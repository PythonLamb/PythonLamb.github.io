[{"title":"生活随笔——这是田雪！","url":"/2021/10/13/生活随笔——这是田雪！/","content":"\n\n\n\n\n好奇不？好奇就点开看看呗！\n\n\n\n<!--more-->\n\n\n\n\n\n\n\n## 个人简介\n\n\n\n姓名：田雪\n\n性别：女\n\n民族：汉族\n\n身高：165\n\n体重：好像是107斤【不是公斤】\n\n出生日期：2002年12月03日\n\n籍贯：内蒙古通辽市开鲁县人\n\n爱好：睡觉、跳一跳、熬夜\n\n特长：懒、懒懒懒！\n\n有什么愿望没有：好像没有\n\n最害怕什么：怕被晒黑\n\n给我的第一印象：咦~这姑娘长得不赖！\n\n个人习惯：吃完饭要打口红、走路慢【可能和我在一起管事】\n\n\n\n\n\n\n\n## 点点滴滴\n\n\n\n我问：有特别喜欢吃的东西吗？\n\n田雪答：没有啥特别喜欢吃的东西！\n\n我心里想：竟然没有特别喜欢吃的东西，太怪了！\n\n\n\n\n\n\n\n\n\n我问：你有什么特别想去旅游的地方吗？\n\n田雪答：没有特别想去的地方！\n\n我心里想：这个女孩，太佛系了\n\n\n\n\n\n\n\n\n\n我问：你有特别喜欢的城市嘛？\n\n田雪答：就喜欢在家这边\n\n我心里想：还行，还行，可以理解\n\n\n\n\n\n\n\n\n\n\n\n每次一起去吃饭，\n\n我问田雪：你感觉好吃吗？\n\n田雪答：还行，每次都是还行！！！！！\n\n我心里想：就不能说一次好吃嘛！\n\n\n\n\n\n\n\n\n\n## 采访环节\n\n\n\n\n\n你最害怕田雪哪里？\n\n最害怕田雪的嘴，太厉害了，损人太狠了！\n\nps：以后田雪的老公你要注意了，哈哈哈\n\n\n\n\n\n\n\n\n\n你最喜欢田雪哪里？\n\n最喜欢田雪的嘴，因为咳咳咳，我想被她损一辈子！\n\nps：我是不是有受虐倾向，NO、NO、NO，好好看看上面一条的ps\n\n\n\n\n\n\n\n\n\n\n\n请说出你最想对田雪说的话！\n\n田雪我想对你说：我想带你的新裙子出去逛街，出去吃饭、出去Happy，如果你有空的话也一起来吧，我会带上我的父母，然后对他们说，老爸老妈你们看，这条裙子我最喜欢了！\n\nps：如果可以........我想和你的新裙子在一起！\n\n可以嘛？田雪\n\n\n\n\n\n\n\n\n\n## 我最喜欢的生活照\n\n\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211013192208.jpg)\n\n\n\n\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211013192159.jpg)\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211013192154.jpg)\n\n\n\n\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211013192018.jpg)\n\n\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211013192101.jpg)\n\n\n\n\n\n未完待续......\n\n","tags":["生活随笔"],"categories":["生活随笔"]},{"title":"爬虫基础——selenium的使用","url":"/2021/10/13/爬虫基础——selenium的使用/","content":"\n\n\n\n\n本文主讲：selenium的安装与使用等等.....\n\n\n\n<!--more-->\n\n\n\n\n\n## selenium环境安装【重点】\n\n\n\n### 什么是selenium以及selenium怎么实现抓取网页数据\n\n\n\n答：selenium是web自动化测试工具，不是浏览器，它常常配合浏览器来实现网站的自动化测试，也就是说selenium可以自动化操作留浏览器进行一些行为，selenium配合浏览器就可以实现数据的抓取（可见即可得）\n\n\n\n\n\n### 怎么查看python安装在哪个路径的指令（win与linux）\n\n\n\nwindow指令：`where python`\n\n![image-20211013152832885](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152832885.png)\n\n\n\n\n\nlinux指令：`whereis python`\n\n![image-20211013152021640](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152021640.png)\n\n\n\n\n\n### 怎么安装 selenium 工具（库）\n\n\n\nWindows + linux指令：`pip3 install selenium`\n\n\n\n\n\n### 安装 selenium + 浏览器工具的环境步骤\n\n\n\n使用selenium + 浏览器最常见的四种组合如下：\n\n1：selenium + PhantomJS\n\n\n\n2：selenium + Chrome + chromedriver\n\n\n\n3：selenium + Firefox + geckodriver\n\n\n\n4：selenium + Edge + \n\n\n\n\n\n注意：其中后面带有driver就是浏览器驱动程序，PhantomJS是无头浏览器因此不需要驱动（行为都在内存中发生！）\n\n\n\n\n\n安装步骤：\n\n注意：下面常用的程序都可以在淘宝镜像网站中下载：   https://npm.taobao.org/mirrors\n\n\n\n第一步：首先确保你的电脑（windows与linux）都安装了这四个浏览器以及 selenium 工具，剩下的就是安装对应的浏览器驱动\n\nPhantomJS下载地址：https://npm.taobao.org/mirrors/phantomjs/\n\n\n\n\n第二步：下载每个浏览器的驱动（下载windows以及linxu版本）\n\nchromedriver下载地址（下载与chrome版本一致的驱动）：https://npm.taobao.org/mirrors/chromedriver/\n注意：没有一致的版本就下载最接近的\n\n\n\ngeckodriver下载地址（下载版本最大的那个驱动）：https://npm.taobao.org/mirrors/geckodriver/v0.29.1/\n\n![image-20211013152113696](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152113696.png)\n\n\n\n\n\n第三步：下载完成驱动后将驱动解压（所有压缩文件全部解压），剪切到对应文件夹下面\n\n\n\nwindows：python路径下面的Scripts文件夹下\n\n![image-20211013152123877](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152123877.png)\n\n\n\n\n\nlinux：家目录下的usr文件夹下的bin文件夹放入成功后，将这个驱动程序权限更改为最高权限\n\n\n\n注意：在linux下放入指定文件夹下的浏览器驱动程序是解压完成的程序，不是压缩文件！！\n\n\n\n\n\n对应指令：\n\n`sudo cp 驱动文件名 /usr/bin  将驱动放入对应文件`\n`sudo chmod  777  /use/bin/驱动文件名`\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152123877.png)\n\n\n\n\n\n第四步：进行测试，可以正常打开浏览器并且不闪退即可\n\n![image-20211013152144737](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152144737.png)\n\n\n\n\n\n\n\n## selenium应用【重点】\n\n\n\n\n\n### 怎么利用selenium配合浏览器打开指定网页并且对网页进行一些操作\n\n\n\n语法： \n\n`from selenium import webdriver`                导入模块\n\n`浏览器对象 = webdriver.Chrome( )`      打开Chrome浏览器（也可以是其他浏览器，前提是安装其他浏览器的驱动）\n\n`浏览器对象.get（“指定网站”）`           在Chrome浏览器内打开指定网站\n\n​\t\n\n\n\n### 浏览器对象的一些常用方法以及属性\n\n\n\n答：在获得浏览器对象之后，我们可以对浏览器对象执行以下方法  其中browser代指浏览器对象\n\n\n\n`browser.get（“指定网站”）` ：在浏览器内打开指定网站\n\n\n\n`browser.maximize_window( )`：将浏览器窗口最大化\n\n\n\n`browser.save_scrrenshot(\"图片名称\")`：将浏览器当前所在的页面进行截图保存\n\n\n\n`browser.page_scurce`：获取浏览器当前页面的前端最终渲染的数据代码\n\n\n\n`browser.page_scurce.find（“字符串”）`：获取浏览器当前页面的前端最终渲染的数据代码，并在代码中查找执行字符串，查不到直接返回-1，常常用于网站最后一页的判断\n\n\n\n`browser.quit( )`：关闭浏览器\n\n\n\n`browser.close（）`：关闭当前网页\n\n\n\n`element_obj= browser.find_element_by_xpath(xpath语法)`：在浏览器内获取第一个符合xpath语法的结点对象\n\n\n\n`element_obj= browser.find_element_by_id (id属性值)`：在浏览器内获取第一个符合id属性值的结点对象\n\n\n\n`element_obj= browser.find_element_by_name (name属性值)`：在浏览器内获取第一个符合name属性值的结点对象\n\n\n\n`element_obj= browser.find_element_by_class_name (class属性值)`：在浏览器内获取第一个符合class属性值的结点对象\n\n\n\n`element_obj= browser.find_element_by_link_text (a标签文本)`：在浏览器内获取第一个符合a标签内文本的结点对象\n\n\n\n`element_obj_list = browser.find_elements_by_xpath(xpath语法)`：在浏览器内获取全部符合xpath语法的结点对象，并且返回存放所有对象的列表\n\n\n\n\n\n\n\n### 利用selenium+浏览器匹配数据的注意事项\n\n\n\n1：浏览器对象在查找指定节点对象时，如果方法中的element不带s，那么就查找第一个符合规则的结点对象返回，如果带s，那就查找所有符合规则的结点对象，并且存放在指定列表中返回这个列表\n\n\n\n2：浏览器对象根据xpath查找指定节点时，可以直接在前端的控制台找到指定节点，右键复制当前节点的xpath即可，这是为什么呢？因为利用selenium获得的数据是前端最终渲染出来的数据，而不是响应源代码，因此利用selenium匹配数据真正实现了可见即可得，管你是动态渲染还是什么，只有一句话，牛批！\n\n\n\n图示：\n\n![image-20211013152221244](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152221244.png)\n\n\n\n\n\n四：浏览器对象在成功匹配指定节点后对这个结点的一些操作指令\n\n\n\n指定节点对象 . send_keys(\"待查找的数据\")：向这个结点对象发送指定数据，一般这样的结点都是搜索框结点\n\n\n\n`指定节点对象.click（）`：点击这个结点\n\n\n\n`指定节点对象.clear（）`：清空结点对象中的内容（常用于清空搜索框中的默认数据）\n\n\n\n`指定节点对象.get_attribute( )`：获取这个结点的属性值\n\n\n\n`指定节点对象.get_attribute( “title”)`：获取这个结点的 title 属性值\n\n\n\n`指定节点对象.text` ：获取这个结点对象的文本值（包括当前节点以及所有子节点的文本）！\n\n\n\n注意事项：\n\n1：获取结点以及子节点的文本内容，是利用结点对象的text属性，而不是text方法！！！！，切记切记！！！\n\n2：浏览器对象.find_elements_by_xpath（xpath表达式）获取到所有符合xpath表达式的结点对象，这个结点对象与利用etree库的xpath表达式在响应源代码中提取的结点对象不一样！！！\n\n\n\n总结截图：\n\n![image-20211013152239461](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152239461.png)\n\n\n\n\n\n\n\n## selenium高级应用【重中之重】\n\n\n\n### 怎么把Chrome以及firefox浏览器设置为无头模式！\n\n\n\n为什么要设置为无头浏览器？\n\n答：无头浏览器性能更好一些，可以在不打开浏览器窗口的情况下进行数据的抓取\n\n\n\n\n\n设置语法：\n\n`from selenium import webdriver `            导入模块\n\t\t\n`options = webdriver.ChromeOptions( )`     创建选项对象，注意ChromeOptions( ) 中的O是大写\n\t\t  \n`options.add_argument(\"--headless\") `        向这个选项对象中添加“headless”参数，代表无头\n\t\t\n`Browser = webdriver.Chrome(options = options) `    创建浏览器时，将设置好的options参数传入\n\t\t\n\n图示：\n\n![image-20211013152255642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152255642.png)\n\n\n\n\n\n### selenium打开的浏览器怎么执行javascript脚本\n\n\n\n语法：`浏览器对象.excute_script(\"javascript脚本代码)`\n\n\n\n实例：`browser.excute_script ( \" window.scrollTo (0,document.body.scrollHeight ）\" )`\n\n\n\n浏览器执行 window.scrollTo (0,document.body.scrollHeight）这段javascript代码，将滚动条滚到最下方\n\n\n\n图示：\n\n![image-20211013152310256](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152310256.png)\n\n\n\n\n\n### selenium配合浏览器抓取数据的注意事项\n\n\n\n1：执行网站换页操作时，如果网站有输入第几页跳转，尽量用那个进行换页，因为如果程序在某一页报错，可以很容易知道在那一页报错\n\n![image-20211013152321863](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152321863.png)\n\n\n\n2：抓取动态网页时，浏览器对象需要执行javascript脚本代码（将滚轮滑到最底部！）\n\n\n\n3：利用find_enements_by_xpath抓取的结点对象集合，然后再循环遍历，调用结点的text属性，获取当前节点以及后代节点的所有文本数据，如果数据不容易被处理，可以在当前节点下调用find_enement_by_xpath方法，在查找具体的数据结点，然后调用text属性获取数据！！\n\n![image-20211013152405296](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152405296.png)\n\n\n\n\n4：如果在前端页面源码内复制结点的xpath查找不到数据！！！！，记得要自己在写一下xpath语句试一试\n\n\n\n\n\n\n### 怎么利用selenium操控键盘操作（不是特别重要）\n\n![image-20211013152428259](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152428259.png)\n\n\n\n\n\n### 怎么利用selenium操控鼠标操作\n\n\n\n用selenium操作鼠标有什么用？\n\n答：有的网站部分功能是动态加载的，你需要把鼠标放在一些元素结点上面，其他的元素结点才能被加载出来，这是我们就要用selenium模拟鼠标操作，将鼠标移动到元素节点上，这样才可以操作动态加载的其他元素结点\n\n\n\n![image-20211013152506145](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152506145.png)\n\n\n\n\n\n\n\n操作语法：\n\n`from selenium.webdriver import ActionChains`            导入模块\n\n\n\n`ActionsChains（浏览器对象）.move_to_element(to_element = 指定节点). perform（）`   将鼠标移动到指定目标结点处！\n\n\n\n\n\n注意事项：必须要执行 perform方法才能真正将鼠标移动到目标结点处！\n\n\n\n图示：\n\n![image-20211013152526149](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152526149.png)\n\n\n\n\n\n代码截图：\n\n![image-20211013152534553](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152534553.png)\n\n\n\n\n\n### 怎么利用selenium切换句柄（切换浏览器窗口）\n\n\n\n切换句柄的使用场景：利用selenium创建浏览器对象，打开指定网站，在网站内点击一个链接后，又打开了一个新的窗口，但是我们的浏览器对象还是处在第一个网站的结点源代码中，想要对新窗口中的网站进行一些操作就要将浏览器对象切换到后打开网站的那个结点源代码中（句柄）\n\n\n\n语法：\n\n\n\n`from selenium  import webdriver`                                 导入模块\n\n\n\n`浏览器对象 = webdriver.Chrome( )`                  创建浏览器对象\n\n\n\n`all_handles = 浏览器对象.window_handles`            获取当前浏览器对象所有打开的窗口对象，并存放到列表内（左边第一个窗口列表下标为0）\n\n\n\n`浏览器对象.switch_to.windows(指定窗口对象)`      将浏览器切换到指定窗口\n\t\n\t\n\n注意事项：\n\n1：window_headles 方法功能是获取当前浏览器的所有窗口对象，并存放在一个列表内，最左面的窗口列表下标为0\n\n2：切换窗口中的窗口不是正常浏览器中的窗口，这里指代浏览器所处在的那个结点源代码中！\n\n\n\n代码截图：\n\n![image-20211013152555406](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152555406.png)\n\n\n\n\n\n\n## selenium高级操作【重中之重】\n\n\n\n须知：如果在前端页面源码内复制结点的xpath查找不到数据！！！！，记得要自己在写一下xpath语句试一试\n\n\n\n\n\n### selenium 控制浏览器对象切换iframe（内嵌框架）的背景\n\n\n\n答：有的网站前端渲染后的html代码是嵌套类型的，就是一个网页html代码中有一个或者多个iframe结点，其中一个iframe结点就代表一个全新的网页（一般网站的登录功能都是一个iframe结点），当利用 selenium 获取 iframe 结点下面子节点并对其操作时，是不能成功的，因为 selenium 只能从 iframe 结点外面的其他结点数据中查找其他的元素，对于这种情况就要用 selenium 控制浏览器切换 iframe了，这样就可以定位到 iframe 结点中的其他结点并对其操作啦！！\n\n\n\n注意：一般登录功能区都在iframe结点下面哦！！\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152716642.png)\n\n\n\n\n\n\n\n\n### selenium 怎么切换 iframe\n\n语法1：\n\n`from selenium import webdriver    `\n\n\n\n导入模块\n\n`iframe_node = 浏览器对象.find_element_by_xpath( \"xpath语法\" )`          查找待切换的iframe结点对象\n\n\n\n`浏览器对象.switch_to.frame(查找到的iframe结点对象)`                利用switch方法进行切换，切换成功后即可定位iframe结点下的子节点并对其操作\n\t\t\n\t\n\t\n语法2：\n`from selenium import webdriver  `        \n\n\n\n导入模块\n`浏览器对象.switch_to.frame ( iframe结点的 id|name 属性值 ) `                              通过目标 iframe 结点的 id、name属性值可直接定位iframe结点切换\n\n\n\n\n\n\n\n注意事项：\n\n1：浏览器对象.switch_to.frame(查找到的iframe结点对象)  中的frame没有I\n\n2：如果目标 iframe 结点中有 id 以及 name 属性，那么直接通过第二种语法定位iframe结点\n\n\n\n代码截图：\n\n![image-20211013152746826](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152746826.png)\n\n\n\n\n\n\n\n\n### selenium 切换到iframe结点后怎么切换回来（其他的层）\n\n\n\n语法：\n\n`浏览器对象.switch_to.parent_frame( )`：切换到当前iframe结点的上一级处！\n\t\n`浏览器对象.switch_to.default_content( )`：切换到主界面（刚打开浏览器所在的界面）\n\t\n\t\n\t\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["爬虫基础篇"],"categories":["爬虫基础篇"]},{"title":"爬虫基础——爬取动态网页与Cookie模拟登录","url":"/2021/10/13/爬虫基础——爬取动态网页与Cookie模拟登录/","content":"\n\n\n\n\n本文主讲：怎么爬取动态加载的页面及其Cookie模拟登录等等.....\n\n\n\n<!--more-->\n\n\n\n## 爬取动态网页的操作流程！【重中之重】\n\n\n\n\n目标：掌握爬取动态网页的操作流程\n\n\n\n### 爬取动态网页的操作流程（浏览器控制台流程）\n\n\n\n第一步：打开动态加载的网页\n\n\n\n第二步：按下F12进行检查找到网络选项内的XHR栏等待抓包\n\n\n\n第三步：刷新动态网页\n\n\n\n第四步：对动态网页进行一些操作使异步加载的数据包加载出来（动态数据包也就是XHR内的数据包）\n\n\n\n第五步：分析动态加载的数据包\n\n\n\n第六步：利用python模拟发送请求！\n\n\n\n\n\n\n\n## 爬取动态网页【重中之重】\n\n\n\n目标：\n1：掌握什么是动态网页\n2：掌握抓取动态网页的步骤以及方法\n3：掌握抓取动态网页的注意事项\n\t\n\n\n\n### 什么是动态网页\n\n\n\n答：动态网页应该具备下面其中一个特点\n\n\n\n特点1：网页的数据在源代码中查不到（网页源代码内没有你要找的数据）（比如腾讯招聘）\n\n\n\n特点2：当你在网页中点击下一页或者其他操作时，网页局部刷新（比如小米应用网）\n\n\n\n特点3：当你在网页中进行一些操作时（滑动滑轮等），数据才加载出来（比如豆瓣电影）\n\n\n\n动态网站：腾讯招聘、小米应用网、豆瓣电影、有道翻译等等\n\n\n\n\n\n### 抓取动态网页的步骤以及方法（小米应用网为例------局部刷新的url网站）\n\n\n\n第一步：按下F12进入检查，找到网络选项开始进行抓包\n\n\n\n第二步：动态加载的数据包一般都是json格式的，对动态网页进行操作让数据加载出来，然后直接筛选XHR格式的数据包即可\n\n![image-20211013111214877](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111214877.png)\n\n\n\n\n\n第三步：分析XHR选项内的数据包，找到真正要抓取的那个数据包（包含数据的数据包）\n\n![image-20211013111224434](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111224434.png)\n\n\n\n\n\n第四步：分析请求的url以及请求方式，如果是get请求，着重分析查询参数，post请求着重分析Form_data，找到所有动态加载的数据包其中的规律\n\n![image-20211013111231314](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111231314.png)\n\n\n\n\n\n第五步：利用 python 程序模拟浏览器向上面的 url 发送请求即可（构建查询参数）\n\n\n\n\n\n\n\n### 抓取动态网页的注意事项\n\n\n\n1：动态加载的网页其中动态加载的数据包一般都是json格式（python中的字典格式）的字符串\n\n2：requests模块向目标url发送请求获取对象的 json 方法可以将 json 格式的字符串转换为 Python 格式的字典！\n\n\n\n\n\n\n\n\n\n\n\n## json解析模块的使用【重中之重】\n\n\n\n\n目标：\n1：掌握 json 标准库模块的使用场景\n2：掌握 json 标准库模块的loads方法以及dump方法功能\n\t\n\t\n### json 标准库模块的使用场景\n\n\n\n答：在抓取动态网页的异步加载的数据包时（XHR），网页服务器返回的数据包源代码是 json 格式的字符串，这时我们就要用到json解析模块来对这些json格式的字符串进行处理！！\n\n\n\n### json 标准库模块的 loads 方法以及 dump 方法功能\n\n\n\n`json.loads（json格式字符串）`方法\n\n功能：将 json 格式的字符串转换为 Python 格式的字典\n\n参数：json格式的字符串（动态加载的数据包网页源代码）\n\n图示：\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111231314.png)\n\n\n\n\n\n\n\n\n\n`json.dump（python，file，ensure_ascii = False）`\n\n\n\n功能：将Python格式的字典、列表 转换为 json 格式的字符串并且保存到 file 文件内（一般都是json后缀的文件）！\n\n参数：\n\n参数1：Python格式的列表、字典\n\n参数2：待保存数据的文件名，一般是json后缀的文件\n\n参数3（ensure_ascii）：默认值为True，我们要给改为False，否则 json 格式的字符串包含中文保存到文件中，在文件内不会正常显示！\n\n\n\n\n\n语法：\n\n```python\nwith open（“info.json”，“w”） as f：\n\tjson.dump（Python格式的字典、列表， f ，ensure_ascii = False）\n```\n\n\n\n图示：\n\n![image-20211013111312698](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111312698.png)\n\n\n\n\n注意事项：\n1：loads方法有s，dump方法没有s\n2：只要对文件进行操作就要利用with open打开文件\n\n\n\n\n\n\n## 多线程爬虫【重中之重重】\n\n\n\n目标：\n1：掌握多进程以及多线程的适用场景\n2：掌握创建多线程的步骤以及常用语法\n3：掌握多线程爬虫的工作原理\n4：掌握Python中队列的一些操作！\n5：掌握多线程对全局变量加线程锁的目的\n\t\n### 多进程以及多线程的适用场景\n\n\n\n多进程适用场景：计算机密集型的操作（CPU密集型），比如说计算大量数据时，多进程可以保证同一时间多个进程同时工作，就是比较消耗内存\n\n\n\n多线程适用场景：I/O密集型操作，比如说网络I/O、本地磁盘I/O，爬虫就是网络I/O与本地磁盘I/O（存储数据）结合体，多线程因为GIL的存在同一时间只能保证有一个线程在工作，但是也能保证同意时间肯定有一个线程在工作\n\n\n\n\n\n### 创建多线程的步骤以及常用语法\n\n\n\n步骤：\n\n第一步：`from threading import Thread`   导入模块\n\n\n\n第二步：`t = Thread（target=任务函数名，args=（））`  创建线程对象     args = （），是元组给任务函数传参，相当于位置传参\n\n\n\n第三步：`t.start（）`    启动线程\n\n\n\n第四步：`time.sleep（1）`  等待线程任务执行完毕\n\n\n\n第五步：`t.join（）`  当 t 线程任务执行结束后 回收 t 这个线程（防止死线程的产生）\n\n\n\n\n\n注意事项：\n\n1：join（）方法功能是等待创建的某线程执行任务函数结束后进行线程的回收\n\n2：利用 join 方法时程序会进入阻塞状态，回收完执行任务完毕的线程后才解除阻塞！\n\n\n\n\n\n\n\n常用建立多线程语法截图\n\n![image-20211013111344803](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111344803.png)\n\n\n\n\n\n\n\n### 多线程爬虫的工作原理\n\n![image-20211013111354627](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111354627.png)\n\n\n\n\n\n### Python中队列的一些操作【数据存入、取出、取数据阻塞等问题】！\n\n\n\n队列存入数据的优先级：队列中的数据是先进先出，从队尾进入，队首取出\n\n\n\n\n\n操作队列的步骤：\n\n第一步：`from queue import Queue`     导入队列模块\n\n\n\n第二步：`q = Queue（）`     创建q这个队列\n\n\n\n第三步：`q.put`（存入队列的数据）    向q这个队列存入数据\n\n\n\n第四步：`q.get（）`   从q这个队列中取出存入的数据\n\n\n\n第五步：`q.empty（）`  判断队列中数据是否为空，是返回True，不是返回False\n\n\n\n\n\n队列取数据出现的问题：当利用 get 方法从队列中取数据时，队列数据为空，那么程序就会进入阻塞状态，有什么办法让程序不阻塞嘛？\n\n\n\n解决办法：\n1：`q.get（timeout=2`）   设置阻塞时间，当超过两秒钟还未从队列中取得数据，程序直接报错\n\t\t\n2：`q.get（block=False）` 在队列取不到数据直接报错，block默认值为True，也就是取不到数据程序一直处于阻塞状态\n\t\t\n3：`q.get_nowait（）`  利用get_nowait方法取数据，队列内没有数据直接报错！！\n\n\n4:\n\n```python\nwhile  not q.empty( ):     \n\tq.get( ) \n```\n判断队列内是否有数据，有数据才取，没数据不取\n\t\t\n\n\n\n\n\n### 多线程对全局变量加线程锁的目的以及加锁步骤\n\n\n\n加线程锁目的：多个线程共享（共同操作）一个全局变量时（全局文件变量、全局变量、全局队列变量），可能会产生资源竞争问题，这时就要对全局变量进行加线程锁，等一个线程对全局变量操作完全结束后，在进行线程锁的释放！，可避免多线程间资源的竞争\n\n\n\n\n加线程锁步骤：\n\n第一步： `from threading import Lock`  导入线程锁模块\n\n\n\n第二步：`l_obj = Lock（）` 创建一个线程锁\n\n\n\n第三步：`l_obj.acquire( )`     某一个线程在对全局变量操作之前进行加锁 \n\n\n\n第四步：`l_obj.release（） ` 某一个线程在对全局变量操作完全结束后进行开锁 \n\n\n\n注意事项：对某个全局变量上线程锁，在线程锁未开锁之前，又给这个全局变量上了一把锁，这是程序会进入阻塞状态\n\n\n\n\n\n图示：\n\n不加线程锁造成的多线程间资源竞争问题\n\n![image-20211013111448726](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111448726.png)\n\n\n\n加线程锁解决多线程之间的资源竞争'\n\n![image-20211013111459472](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111459472.png)\n\n\n\n\n\n多线程爬虫共同操作全局变量【同一个资源】（文件变量、队列变量等）的注意事项：只要是线程对全局变量（同一个资源）进行了操作都要加上一把线程锁！！！\n\n注意事项：全局变量（全局队列等）有几个，那么就要创建几把线程锁\n\n\n\n\n\n\n\n\n\n## 单级页面的多线程爬虫框架【重中之重】\n\n\n\n目标：掌握单级页面的多线程爬虫框架（各种函数）\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%8D%95%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB.png)\n\n\n\n\n\n\n## 多级页面的多线程爬虫框架【重中之重】\n\n\n\n目标：掌握多级页面的多线程爬虫框架\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB.png)\n\n\n\n\n\n\n\n\n## Cookie模拟登陆【重点】\n\n\n\n目标：\n1：掌握Cookie是什么并且有什么用\n2：掌握怎么用 Python程序实现Cookie模拟登陆（好几种方法）\n\t\n\t\n\n### Cookie是什么并且有什么用\n\n\n\nCookie适用场景：抓取需要登录才能获取数据的网站\n\n\n\n答：当客户端向需要登录的网站服务器发送请求时，当登录成功后，服务器会给浏览器分发一段不超过4k大小的Cookie文本（浏览器将Cookie保存起来），服务器自身保存一段session文本，浏览器保存的Cookie相当于一个身份证，当你在向这个网站的其他页面发送请求时，会携带保存的Cookie，服务器会将浏览器发送请求时携带的Cookie与自身的session进行比对，比对成功后，放行（可以访问这个网站的其他页面），比对失败不放行（需要重新登录！）\n\n\n\n\n\n### 怎么用 Python程序实现Cookie模拟登陆（好几种方法）\n\n\n\n第一种方法：暴力模拟登录——手动查找 Cookie，将 Cookie 充当请求标头内 headers 的一个参数\n\n\n\n第一步：浏览器打开需要登录的网站，先登录一次\n\n![image-20211013111559051](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111559051.png)\n\n\n\n\n\n第二步：登录成功后进入到待抓取数据的页面\n\n![image-20211013111605707](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111605707.png)\n\n\n\n第三步：按下F12找到网络选项，刷新页面，找到所有包里面的第一个包（一般是第一个包，主要是看这个包请求的url与目标url是否相同）\n\n![image-20211013111613690](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111613690.png)\n\n\n\n第四步：找到这个包里面请求信息（请求标头）的Cookie，复制\n\n![image-20211013111620460](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111620460.png)\n\n\n\n第五步：打开 pycharm 写程序发送请求\n\n![image-20211013111627910](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111627910.png)\n\n\n\n\n\n模拟Cookie登录的第二种方法——Cookies参数方式\n\n\n\n方法：将手动抓取登录后的 Cookie 作为 requests 模块发送get请求的 cookies 参数传入\n\n\n\n参数类型：字典     需要将抓取的cookie字符串处理为字典才能传参\n\n\n\n语法：`requests.get（url=url，headers=headers，cookies=cookies）`    其中 cookies 就是处理好的 cookie字典\n\n\n\n\n\n注意事项：手动抓取登录后的cookie和第一种方法抓取的一样！\n\n\n\n截图：\n\n![image-20211013111641474](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111641474.png)\n\n\n\n\n\n将cookie字符串处理为cookies参数\n\n![image-20211013111650257](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111650257.png)\n\n\n\n\n\n\n\n第三种方法：requests模块的session类实现Cookie模拟登录\n\n\n\n语法：\n\t\n`s = requests.session（）创建session对象`\n\t\n`s.post(url = url,headers = headers,data = data)`   向登录网站的接口发送请求（get或者是post请求具体分析），进行登录网站\n\t\n`html = s.get(url = url,headers = headers).text`   \n\n上一步成功实现后，s 对象就是已经携带了登录成功的Cookie并保持会话，我们这是就可以向登录成功的任何页面发送请求获取数据了\n\n\n\n\n\n\n未完待续......\n\t\n\n\n\n\n\n\n\n\n\n","tags":["爬虫基础篇"],"categories":["爬虫基础篇"]},{"title":"爬虫基础——requests模块与xpath语法","url":"/2021/10/13/爬虫基础——requests模块与xpath语法/","content":"\n\n\n\n\n本文主讲：爬虫请求库requests的使用与xpath语法解析数据、User-agent随机生成库、代理IP、搭建代理IP池、关于js加密那些事等等.....\n\n\n\n<!--more-->\n\n\n\n\n\n## requests模块的使用【重点】\n\n\n\n须知：一个网页右键检查（F12）所看到的代码是浏览器最终渲染完成的代码，它和网站服务器给你相应的源代码不一定相同，抓取数据的时候一定要以源代码为主，检查可以帮助你快速查找数据！！！\n\n\n\n目标：\n\n1：掌握 requests 模块的基本使用（获取url响应数据）\n\n2：掌握 requests 模块响应对象一些基本属性\n\n3：掌握 requests 模块响应对象的 json（）方法作用\n\n​\t\n​\t\n\n### requests 模块的基本使用（获取url响应数据）\n\n\n\n实现功能：向指定url发送请求（User-Agent经过包装）获取响应数据\n\n语法：\n\n1：res_obj = requests.get（url = url，headers = headers）          →向目标url发送get请求，返回响应对象\n\n\n\nhtml_data = res_obj.text                                                           →利用响应对象的text属性获取响应源代码\n\n\n2：html_data = requests.get（url = url，headers = headers，timeout=3）.text            → 向目标url发送get请求，获取响应源代码\n\n\n\n参数：\n\n1.url：请求的目标url\n\n2.headers：包装的请求标头信息\n\n3.timeout：设置请求时间，如果向指定网站发送请求，等待的响应时间超过3秒，则抛出异常（可捕获用！）\n\n\n\n注意事项：\n\n1：在 requests 模块内的响应对象没有方法，全都是属性，例如 text 属性\n\n2：requests 模块是第三方模块安装语法 pip3 install requests\n\n3：响应对象的text属性获取的是字符串响应数据\n\n\n\n截图：\n\n![image-20211013105030475](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211013105030475.png)\n\n\n\n\n\n设置timeout参数抛出异常截图：\n\n![image-20211013105037895](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105037895.png)\n\n\n\n\n\n### requests 模块响应对象一些基本属性\n\n\n\n\n\nres_obj = requests.get(url = url,headers = headers)          →创建指定url服务器的响应对象\n\n下面是响应对象的一些常用属性\n\n\n\nres_obj.text：获取指定url的响应源代码（字符串类型的）\n\n\n\nres_obj.content：获取指定url的响应源代码（bytes类型的，也就是二进制的响应源代码）\n\n\n\nres_obj.url：获取服务器响应数据的真实url地址\n\n\n\nres_obj.status_code：获取客户端与服务端进行http通信的状态码\n\n\n\n\n\n截图：\n\n![image-20211013105054440](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105054440.png)\n\n\n\n### requests 模块响应对象的 json（）方法作用\n\n\n\n方法名：json（）\n\n语法：requests响应对象.json（）\n\n功能：将 json 格式的字符串【字典格式的字符串】转换为python格式的字典！\n\n\n\n代码演示\n\n不使用json（）方法返回的数据类型\n\n![image-20211013105105938](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105105938.png)\n\n\n\n使用json（）方法返回的数据类型\n\n![image-20211013105112398](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105112398.png)\n\n\n\n\n\n## requests模块抓取图片、视频等【重点】\n\n\n\n须知：一个网页右键检查（F12）所看到的代码是浏览器最终渲染完成的代码，它和网站服务器给你相应的源代码不一定相同，抓取数据的时候一定要以源代码为主，检查可以帮助你快速查找数据！！！\n\n\n\n目标：\n\n1：掌握抓取网站图片、视频的一些注意事项\n\n2：掌握怎么利用 os 标准库判断一个路径是否存在以及怎么创建文件夹！\n\n2：掌握利用 requests 模块抓取网站图片的步骤\n\n​\t\n\n\n\n### 抓取网站图片、视频的一些注意事项\n\n\n\n\n\n图片、视频在计算机内的存储方式：图片、视频、音频均以二进制（bytes）数据的方式进行存储\n\n\n\n图片、视频等的 url 地址：图片、视频等文件的源url地址不是浏览器最上方的地址，而是在图片上右击选择复制图片源地址的地址\n\n\n\n抓取注意事项：\n\n1：因此在向图片、视频等 url 源地址发送请求获取源代码数据时，应该获取二进制（bytes）网页源代码\n\n2：获取到二进制网页源代码后，保存文件时，只要是图片、视频等，都要以二进制的方式打开指定文件！！\n\n​\t\t\t\n\n### 怎么利用 os 标准库判断一个路径是否存在以及怎么创建文件夹！\n\n\n\n判断路径是否存在功能语法实现：\n\n\n\n1.`import os`              →导入模块\n2.`is_no = os.path.exists（指定路径文件夹或文件） `    →判断指定路径文件夹（文件）是否在计算机存在，是返回True，不在返回False\n\t\t\t\t\t\t\n\n创建文件夹语法实现：\n\n1.`import os`              →导入模块\n2.`os.mkdir（文件夹名）`              →文件夹名可以是指定路径（绝对路径、相对路径）下的文件夹\n\t\t\t\t\n\n\n\n代码演示：\n\n![image-20211013105138508](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105138508.png)\n\n\n\n\n\n### 三：利用 requests 模块抓取网站图片的步骤\n\n\n\n第一步：找到图片的源地址（不是浏览器最上方的url）\n\n![image-20211013105157588](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105157588.png)\n\n\n\n第二步：利用 requests 模块向图片源地址发送请求，获取二进制（bytes）类型的网页源代码\n\n\n\n实现语法：\n\nres_obj = requests.get(url=图片源地址，headers=包装的请求头)          →创建图片源地址响应对象\nhtml_b_data = res_obj.content                                                     →利用对象的content获取网页二进制源代码\n\t\t\n\n第三步：利用 os 模块判断图片待保存的路径（文件夹）是否存在，不存在创建这个路径文件夹\n\n\n\n实现语法：\n\n```python\n\t\tif  os.path.exists（图片待保存文件夹路径）：\n\t\t\tprint（“路径存在”）\n\t\telse：\n\t\t\tprint（“路径不存在即将创建”）\n\t\t\tos.mkdir（图片待保存的文件夹路径）\n```\n\n\n\n第四步：根据自己的想法创建图片待保存的文件名，并且拼接图片待保存路径以及文件名\n\n\n\n创建图片名实现语法：\n\n\n\n1.根据图片源地址创建图片保存名称（源地址后缀必须是.jpg或者.png等）：  图片源地址字符串 [ -10 : ]                  →获取图片源地址的最后10个字符串作为文件名\n\n\n\n2：根据抓取的图片标题创建图片保存名称\n\t\t\n\n3：单纯的遍历某个数字区间命名\n\t\n\t\n拼接图片待保存路径以及文件名语法：带保存路径 + 图片带保存名\n\n\n\n第五步：以二进制读写方法打开已经拼接好的的路径文件（不是路径文件夹）\n\n实现语法：\n\n```python\nwith open （拼装好的路径文件，“wb”）as f ：\n\tf.wither（向图片源地址请求的二进制源代码）\n```\n\n\n\n实现代码截图（部分）：\n\n![image-20211013105224121](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105224121.png)\n\n\n\n\n\n\n\n\n## User-Agent库随机生成用户代理【重点】\n\n\n\n目标：掌握怎么用 Python 库 fake_useragent（非标准库） 生成随机的用户代理\n\n\n\n### Python 库 fake_useragent（非标准库）生成随机的用户代理\n\n\n\n安装：`pip3 install fake_useragent`\n\n功能：随机生成用户代理（User-Agent）\n\n语法：\n导入模块：`from fake_useragent import UserAgent`\n生成随机代理：`UserAgent（）.random`\n\t\n\n爬虫用法：\n\n导入模块：`from fake_useragent import UserAgent`\n\n生成随机代理：`headers = {“User-Agent”：UserAgent（）.random}`\n\n\n\n注意事项：生成随机用户代理时，利用的是UserAgent方法，不是random方法，random只是属性！！！\n\n\n\n截图演示：\n\n![image-20211013105241914](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105241914.png)\n\n\n\n\n\n## 安装爬虫相关的浏览器插件【重点】\n\n\n\n目标：\n1：掌握安装插件的两种方式\n2：掌握与爬虫相关的插件都有哪些以及其功能\n\t\n### 的两种方式\n\n\n\n第一种方式：直接在浏览器对应的扩展商店里面搜索安装即可\n\n\n\n第二种方式：如果浏览器里面的扩展商店没有目标插件，可去第三方插件网站将插件下载至计算机内，在进行离线安装\n推荐第三方插件网：极简插件_Chrome扩展插件商店_优质crx应用 (zzzmh.cn)\n\n\n\n### 关的插件都有哪些以及其功能\n\n\n\n插件1：xpath helper    （解析网页源代码中的html（xml）代码，提取相应数据）\n\n\n\n插件2：JSONView         （解析网页源代码中的json文档）\n\n\n\n插件3：Proxy SwitchyOmega  （轻松切换代理）\n\n\n\n插件截图\n\n![image-20211013105329439](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105329439.png)\n\n\n\n\n\n\n\n## xpath语法详解【重点】\n\n\n\n目标：\n1：掌握什么是 xpath \n2：掌握 xpath 匹配数据的几种语法格式\n3：使用 xpath 的一些注意事项\n\t\n### xpath \n\n\n\n答：xpath 是在 xml 文档中匹配数据的一种查询语言（俗称xml路径语言），因为 xml 文档与 html 文档结构非常类似，所以 xpath 也可以用在匹配 html 文档数据中（爬虫提取数据）\n\n\n\n\n\n### xpath匹配数据的几种语法格式\n\n\n\n`/div`匹配文档中所有的 div 标签，返回匹配的内容对象\n\n\n\n`/div/p`匹配文档中所有的div标签下的一级 p 标签，返回 p 标签下（包括p标签子标签）的所有的文本内容对象（是文本结点对象，不是字符串类型的文本）\n\n\n\n`/div//p`匹配文档中所有 div 标签下的所有级别 p 标签（包含在div标签内其他标签下p标签），返回 p 标签下（包括p标签内子标签）的所有的文本内容对象（是文本结点对象，不是字符串类型的文本）\n\n\n\n`/div/p[1]`匹配文档中所有div标签内的第一个 p 标签，返回这个 p 标签下的所有文本内容对象\n\n\n\n`/div[@class=\"name\"]`匹配文档中属性包含 class=\"name\"的所有div标签，返回这个div标签下的所有文本内容对象\n\n\n\n`/div/p@src`匹配文档内所有div标签下的p标签，获取p标签中src属性的值（是字符串类型不是文本对象类型）\n\n\n\n`/div[@class=\"byd\"] | //div[@class=\"bm\"]`匹配文档内class属性为“byd”或者“bm”的所有div标签，返回下面所有标签的文本内容对象（不是字符串类型）\n\n\n\n`/li[ contains(@class,\"car_\")]`匹配class属性中包含“car_”内容的所有 li 标签，返回下面所有标签的文本内容对象（不是字符串类型）\n\n\n\n`/li[@class=\"name\"]/text（）`匹配 class 属性值为“name'”的所有 li 标签，并且返回 li 标签中（不包括li子标签）的文本内容（字符串类型）\n\n\n\n整体图示\n\n![image-20211013105409947](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105409947.png)\n\n\n\n\n\n### path 的一些注意事项\n\n\n\n最重要一条：xpath语法的开头查找标签必须要加两条//，一条/不能成功匹配\n\n\n\n1.xpath语法中只要与条件有关，就要在条件两侧加上 [ ]\n\n\n\n2.xpath语法内只要与标签属性有关，就要在属性前面加上@\n\n\n\n3.xpath语法中末尾是 /text（）或者 /@属性值，那么获取的值就是字符串类型的文本内容，除此之外获取的全部都是文本内容对象（不是字符串）\n\n\n\n4.xpath语法是 //div/p/text（），只匹配所有div标签下p标签中的文本内容（字符串），不能匹配p标签下其他子标签的文本内容！！！\n\n\n\n5.xpath语法是 //div/p，匹配所有div标签下p标签中（包含p标签下的其他子标签）的文本内容对象（不是字符串）\n\n\n\n\n\n6.html一段文档是 <p class=\"name\", id=6> 姓名 </p>，其中class与id都是属性，匹配的文本内容是姓名，不是其他的！\n\n\n\n\n\n\n\n\n## lxml库搭配xpath语法实现数据提取【重点】\n\n\n\n目标：\n1：掌握 python 的第三方库 lxml 搭配 xpath 语法在 html 文档内提取数据的使用方法！\n2：掌握 for 循环的另外一种用法以及怎么将列表内元素拼接为一个字符串\n\t\n\t\n\t\n\n### on 的第三方库 lxml 搭配 xpath 语法在 html 文档内提取数据的使用方法！\n\n\n\nlxml库功能：与 xpath 语法搭配使用从而在 html 或者 xml 文档中提取出自己想要的数据\n\nlxml库安装（unubtu）：pip3 install lxml\n\nlxml库在html文档代码内提取数据使用步骤：\n\n\n\n\n\nfrom lxml import etree                                                导入模块\nlxml_obj = etree.HTML( 网页的html源代码 )               创建 lxml 对象用于提取数据\n\ndata_list = lxml_obj.xpath（xpath语法）              利用 xpath 语法从网页的html源代码中提取数据\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\nlxml库搭配xpath语法在html文档中提取数据（电影、汽车等）最常用法如下：\n\n```python\nfrom lxml import etree                                                导入模块\nlxml_obj = etree.HTML( 网页的html源代码 )               创建 lxml 对象用于提取数据\nlable_obj_list = lxml_obj.xpath（xpath语法）           利用 xpath 语法从网页的 html 源代码中 提取 数据存在的 标签结点对象\nfor  lable in data_list:                                          for循环遍历这个标签结点对象\n\tdata_list = lable.xpath(xpath语法)           调用这个标签结点对象的xpath方法，在当前路径下匹配数据\n\tprint(data_list)                                     打印数据\n```\n\n\n\n注意事项：\n\n1：只要 lxml 对象调用了 xpath 方法，那么获取的数据类型一定是列表！！！！\n\n2：在 html 文档中提取数据最常用法中通过 for 循环遍历数据结点对象里面那个xpath语法（第二个xpath）开头要以 . 开头，表示在当前标签结点下查找标签数据！\n\t\t\n\n代码体验（提取数据使用步骤）：\n\n![image-20211013105447337](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105447337.png)\n\n\n\n\n\n最常用法截图：\n\n![image-20211013105454198](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105454198.png)\n\n\n\n\n\n\n\n## requests模块的高级参数【重点】\n\n\n\n\n目标：\n1：掌握 requests 模块 params 参数的功能\n2：掌握 http与https有什么不同\n3掌握 requests 模块 verify 参数的功能\n\t\n### requests 模块 params 参数的功能\n\n\n\n参数名：params\n\n参数类型：字典\n\n功能：对目标 url 的查询参数（中文或英文）进行编码然后拼接整体 url\n\n语法：requests对象.get（url=基准url，headers=headers，params={“查询参数名1”：“查询参数值1”，查询参数名2”：“查询参数值2”}）\n\n\n\n注意事项：利用 requests 库加上 params 参数向目标url发送请求时，url是基准url，也就是不包含查询参数的url，但是要包含最后的 ？\n\t\t\n代码演示：\n\n![image-20211013105520303](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105520303.png)\n\n\n\n\n\n\n\n### http与https有什么不同以及http怎么变为https\n\n\n\n第一：http端口号是80，https端口号是443\n\n第二：https就是在http基础加上了安全套接层（ssl），就是客户端向https协议的网站服务器发送请求，请求报文会被加密，目标url服务器响应的报文也就进行加密\n\n\n\nhttp怎么升级为https：http协议网站向第三方数字证书认证机构进行ssl认证即可，注意必须是要经过第三方数字证书认证机构认证，个人做的ssl证书，浏览器是不信任的！\n\n\n\n\n\n### requests 模块 verify 参数的功能\n\n\n\n参数名称：verify\n\n参数类型：bool 类型（ True【默认】 |  False ）\n\n功能：是否对目标 url （https协议的）进行 ssl 检查，默认检查，如果目标 https协议的url 没有经过第三方数字证书认证机构认证，会抛出 SSLError错误\n\n适用场景：向未经过第三方数字证书认证机构的https网站发送请求时，如果出现SSLError异常，可将verify参数值设置为False\n\n\n\n语法：requests对象.get（url=基准url，headers=headers，verify=False）\n\n\n\n\n\n\n\n\n\n\n## 代理IP的使用【重点】\n\n\n\n目标：\n1：掌握为什么要用代理IP访问web服务器\n2：掌握本机IP与出口IP的区别\n3：掌握代理IP分类以及代理IP的网站\n4：掌握利用requests库如何实现代理IP请求web服务器\n\t\n### 为什么要用代理IP访问web服务器\n\n\n\n答：如果利用自身IP频率过高的访问web服务器，网站一般都有反爬措施，会将自身的IP（出口IP）封掉，这是我们就提现出代理IP的重要性了\n\n\n\n利用代理IP访问web服务器图示：\n\n![image-20211013105558759](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105558759.png)\n\n\n\n\n\n### 本机IP与出口IP的区别\n\n\n\n本机IP：局域网内的IP地址，只能在局域网中使用（内网IP），在windows终端内通过 ipconfig 指令查看的 IP 即本机IP，需要上网的话会通过NET出口，分配出口IP进行上网\n\n![image-20211013105617724](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105617724.png)\n\n\n\n出口IP：外网IP，是你的计算机真正的IP地址（可以显示IP的具体地理位置）\n\n![image-20211013105647739](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105647739.png)\n\n\n\n\n\n### 代理IP分类以及代理IP的网站\n\n\n\n高匿代理IP：通过高匿代理IP访问网站服务器，服务器不知道这是用户通过代理IP访问的（知道代理IP地址），不知道真实用户的IP\n\n\n\n普通代理IP：通过普通代理IP访问网站服务器，服务器知道这是用户通过这个代理IP进行访问的（知道代理IP地址），但是不知道用户的真实IP\n\n\n\n透明代理IP：通过透明代理IP访问网站服务器，服务器知道代理IP地址以及用户的真实IP地址\n\n\n\n常用的免费代理IP网站：\n\n快代理：快代理 - 企业级代理云服务提供商 (kuaidaili.com)\n\n66代理：免费代理ip_服务器http代理_最新ip代理_免费ip提取网站_国内外代理_66免费代理ip (66ip.cn)\n\n\n\n\n​\t\t\t\t\n\n### 利用requests库如何实现代理IP请求web服务器\n\n\n\n实现参数：proxies\n\n参数类型：字典     \n\n\n\n参数设置：\n\n设置基本代理IP                           →  proxies =   {\"协议类型\"，“协议类型：//代理IP地址：代理IP端口号”}\n\n设置专享 | 私密 代理IP                →  proxies = {\"协议类型\"，“协议类型：//用户名：密码@代理IP地址：代理IP端口号”}\n\n\n实例（基本代理IP）：\n\n```python\nproxies = {“http”：“http：//123.51.56.124：8695”，\n\t\t\t\t\t      “https”：“https：//123.51.56.124：8695”}\n```\n\n\n\n实例（独享 | 私密 代理IP）：\n\n```python\nproxies = {“http”：“http：//xxx：……@256.36.125.35：8695”，\n\t\t\t\t\t     “https”：“https：//xxx：……@256.36.125.35：8695”}\n```\n\n\n\n实现语法：\n\n`html_data = requests.get(url=url , headers=headers ,  params=params , proxies=proxies )`\n\n\n\n注意事项：\n\n1：为什么设置代理IP时要设置两个协议的（http|https），当访问网站类型为http时，就用http协议的代理IP进行访问！\n\n2：私密代理以及独享代理或者基本代理都是可以花钱买的，私密代理以及独享代理使用时需要验证用户名和密码！\n\n3：爬虫最常用的是私密代理！！\n\n\n\n代码演示：\n\n没设置代理IP\n\n![image-20211013105737207](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105737207.png)\n\n\n\n设置了代理IP\n\n![image-20211013105743874](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105743874.png)\n\n\n\n\n\n\n\n## 搭建IP代理池【重点】\n\n\n\n注意：再利用xpath语法提取数据时，右键检查发现数据所在的标签在 tbody下面这时就要小心了，因为很有可能网页源代码内没有这个tbody标签！！\n\n\n\n目标：掌握搭建代理IP池的步骤（免费代理ip网站）\n\n\n\n\n\n### 搭建代理IP池的步骤\n\n\n\n第一步：从免费代理IP网站提取出代理IP以及端口号（xpath提取目标ip以及端口号）\n\n\n\n第二步：通过代理ip向测试网站发送请求（设置timeout）如果超过timeout设置的时间则认为当前代理IP不可用！\n\n\n\n第三步：将可用的代理IP以及端口号保存到列表内或者txt文件内！\n\n\n\n代码截图\n\n![image-20211013105800933](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105800933.png)\n\n![image-20211013105809267](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105809267.png)\n\n![image-20211013105819657](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105819657.png)\n\n\n\n\n\n\n## requests的post请求【重中之重】\n\n\n\n目标：\n1：掌握控制台抓包的具体步骤以及参数功能\n\n2：掌握什么是post请求\n\n3：掌握利用requests模块向目标url发送post请求的语法\n\n4：掌握利用pycharm正则批量处理字符串的步骤\n\n​\t\n\n\n\n### 控制台抓包的具体步骤以及参数功能\n\n\n\n第一步：打开网站按下F12打开控制台\n\n\n\n第二步：刷新网站，对网站进行一些操作后进行二次刷新（动态显示的网站无需二次刷新，数据包已经加载，比如有道翻译网站）\n\n\n\n第三步：根据一些规则（响应数据）找到自己需要的数据包\n\n\n\n第四步：分析请求的目标URL以及请求方式\n\n\n\n注意事项：\n\n1：如果待抓取的数据在网页源代码内没有，基本都是异步（动态）加载的，我们可以考虑抓取XHR的包\n\n2：多多利用好数据包信息栏里面的Preview选项（对服务器响应数据的预览），可以根据这个快速找到我们待抓取的包\n\n![image-20211013105858633](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105858633.png)\n\n\n\n\n\n### 什么是post请求\n\n\n\n答：post请求就是客户端带着Form data 表单数据（字典）向服务器发送的请求\n\n\n\n\n\n\n\n### 利用requests模块向目标url发送post请求的语法\n\n\n\n\n\n语法：requests.post（url=…….，headers={}，data={}）.text\n\n重要参数：data          data 参数就是客户端需要带着的Form data 表单数据\n\n参数类型：字典\n\n\n\n![image-20211013105908065](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105908065.png)\n\n\n\n\n\n\n\n### 利用pycharm正则批量处理字符串的步骤（一般是将字符串变为字典形式）\n\n\n\n第一步：在pycharm内新建txt文件\n\n\n\n第二步：将待批量处理的字符串复制进来\n\n\n\n第三步：按下快捷键 Ctrl + r\n\n\n\n第四步：利用 pycharm 自己的正则对字符串进行批量处理\n\n\n\n截图：\n\n\n\n![image-20211013105922519](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105922519.png)\n\n\n\n\n\n\n\n\n## 关于js加密【重中之重】\n\n\n\n目标：\n1：掌握 分析 js 加密的过程（打断点、控制台等）\n2：掌握抓取有道翻译的注意事项\n\t\n\n\n\n### 分析 js 加密的过程（打断点、控制台等）\n\n\n\n分析背景：\n\n\n\n答：在发送post请求时，要带着Form_data表单数据向目标服务器发送请求，因为网站反爬的原因，有的Form_data表单数据是经过js加密的，因此就要分析js加密的原理从而进行破解利用python实现\n\n\n\n\n\n分析js加密过程示例：\n\n\n\n第一步：查看post请求中哪几个表单数据是经过 js 加密的\n\n![image-20211013110011885](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110011885.png)\n\n\n\n\n\n\n\n第二步：在全部包中搜索表单数据的变量名（salt、sign、lts）\n\n![image-20211013110021162](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110021162.png)\n\n\n\n\n\n第三步：将一行代码进行格式化（多行代码）\n\n![image-20211013110030164](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110030164.png)\n\n\n\n\n\n\n\n第四步：在包含表单数据变量名的代码中搜索表单变量名，分析js加密原理\n\n![image-20211013110038526](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110038526.png)\n\n\n\n\n\n\n\n第五步：分析经过js加密后的表单数据变量（打断点、控制台）\n\n![image-20211013110047499](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110047499.png)\n\n\n\n控制台输出代码\n\n![image-20211013110054831](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110054831.png)\n\n\n\n对程序打断点\n\n![image-20211013110103415](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110103415.png)\n\n\n\n\n\n分析完成利用python实现这个几个字段的加密然后向目标url发送post请求即可\n\n\n\n\n\n### 二：抓取有道翻译的注意事项\n\n\n\n因为有道翻译反爬严重，请求标头要道带上所有的请求标头去发送请求\n\n![image-20211013110114786](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110114786.png)\n\n\n\n\n\n\n\n\n## 爬取民政部行政区号遇到的反爬【目标】\n\n\n\n重点：掌握在爬取民政部行政区号遇到的反爬怎么解决\n\n\n\n\n\n\n### 爬取民政部行政区号遇到了怎样的反爬\n\n![image-20211013110131351](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110131351.png)\n\n![image-20211013110139384](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110139384.png)\n\n\n\n\n\n\n\n\n\n\n\n检查发现还他娘真有这段js跳转脚本代码\n\n\n\n![image-20211013110149295](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110149295.png)\n\n\n\n\n\n\n\n\n\n未完待续.......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["爬虫基础篇"],"categories":["爬虫基础篇"]},{"title":"数据存储——Mysql与redis存储","url":"/2021/10/13/数据存储——Mysql与redis存储/","content":"\n\n\n\n\n本文主讲：如何将爬取下来的数据存储到Mysql数据库内及其redis数据库内.....\n\n\n\n\n\n<!--more-->\n\n\n\n## MySQL实现增量式爬虫（md5加密）【重点】\n\n\n\n### python 怎么对 url 字符串进行 MD5 加密\n\n\n\n什么是MD5加密：就是将一串字符重新加密为定长32的唯一字符串（常常用作 url 加密）\n\n为什么要对 url 进行MD5加密：因为有的 url 长度太长在实现增量式爬虫时的mysql  url指纹库不好控制，所以进行MD5加密\n\n实现语法：\n\n```python\n\t\tfrom hashlib import md5               →  导入md5模块（标准库模块）\n\t\ts = md5（）                                →  创建一个md5对象\n\t\ts.update( url.edcode（）)                 → 对 url 进行md5加密\n\t\t加密结果 = s.hexdigest（）       → 获取加密后的十六进制url字符串\n```\n\n\n\n注意事项：一段字符经过md5加密之后结果是16进制字符串，那么相同的这段字符在经过md5加密，形成的16进制字符串是不变的\n\n\n\n代码体验：\n\n![image-20211013095105307](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095105307.png)\n\n\n\n\n\n### MySQL 增量式爬虫的实现逻辑\n\n\n\n增量式爬虫的背景：假设爬取新闻网站资源，今天把所有的新闻全部爬取下来了，第二天网站又更新了几条新闻，这时我们只需要爬取更新的新闻即可，这就是做增量式爬虫的目的\n\n\n\n增量式实现逻辑：创建一个 mysql 网站指纹数据表，将爬取过的 url（看情况确定是一级url 还是二级url） 经过 md5 加密之后保存进数据表，以后在爬取数据时先将待爬取的 url 与指纹数据表里面的加密url进行比对，如果url已经存在指纹数据表内，那么就停止爬取，没有则继续爬取\n\n\n\n\n\n### MySQL 增量式爬虫的具体实现思路\n\n\n\n第一步：创建 mysql 指纹数据表\n\n语法：\n\n```python\n\tcreate database 数据库名 charset=utf8；\n\tcreate table 数据表名（ 字段名 char（32） not null ）charset=utf8；\n```\n\n\n\n第二步：在向指定 url 服务器发送请求之前，先将url与mysql数据指纹库里面的url进行比对，没有一样的在发送请求\n\n部分语法：\n```python\n\t\t游标对象.execute（select * from 指纹数据表名）\n\t\turl_tuple = 游标对象.fetchall（）\n\t\tif  url in url_tuple：\n\t\t\t退出程序\n\t\telse:\n\t\t\t继续爬取\n```\n\n\n\n注意事项：url_tuple = 游标对象.fetchall（）  语法获取的数据是元组嵌套，但是没关系，不管是元组还是元组的嵌套 in 关键字都可以判断指定数据是否在里面！！\n\n\n\n第三步：如果判断 url 不在 url数据指纹库内，则爬取数据完成后，将这个url经过md5加密后写入到数据指纹库里面！！\n\n\n\n\n\n\n\n\n## MySQL增量式爬虫框架【重点】\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/python%E4%BA%8C%E7%BA%A7%E7%88%AC%E8%99%AB%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%A1%86%E6%9E%B6%E3%80%90%E7%BE%94%E7%BE%8A%E6%80%BB%E7%BB%93%E3%80%91.png)\n\n\n\n\n\n## redis数据库基本操作【重点】\n\n\n\n### 什么是 redis 数据库\n\n\n\n类型：非关系型数据库\n\n数据存储类型：字符串（键值对）、列表，集合（去重），zset（有序集合），哈希（2的32次方减1个键值对）\n\n数据存储位置：内存\n\n优点：读取大量数据速度快\n\n\n\n注意事项：redis的字符串其最基本的数据类型也是二进制类型的，你可以理解为redis内的字符串数据可以是任何类型的数据，比如说图片、音频等，其中redis的字符串类型最大可存储512mb的数据\n\n\n\n\n\n### 怎么安装 redis 数据库\n\n\n\nubuntu安装指令：`sudo apt-get install redis-server`\n\nubuntu终端启动redis指令：`redis-server`\n\n终端查看是否启动redis指令（常用）：`redis-cli`      如果启动成功出现这串字符：redis 127.0.0.1:6379>\n\n进入redis数据库指令：在 redis 127.0.0.1:6379> 基础上输入 `ping` 即可\n\n\n\n截图：\n\n![image-20211013095217759](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095217759.png)\n\n\n\n\n\n### redis 数据库的五大数据类型\n\n\n\n1.字符串（键值对）：redis 最基础的数据类型，其中字符串是二进制的，可以理解为redis的字符串可以存储任何数据，图片、音频等，但是redis的字符串（值）最大可存储512mb大小的数据\n\n\n\n插入数据：`SET 键名  值`\n\n获取数据：`GET 键名`\n\n![image-20211013095228423](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095228423.png)\n\n\n\n\n\n2.hash（哈希）：哈希数据类型可以理解为键值对的集合，一个哈希最多可以存储232 -1 键值对（40多亿）\n\n\n\n省略……..\n\n\n\n\n\n3.列表：列表是redis最简单的数据类型，数据元素按照插入顺序排序（先插在后）\n\n\n\n插入数据：`lpush 键名  值`\n\n获取数据：`lrange 键名 数据在列表开始下标 数据在列表结束下标`\n\n图示：\n\n![image-20211013095241914](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095241914.png)\n\n\n\n\n\n4.集合：redis的集合是字符串无序集合，元素不能重复，通过哈希表实现，因此添加、查找、删除的复杂度都是O（1）\n\n\n\n插入数据：`sadd 键名 数据`\n\n查询数据：`smembers 键名`\n\n\n\n注意：添加一个数据到集合键里面，如果这个数据在集合存在则不能插入返回0，不在插入成功返回1\n\n\n\n图示：\n\n![image-20211013095257113](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095257113.png)\n\n\n\n\n\nzset（无序集合）：Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复\n\n\n\n插入数据到集合内：`zadd key score member`\n\n\n\n省略……\n\n\n\n\n\n\n\n## redis数据库的常用指令【重点】\n\n\n\n### 怎么在redis数据库删除指定键\n\n\n\n语法：`del 键名`\n\n截图：\n\n![image-20211013095317287](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095317287.png)\n\n\n\n全部键指令截图：\n\n\n\n![image-20211013095329179](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095329179.png)\n\n![image-20211013095343346](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095343346.png)\n\n\n\n\n\n###  redis 数据库一些关于字符串的操作\n\n\n\n![image-20211013095357083](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095357083.png)\n\n![image-20211013095405396](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095405396.png)\n\n\n\n\n\n\n\n## redis数据库与python交互【重点】\n\n\n\n### 怎么安装 redis 数据库与 python 交互的第三方库\n\n\n\n安装指令：`pip3 install redis`\n\n\n\n### redis 数据库与 python 交互的步骤\n\n\n\n第一步：导入 redis 第三方数据库             →       ` import redis` \n\n\n\n第二步：创建 redis 连接数据库对象        →        `  red_obj = redis.Redis(host=主机，port=端口号，db=数据库号)`\n注意：redis默认有16个数据库，也就是数据库号可以是  0-15，一般选择0   redis的端口号是6379（整形）\n\n\n\n第三步：利用创建的 redis 数据库对象对数据库进行操作      → ` result = red_obj.sadd(\"name：age\" , \"21\") `  向外键名为name的集合内插入键为age值为“21”的一条数据\n\n\n\n注意：redis内的集合数据类型具有数据唯一性以及无序性的特征，如果上述插入的数据在集合内存在返回0，不存在返回数据1\n\n\n\n截图：\n\n\n\n![image-20211013095424043](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095424043.png)\n\n\n\n\n\n## redis实现增量爬虫【重点】\n\n\n\n### 怎么利用 redis 实现增量式爬虫\n\n\n\n实现重要方法：\n\n\n\n第一步：在进行爬取指定url数据时，先将指定 url 写入到 redis 数据库集合内，获取返回值！\n写入redis集合方法：连接数据库对象.sadd（键名，键名所对应的值）\n\n\n\n第二步：如果返回值是1，就说明这个url还未加入到url指纹数据库内（未爬取），可进一步爬取当前url数据，如果返回值为 0 说明当前经过md5加密后的url已经加入到url指纹数据库内，无需爬取，退出程序（只适用于电商新闻类网站！）\n\n\n\n\n实现原理：因为 redis 数据库的集合具有无序性以及数据唯一性！，当数据在redis集合内存在时，插入数据失败返回值为o\n\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"数据存储——CSV文件与mongoDB","url":"/2021/10/13/数据存储——CSV文件与mongoDB/","content":"\n\n\n\n\n本文主讲：将爬取下来的数据持久化存储到CSV文件内或存到mongoDB数据库内、Mysql数据库内，简单的二级爬虫框架等\n\n\n\n<!--more-->\n\n\n\n\n\n## 爬取数据持久化存储（csv）【重点】\n\n\n\n### python 标准库模块 csv 的使用方法及功能\n\n\n\n功能：将数据写入到 csv 文件的模块\n语法：\n\n```python\n\timport csv\n\twith open （“文件名.csv”，“打开方式”） as  文件别名：\n\t\t\t写作对象 = csv.writer（文件别名）\n\t\t\t写作对象.writerow（列表）    →→→→→→→→→→ 单行数据写入 csv 文件\n\t\t\t写作对象.writerows（列表内嵌套元组）   →→→→→→→→→→ 多行数据写入 csv 文件，其中一个元组代表一行数据！\n```\n\n\n\n两种写入方法：\n\n写作对象.writerow（列表）：这是将数据单行写入到 csv 文件内，一个列表元素是一个字段\n\n写作对象.writerows（列表内嵌套元组）：这是将数据多行写入到 csv 文件内，一个列表内元组是一行记录\n\n\n图示：\n\n单行数据写入\n\n![image-20211013093811033](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093811033.png)\n\n\n\n\n\n多行数据写入\n\n![image-20211013093818574](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093818574.png)\n\n\n\n\n\n### 将数据保存至 csv 文件的一些问题处理方法\n\n\n\n出现什么问题？ \n\n答：多行数据保存时，每行数据下面会多出一行空行（windows专属，linux没有这种问题），这该怎么解决呢\n\n\n\n怎么解决？\n\n答：打开文件时加上参数 newline = “” 即可解决！！！\n\n\n\n代码演示：\n\n![image-20211013093837101](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093837101.png)\n\n\n\n\n\n\n\n\n\n## 数据持久化存储（mysql）【重点】\n\n\n\n### python 与 mysql 数据库交互的步骤\n\n\n\n第一步：导入 pymysql 模块\n\n\n\n第二步：创建铁路对象 way_obj = pymysql.connect(host = 主机，user = 用户名，password = 数据库密码，database = 交互数据库名)\n\n\n\n第三步：在铁路对象上创建游标对象 cursor_obj = way_obj.cursor（）\n\n\n\n第四步：将数据插入到数据库内（两种方法）\n\n\n\n1（单行数据插入）： cursor_obj.execute（SQL语句，数据列表）\n\n2（多行数据插入）：cursor_obj.executemany(SQL语句，列表内嵌套元组数据)\n\n\n\n\n\n\n第五步：将更改提交到数据库 way_obj.commit( )   注意是铁道对象提交，针对mysql数据库的事务特性！\n\n\n\n第六步：关闭游标对象 cursor_obj.close（）\n\n\n\n第七步：关闭铁道对象 way_obj.close( )\n\n\n\n截图演示：\n\n![image-20211013093857877](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093857877.png)\n\n\n\n\n\n### 将数据存储到数据库的两种方法（单记录插入、多记录插入）\n\n\n\n单行数据插入方法—— execute（）\n\n\n\n功能：将单行数据（列表）插入到数据库内！\n\n语法：游标对象.execute（参数1，参数2）\n\n\n\n参数1：SQL语句\n参数2：列表数据，所有列表数据就是一行记录\n\n\n\n\n\n代码演示：\n\n![image-20211013093910839](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093910839.png)\n\n\n\n\n\n\n\n多行数据插入方法—— executemany（）\n\n\n\n功能：将多行数据（列表内嵌套元组）插入到数据库内\n\n语法：游标对象.executemany（参数1，参数2）\n\n参数1：SQL语句\n参数2：列表内嵌套元组，一个元组内所有数据就是数据库内的一行数据！\n\n\n\n\n\n注意事项：列表内嵌套元组，其中一个元组内的数据就是一行记录\n\n\n\n代码演示：\n\n![image-20211013093938395](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093938395.png)\n\n\n\n注意事项：多行数据插入方法（executemany）比单行数据插入方法（execute）效率要快的多，因为计算机 i/o次数减少很多！！！\n\n\n\n\n\n\n\n## mongoDB数据库基本操作【重点】\n\n\n\n###  mysql、mongoDB、redis数据库的端口号\n\n\n\nmysql：3306\n\nmongoDB：27017\n\nredis：6379\n\n\n\n\n\n### mongoDB 数据库的详解\n\n\n\n特征：mongoDB数据库是非关系型数据库（开源、免费），以键值对的形式存储数据，存放数据的数据类型为 json 文档，且mongoDB是基于磁盘存储数据（redis基于内存存储数据）\n\n\n\nmongoDB数据库与mysql数据库的对比分析：\n\n\n\nmysql数据库：\n\n定义：关系型数据库\n\n结构：数据库→数据表→数据表记录\n\n基于存储：不同引擎不同存储方式\n\n存储数据时是否需要提前建表：是\n\n存储模式：静态模式\n\n查询语言：SQL语言\n\n\n\n​\t\t\t\n\nmongoDB数据库：\n\n\n\n定义：非关系型数据库\n\n结构：数据库→数据集合→json文档（字典）\n\n基于存储：基于磁盘存储（虚拟内存+持久化）\n\n存储数据时是否需要提前建集合：否\n\n存储模式：动态模式（不需要提前建数据集合以及字段什么的）\n\n查询语言：独特的mongoDB语言\n\n优势：分布式集群\n\n缺点：不支持事务！\n\n​\t\t\t\t\n\n\n\n注意事项：\n\n1：mongoDB 数据库内的数据集合里面可以存放好多条 json文档（字典）\n\n2：每一个 json 文档就是一个字典！\n\n\n\n\n\n###  mongoDB数据库的基本操作（安装、查看数据库、删除数据库等等）\n\n\n\n\n\n1.mongoDB数据库安装步骤（linux-ubuntu系统）：\n\n安装指令：sudo apt-get install mongdb\n\n\n截图：\n\n![image-20211013094020403](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094020403.png)\n\n\n\n\n\n\n\n2.查看mongoDB数据库内的所有数据表\n\n指令：show dbs\n\n截图：\n\n![image-20211013094043171](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094043171.png)\n\n\n\n\n\n3 . 进入（切换）数据库\n指令：use 数据库名\n截图：\n\n![image-20211013094055168](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094055168.png)\n\n\n\n\n\n\n\n4 . 查看当前所在的数据库内所有集合\n指令：show collections\n截图：\n\n![image-20211013094105537](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094105537.png)\n\n\n\n\n5. 查看当前数据库内的数据集合里面有哪些文档\n\n  语法：\n  正常查询输出：db.集合名.find（）\n  格式化查询输出：db.集合名.find（）.pretty（）\n\n  截图：\n\n![image-20211013094118675](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094118675.png)\n\n\n\n\n\n6. 查看当前数据库内的数据集合里面的文档数量\n  语法：db.数据集合名.count（）\n  截图：\n\n  ![image-20211013094127336](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094127336.png)\n\n\n\n\n\n\n\n7.删除数据库内的指定集合\n语法：db.指定数据集合名.drop（）\n截图：\n\n![image-20211013094138284](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094138284.png)\n\n\n\n\n\n8.删除指定数据表\n语法：db.dropDatabase( )\n截图：\n\n![image-20211013094144723](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094144723.png)\n\n\n\n\n\n\n\n9.查看当前所在数据库名\n语法：db.getName（）\n截图：\n\n![image-20211013094153128](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094153128.png)\n\n\n\n\n\n### python 怎么与mongoDB数据库进行交互？\n\n\n\n交互步骤：\n\n\n\n第一步：导入模块 import pymongo \n\n\n\n注意：pymongo不是标准库需要安装\n\nlinux终端安装指令：sudu pip3 install pymongo\n\n\n\n\n\n第二步：创建mongo数据库连接客户对象     con_obj = pymongo.MongoClient(host = 当前主机，port = 端口号)\n\n\n\n注意：\n\n1：主机一般都是 127.0.0.1\n\n2：mongoDB数据库的端口号是 27017\n\n3：参数MongoClient方法的port参数数据类型是数字，不是字符串\n\n\n\n\n\n第三步：创建数据库对象     db_obj = 连接对象[\"数据库名\"]\n\n\n\n注意：数据库名可以是在mongoDB数据库内存在的，也可以是不存在的，存在则直接进行操作，不存在则先创建这个数据库在操作\n\n\n\n\n\n第四步：创建数据集合对象  set_obj = 数据库对象[\"数据集合名\"]\n\n\n\n第五步：向数据集合内插入文档\n\n\n\n插入单条文档数据方法：数据库集合对象.insert_one(字典)\n\n插入多条文档数据方法：数据库集合对象.insert_many(列表内嵌套字典)\n\n\n\n注意事项：插入单条文档数据时一个字典就是一条文档数据，插入多条文档数据也是如此（一个字典是一个文档数据）\n\n\n\n总体注意：在利用 python 与 mongoDB 数据库进行交互时，不需要提前建好数据库以及数据集合，这是与mysql数据库交互的不同之处！\n\n\n\n\n\n代码演示：\n\n![image-20211013094223862](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094223862.png)\n\n\n\n\n\n\n\n## 数据持久化存储（mongodb）【重点】\n\n\n\n### 将数据持久化存储到mongoDB数据库的两种方法\n\n\n\n1.单条数据文档插入存储方法——数据集合对象.insert_one({})\n\n\n\n功能：将单条文档数据（字典）插入到建好的mongoDB数据库的数据集合内\n\n语法：数据集合对象.insert_one({})\n\n注意：insert_one（{}）方法里面的参数是字典，一个字典就代表一个文档数据\n\n\n\n截图：\n\n![image-20211013094245938](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094245938.png)\n\n\n\n\n\n2.多条数据文档插入存储方法——数据集合对象.insert_many( [ {}，{}，{}，{} ] )\n\n\n\n功能：将多条文档数据（列表内嵌套字典）插入到建好的mongoDB数据库的数据集合内\n\n语法：数据集合对象.insert_many( [ {}，{}，{}，{} ] )\n\n注意：insert_one（{}）方法里面的参数是列表内嵌套字典，一个字典就代表一个文档数据\n\n\n\n截图：\n\n![image-20211013094301571](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094301571.png)\n\n\n\n\n\n\n\n## random模块的uniform方法【重点】\n\n\n\n### random 模块的 uniform 方法的使用\n\n\n\n功能：随机生成指定区间的浮点数\n\n语法：random.uniform（1，6）    随机生成1到6的浮点数\n\n截图：\n\n![image-20211013094313020](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094313020.png)\n\n\n\n\n\n\n\n\n## 简单的二级爬虫框架【重点】\n\n\n\n注意：字太小先保存到计算机内在方法观看‘\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/python%E4%BA%8C%E7%BA%A7%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E3%80%90%E7%BE%94%E7%BE%8A%E6%80%BB%E7%BB%93%E3%80%91.png)\n\n\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"爬虫基础——urllib库与正则表达式","url":"/2021/10/13/爬虫基础——urllib库与正则表达式/","content":"\n\n\n\n\n本文主讲：了解什么是爬虫、urllib请求库的使用、正则表达式的使用等.....\n\n\n\n<!--more-->\n\n\n\n## 什么是爬虫及其分类！\n\n\n\n\n### 什么是网络爬虫？\n\n答：网络爬虫就是利用一段程序模拟人操作浏览器获取数据的过程，且模拟人操作浏览器越逼真越好！\n\n\n\n\n\n### 网络爬虫的分类\n\n\n\n通用爬虫：浏览器所用的爬虫，需要遵守 robots 君子协议\n\t\n聚焦爬虫：针对一些特定网页获取数据\n\n功能爬虫：利用爬虫实现一些功能，如自动投票、自动抢票等\n\n数据爬虫：利用爬虫获取一些指定网页的数据！\n\n\n\n注意事项：在网站的根目录下输入 /robots.txt 可查看网站的 robots 协议\n\n![image-20211013092323280](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092323280.png)\n\n\n\n\n\n\n## 爬虫爬取数据的步骤！\n\n\n\n### 爬虫获取数据的步骤！\n\n\n\n第一：找到需要爬取数据的 url 地址\n\n\n\n第二：（包装请求头）向这个 url 地址发起请求\n\n\n\n第三：获取这个 url 服务器发来的响应数据（网页源代码）\n\n\n\n第四：利用 python 数据解析库在源码中获得想要的数据！\n\n\n\n第五：将数据进行清洗保存（csv、数据库、Excel）！\n\n\n\n第六：是否需要在原网页内进行链接跳转再抓取数据！\n\n\n\n\n\n\n\n\n## urllib.request库的方法及功能【重点】\n\n\n\n### urllib.request 库内的 urlopen（）方法功能\n\n\n\n功能：向目标 url 发送一个请求，并返回一个相应对象\n\n方法参数：\n\nurl：发送请求的目标网站（网站一定要写全 例如 http://www.baidu.com/ ，http不能忘以及最后的/）\n\ntimeout：设置请求时间，超过设置的请求时间将抛出异常\n\n\n\n语法：`res_obj = urllib.request.urlopen（url）`\n\n\n\n注意：res_obj 只是网站响应的对象，不是网站相应的数据！！！\n\n\n\n\n\n### urllib.request.urlopen（）方法返回的响应对象的方法\n\n\n\n响应对象.read（）：获取网站响应的源代码（bytes数据格式）【字节串数据格式】\n\n响应对象.read.decode（编码格式）：获取网站响应的源代码（string数据格式）【字符串数据格式】\n\n响应对象.geturl（）：获取实际返回响应数据的网站url（考虑到重定向问题）\n\n响应对象.getcode（）：获取网站的http响应状态码\n\n\n\n注意：\tbytes数据与string数据不一样，bytes是以字节为单位，string是以字符为单位， string通过encode（）编码可转换为bytes，bytes可通过decode（）解码转换为string，bytes数据格式为 b“数据”，string数据格式为 “数据”\n\n\n\n图示：\n\n响应对象的.read（）方法\n\n![image-20211013092402556](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092402556.png)\n\n\n\n\n\n响应对象的.read（）.decode（）方法\n\n![image-20211013092409918](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092409918.png)\n\n\n\n响应对象的.geturl（）与响应对象的.getcode（）方法\n\n![image-20211013092417285](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092417285.png)\n\n\n\n\n\n### 怎么查看程序向网站发送请求时标头的 User-Agent\n\n\n\n直接向下面 url 地址发送请求即可查看请求协议标头的 User-Agent\n\n\n\n网站：http://httpbin.org/get\n\n\n\n图示：\n\n浏览器发送请求查看 User-Agent\n\n![image-20211013092437732](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092437732.png)\n\n\n\npython的urllib库发送请求查看 User-Agent\n\n![image-20211013092445366](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092445366.png)\n\n\n\n\n\n\n\n###  urllib.request库内的 Request（）方法功能\n\n\n\n功能：包装请求标头信息（一般是 User-Agent），并且返回这个包装好的请求头对象，用于向 url 发送请求\n\n语法：`req = urllib.request.Request（url = 网站域名，headers = {“User-Agent”：“伪装的标头信息”}）`\n\n\n\n参数：\n\nurl：待请求的链接地址\n\nheaders：伪装的请求标头信息\n\n\n\n\n\n注意事项：Request方法并没有向网站发送请求，而是伪装请求标头，urlopen方法才向目标网站发送请求并且接收响应数据\n\n\n\n\n\n截图\n\n![image-20211013092505732](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092505732.png)\n\n\n\n\n\n\n\n## urllib.parse模块的方法功能解析【重点】\n\n\n\n目标：\n\n1：掌握搜索关键字 url 地址的组成部分\n\n2：掌握向目标查询关键字地址发送请求的注意事项\n\n3：urllib.parse.urlencode（）方法详解\n\n4：urllib.parse.quote（）方法详解\n\n5：掌握 urllib.parse库内的 urlencode 方法以及 quote 方法的区别~\n\n\n\n\n\n\n\n\n\n### 搜索关键字 url 地址的组成部分\n\n\n\n组成：协议项+域名+数据库资源路径+查询参数\n\n图示：\n\n![image-20211013092521994](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092521994.png)\n\n\n\n\n\n注意：其实很多查询参数都没有用，上面的 url 可简化为 https://www.baidu.com/s?wd=美女\n\n\n\n\n\n### 向查询关键字地址服务器发送请求的注意事项\n\n\n\n什么是查询关键字地址？：就是搜索相应关键字所对应的url地址，例如在百度上查询美女的url地址如下\n\n\n\n https://www.baidu.com/s?wd=美女\n\n\n\n向查询关键字地址服务器发送请求的注意事项：需要将url地址内中文 编码后 才可以向服务器发送请求\n\n\n\n示例：\n\n\n编码前URL地址：https://www.baidu.com/s?wd=美女\n\n\n编码后URL地址：https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3\n\n\n注意：编码后三个%对应一个中文字符，例如%E7%BE%8E就对应 美 这个中文字符\n\n\n\n\n\n\n\n\n\n\n\n### urllib.parse.urlencode（）方法详解\n\n\n\n功能：将查询参数内的中文进行编码，并返回编码后的查询参数（返回多个编码后的查询参数时默认返回 &）\n\n语法：返回编码后查询参数 = urllib.parse.urlencode（{查询参数1：待编码值1，查询参数2：待编码值2……….}）\n\n\n\n\n\n语法参数：\n\n字典：字典内存放需要编码的查询参数，例如查询参数为   wd=美女   就这么写 {“wd”：“美女”}\n\n\n\n语法参数返回值：\n\n`params = urllib.parse.urlencode（{“wd”：“美女”}）`   params 就是 wd=%E7%BE%8E%E5%A5%B3\n\t\t\t\n注意事项：urllib.parse.urlencode（）方法只返回编码后的查询参数，并不是整个url地址，需要进行字符串拼接才能向目标url服务器发送请求\n\n\n\n图示：\n\n![image-20211013092600107](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092600107.png)\n\n\n\n\n\n\n\n### urllib.parse.quote（）方法详解\n\n\n\n功能：对查询参数内的中文进行编码，并且返回这个中文编码后的字符串\n\n语法：编码后的中文字符串 = urllib.parse.quote（”查询参数中的中文关键字“）\n\n例如：params = urllib.parse.quote（”美女“）  params 就是  %E7%BE%8E%E5%A5%B3  \n\n\n\n方法参数：\n\n查询参数内的中文：只是中文，没有相对应的 wd 等\n\t\n\n注意事项：这个方法只返回编码后的中文字符，连键都不返回需要自己写\n\n\n\n\n\n图示：\n\n![image-20211013092614582](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092614582.png)\n\n\n\n\n\n\n\n### urllib.parse库内的 urlencode 方法以及 quote 方法的区别~\n\n\n\n区别：\n\n1：参数不同，urlencode参数为字典，quote参数是中文字符串\n\n\n\n2：返回值不同，urldecode返回的是键与值，例如 wd=%E7%BE%8E%E5%A5%B3 ，quote方法返回的只有值，例如 %E7%BE%8E%E5%A5%B3 \n\n\n\n\n\n\n\n## 简单爬虫的构架【重点】\n\n\n\n### 简单爬虫的老版本构架（面向对象编程）\n\n\n\n可保存至电脑放大来看！\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/python.png)\n\n\n\n\n\n\n\n\n\n### 简单爬虫的新版本构架（面向对象编程）\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-04-28_20-31-44.png)\n\n\n\n\n\n\n\n## 正则模块（re）的使用【重点】\n\n\n\n### 正则模块 re 抓取数据的两种方法形式\n\n\n\n第一种形式(直接使用findall（查找数据）方法)：\n\ndata_list = re.findall（正则表达式，待匹配字符串，re.S）\n\n\n第二种形式（先创建正则编译对象在调用findall等方法）：\n\npattern = re.compile（正则表达式，re.S）\ndata_list = pattern.findall(待匹配字符串)\n\n\n\n\n\n注意事项：一般大佬都用第二种形式，因为正则写好一个可以多次调用\n\n\n\n图示：\n\n![image-20211013092723573](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092723573.png)\n\n\n\n\n\n### 正则模块 re 方法的 re.S参数的作用\n\n\n\n作用：正则表达式中的元字符 . 可以匹配任意字符（除了换行符/n），在findall等方法内部加上参数 re.S后 元字符 . 就可以匹配换行符/n啦\n\n\n\n注意：在抓取 html 代码时一定不要忘记写 re.S参数，因为 html 代码有很多换行符\n\n\n\n图示：\n\n![image-20211013092734436](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092734436.png)\n\n\n\n\n\n\n\n### 正则表达式贪婪模式以及非贪婪模式的注意事项\n\n\n\n元字符 ？功能： ？ 前一个字符出现1次或者0次\n\n\n\n贪婪模式：在满足匹配规则的前提下尽可能多的匹配数据\n\n\n\n非贪婪模式：在满足匹配规则的前提下尽可能少的匹配数据\n\n\n\n注意事项：\n\n1：贪婪模式与非贪婪模式说的都是在匹配多个字符时才适用，即元字符 * + ？\n\n2：python程序默认是贪婪模式匹配数据\n\n3：在匹配多个数据的元字符（* + ？）后面加上 ？ 就可将贪婪模式转变为非贪婪模式，注意一定是在匹配多个元字符后面加才管用！！！\n\n\n\n\n\n### 正则表达式单个分组以及多个分组的用法\n\n\n\n用法【单个分组】：如果在正则表达式的一部分加上单个分组，也就是一个（） 那么在调用 findall方法时，只将符合分组内的数据提取到列表内！\n\n\n\n用法【多个分组】：如果在正则表达式的一部分加上多个分组，也就是多个（） 那么在调用 findall方法时，将符合多个分组内的数据先保存到一个元组内，然后在匹配其他符合分组的数据，再次存放到另一个元组内，然后在将多个元组存放至列表中【列表内嵌套元组】\n\n\n\n图示【单个分组】  【多个分组】：\n\n![image-20211013092752765](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092752765.png)\n\n\n\n\n\n\n## 正则表达式匹配html数据的技巧【重点】\n\n\n\n目标：掌握正则表达式匹配 html 代码的技巧\n\n\n\n### 正则表达式匹配 html 代码的技巧\n\n\n\n实例html代码如下（提取电影名、主演、上映时间）：\n\n\n\n![image-20211013092804554](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092804554.png)\n\n\n\n\n\n正则表达式可以这么写！！\n\n\n\n对应的正则表达式：\n```\n<div class=\"movie-item-info\">.*?<a href=\"/films/[0-9]+\" title=\"(.*?)\".*?<p class=\"star\">\\s+主演：(.*?)\\s+</p>\\s+<p class=\"releasetime\">上映时间：(.*?)</p>\n```\n\n\n\n\n\n书写正则的技巧：\n\n1：第一个包含类的标签一定要写出来（例如 `<div class=\"movie-item-info\">`）这样正则可一下就找出来匹配的数据在那个标签类\n\n2：待匹配的数据要加上分组，一般都是这么写 `（.*？）`，这样可被findall方法直接匹配出来\n\n3：待匹配数据的前一个标签一般要按照给出的写出来（也可以不写！）\n\n4：`.*？`正则表达式是一个很好的东西哦，一定要学会使用！！！\n\n5：因为加上了 re.S 参数，所以 . 可以匹配任何数据\n\n\n\n图示：\n\n![image-20211013092844399](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092844399.png)\n\n\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["爬虫基础篇"],"categories":["爬虫基础篇"]},{"title":"爬虫的疑难杂症【第一期】","url":"/2021/10/13/爬虫的疑难杂症【第一期】/","content":"\n\n\n\n\n\n\n本文主讲：在爬虫过程中遇到的编码解码问题、发送请求错误、写正则的技巧、字符串列表字典之间的互转、浏览器抓包犯病等等问题~\n\n\n\n<!--more-->\n\n\n\n## 获取响应数据出现编码的问题\n\n\n\n报错提示：\n\nUnicodeDecodeError: 'gb18030' codec can't decode byte 0xa1 in position 32952: illegal multibyte sequence\n\n\n\n报错翻译：'gb18030'编解码器无法解码位置32952中的字节0xa1：非法的多字节序列 \n\n\n\n报错原因：有的字节使用 gb18030 字符集解码时是无效的\n\n\n\n解决办法：在解码方法 decode（）里面加上参数  ignore，即可忽略不能解码的字符！！\n\n\n\n办法截图：\n\n![image-20211013091115228](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091115228.png)\n\n\n\n\n注意事项：中国对字符进行解码有三种字符集，分别是 gbk、gb2312、gb18030，其中gb18030是最强的解码字符集，gb2312不能解的，gb18030可以解！\n\n\n\n\n\n\n\n## 向网站服务器发送请求时错误（捕获异常）【网络问题】\n\n\n\n报错提示：<urlopen error [Errno 11001] getaddrinfo failed>\n\n\n\n报错翻译：<urlopen错误[Errno 11001] getaddrinfo失败>\n\n\n\n报错原因：因为网络（网络不稳定）原因或者url地址的原因出现错误\n\n\n\n解决办法：死循环加上捕获异常即可解决此问题\n\n\n\n解决代码：\n\n```python\nwhile True：\n\ttry：\n\t\thtml_data = urllib.request.urlopne(url = url)\n\texcept Exception as result:\n\t\tprint( f \"出现错误：{result} 将继续执行此代码！\")\n\telse:\n\t\tbreak\n```\n\n\n\nelse功能：当try下面的代码不报错时执行else下面缩进的代码！\n\n\n\n解决代码截图：\n\n![image-20211013091147002](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091147002.png)\n\n\n\n\n## 写正则的技巧【重中之重】\n\n\n\n目标：掌握在 html 源代码中提取数据写正则的技巧\n\n\n\n一：在 html 源代码中提取数据写正则的技巧\n\n\n\n答：写正则提取数据之前，先不要查看网站源代码，先检查查看提取的数据在哪个标签内，把这个标签直接复制到文本文档内，在写正则即可！！！\n\n\n\n注意事项：\n\n1：在写正则的时候一定不要出现这种情况→→→→ ` .*? (.*?) `    也就是两个`.*？`连在一起的情况！！\n\n2：需要提取的数据  前一个标签与后一个标签一定不能省略！（一定要写）\n\n\n\n\n\n\n\n\n\n## 字符串、列表、字典之间的相互转化【重点】\n\n\n\n### 列表与字符串之间的相互转换\n\n\n\n列表转换为字符串方法：“”. join（列表）\n\n图示：\n\n![image-20211013091209950](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091209950.png)\n\n\n\n\n\n### 字典与字符串的相互转换\n\n\n\n转换所用到的标准库 json 库\n\n\n\n字典转为字符串方法：json.dumps（带转换字典）\n\n\n\n图示：\n\n![image-20211013091220349](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091220349.png)\n\n\n\n\n\n### 字符串转为字典的两种方法：\n\n\n\n1：dict = eval( s )   其中 s 为字典格式的字符串\n\n2：json.loads（s）  其中 s 为字典格式的字符串\n\n\n\n图示：\n\n一般方法\n\n![image-20211013091237813](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091237813.png)\n\n\n\nJson.loads方法转换\n\n![image-20211013091244244](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091244244.png)\n\n\n\n\n\n### 将字典转换为字符串之后写入到文件内中文出现乱码的问题！\n\n\n\n字典转字符串的方法：json.dumps（带转换字典）\n\n\n\n问题截图：\n\n![image-20211013091252739](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091252739.png)\n\n\n\n解决问题：\n\n\n\n将 json.dumps（）方法内的 ensure_ascii 参数值改为 False 即可（默认为True）\n\n\n\n图示：\n\n![image-20211013091301518](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091301518.png)\n\n\n\n\n\n\n## 浏览器抓包时犯病怎么解决\n\n\n浏览器清除缓存快捷键：Ctrl + Shift + Del 【如果浏览器犯病就试试这个快捷键】\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n","tags":["疑难杂症篇"],"categories":["疑难杂症篇"]},{"title":"精致BOY【第一期】","url":"/2021/10/12/精致BOY【第一期】/","content":"\n\n\n本文主讲：男孩子怎么护肤、怎么健身、怎么拍照、怎么选购香水、发型相关、怎么变帅、穿衣服的一些小技巧、怎么选购镜框、好物分享等...\n\n\n\n<!--more-->\n\n\n\n## 怎么护肤\n\n\n\n早上：洁面【用氨基酸补水温和清洁的洗面奶】（用洗面奶洁面时不要太用力洗以及不要用太热的水，温水或凉水）  →   用毛巾轻轻吸干水分（不要用力擦） → 涂水  →  在涂精华  → 在用乳\n\n\n\n\n晚上：洁面【用氨基酸补水深层清洁的洗面奶】 → 用毛巾轻轻吸干水分 → 用美白面膜【一周两次 可以选择泥状面膜】or 去角质【十天去一次角质】  →  涂水  →  在涂精华  → 在用乳\n\n\n\n\n\n## 怎么健身\n\n\n\n我的体脂率为：13.96%\n\n\n\n健身顺序为：热身 → 无氧运动【剧烈的运动 举重 哑铃】 → 有氧运动【缓慢的 慢跑 骑车】\n\n\n\n\n\n健身中的吃法：\n\n健身前半小时：粗粮面包 or 香蕉 or 补剂【增肌粉】    注意：增肌粉 = 蛋白粉 + 碳水化合物\n\t\t\t\n健身中：十五分钟补充一次水分【每次150-200ml】\n\t\t\n健身后半小时进食：粗粮面包 or 香蕉 or 补剂【增肌粉】    注意：增肌粉 = 蛋白粉 + 碳水化合物\n\t\t\t\n\n\n\n健身的注意事项：\n\n1：健身后不要立即冲凉水澡\n\n2：运动过后不要急刹车\n\n3：不要饱腹以及空腹运动\n\n4：增肌健身最好的时间段在下午4：00 —  6：00 【我选择】\n\n\n\n\n\n健身的时间掌控：热身约5分钟，力量训练约30~40分钟，有氧约10~20分钟，放松约5分钟，每次锻炼总时长约50~70分钟。\n\n\n\n\n\n\n## 怎么拍照\n\n\n\n略.......\n\n\n\n## 怎么选购香水\n\n\n\n香水分类：\n\n1：香精\n\n2：浓香水\n\n3：淡香水【男士常用】\n\n4：古龙水【男士常用】【有好感】\n\t\t\n\n\n\n香水品牌：香奈儿、迪奥、爱马仕等等\n\n\n\n\n\n男士选择香水香调的标准【我可以尝试 果香以及柑橘味道】：\n\n![image-20211012190655568](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012190655568.png)\n\n\n\n\n\n香水涂抹留香的位置：指尖、脖颈、肘窝、肚皮【或者内衣】、裤兜\n\n\n\n\n\n喷香水的注意事项：\n\n1：烟味很大的话不建议喷香水\n\n2：和女生约会考虑喷香水、成天和哥们一起就不要喷了\n\n3：形象和气味要一致\n\n4：先不要着急买大瓶，先尝试尝试小样！\n\n最重要：如果我喷了香水就不要与其他味道浓的产品一起使用【例如凝香珠、发胶】\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 发型相关\n\n\n\n让头发蓬松起来的产品：蓬松粉、海盐水等一般都用在发根，减少头皮油脂\n\n\n\nps：我是长脸，需要有长头帘并且头帘要有碎盖的效果，否则显的整个人比较沉重、压抑等，并且长脸两边不要剃短，最好两边留长，这样显得脸比较短一点.......\n\n\n\n\n\n\n## 想买的产品\n\n\n\n1：水乳【已经买了】\n\n2：烧烤架子\n\n3：墨镜\n\n4：鼠标\n\n5：早用温和洗面奶\n\n6：晚用强力洗面奶\n\n7：清洁面膜or美白面膜\n\n8：拉力带\n\n9：古龙果香味香水\n\n10：漱口水【约会前漱漱口】\n\n11：摇摇杯【内置搅拌球】\n\n12：全身镜\n\n13：投影仪\n\n14：创意摆件\n\n15：蒸汽眼罩\n\n\n\n\n\n\n## 怎么变帅\n\n\n\n1：发型头帘一定要碎一点\n\n\n\n2：长脸发型两边不要剪得特别短，尽量长一点，与头发有联系\n\n\n\n3：眼睛一定要有神不要呆滞\n\n练习方法：(找准某一个点一直盯着看【有神】，用手指画圈眼睛跟着看！逆时针、顺时针各15圈)\n\n\n\n4：皮肤黑不要穿浅色亮面的衣服（北面那个羽绒服）\n\n\n\n5：清洁面膜【泥状】使用步骤\n\n1：先用温水洗一下脸\n\n2：涂上爽肤水\n\n3：在涂清洁面膜【出油多的地方多抹一点】\n\n\n\n\n\n\n\n## 穿【买】衣服的一些小技巧\n\n\n\n1：买衣服问客服多大码衣服合身，多大码可以穿出宽松的感觉【就买那个码】\n\n\n\n2：腿变长小妙招：鞋裤一体，尽量不要露脚踝\n\n\n\n3：如果有一个体恤很花，那么裤子和鞋子要统一颜色\n\n\n\n4：衣服一定要比配饰要大【充实】，也就是如果配饰很花那么衣服要更花\n\n\n\n\n\n\n\n## 怎么选购镜框\n\n\n\n1：圆形脸选购方形镜框\n\n![image-20211012190750509](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012190750509.png)\n\n\n\n\n\n二：长脸选择圆形的镜框【镜片大的眼镜】\n\n\n\n三：方脸选择方形镜框【就和我现在的差不多】\n\n\n\n注意：眼镜的大小和太阳穴一齐就好\n\n\n\n根据肤色选择镜框颜色\n\n![image-20211012190804802](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211012190804802.png)\n\n\n\n![image-20211012190824951](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211012190824951.png)\n\n\n\n![image-20211012190835378](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012190835378.png)\n\n\n\n\n\n## 好物分享\n\n\n1：衣物喷雾【吃完火锅或者晾晒衣服时候可以喷一喷】\n\n\n\n\n2：RE的扩香水\n\n\n\n\n3：磨砂膏【去死皮、去角质】\n\n4：便捷式挂烫机\n\n5：拼接式项链\n\n\n\n\n\n\n\n\n\n未完待续......持续更新....\n\n\n\n\n","tags":["精致BOY"],"categories":["精致BOY"]},{"title":"黑马程序员学Python——导入模块与继承问题","url":"/2021/10/12/黑马程序员学Python——导入模块与继承问题/","content":"\n\n\n\n\n本文主讲：Python导入模块的几种方式及其注意事项、单继承与多继承、property装饰的使用、魔法属性与魔法方法、with上下文方式\n\n\n\n<!--more-->\n\n\n\n\n\n## 检测字符串文件的后缀【重点】\n\n\n\n### 怎么检测文件（字符串）的后缀！\n\n\n\n关键字：endswith\n\n\n\n语法：文件字符串.endswith（“后缀”）\n\n\n\n注意事项：\n\n1：后缀要加上.      例如 .py  .txt\n\n2：文件字符串.endswith（“后缀”）返回的是一个布尔值，是括号里面的后缀则返回True，不是括号里面的后缀返回False\n\n\n\n图示：\n\n![image-20211012184426752](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184426752.png)\n\n\n\n\n\n\n\n## import导入模块路径【重点】\n\n\n\n### 如何使用模块内的变量？\n\n\n\n语法：模块名.变量名\n\n实例：print（moudle.name） 即可打印 moudle 模块内name变量的值\n\n\n\n注意事项：不仅可以使用模块内的函数以及类还可以使用变量等其他一切资源！\n\n​\t\n\n\n\n### 如何查看 python 解释器寻找模块所在路径的方法\n\n\n\n关键字：sys.path\n\n语法：\n\n```python\n\timport sys\n\tprint（sys.path）\n```\n\n\n\n注意：sys.path是一个列表，里面存放着 python 解释器查找模块的所有路径\n\n\n演示：\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184426752.png)\n\n\n\n\n\n\n\n### 如何利用 import 导入指定路径的模块\n\n\n\n第一步：查看目标模块的路径\n\n![image-20211012184507006](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184507006.png)\n\n\n\n\n\n第二步：将目标模块路径加到 python 查找模块路径的列表内即可！\n\n添加方法：\n\n1：列表.append（待添加数据）\n\n2：列表.insert（位置，待添加数据）\n\n\n\n\n\n注意事项：\n\n1：向 sys.path 列表（python查找模块的路径列表）内添加完模块目标路径之后，程序重新运行后，添加的那些数据会被清空！只是临时添加，需要重新添加否则报错\n\t\t\n2：必须要先添加模块所在路径才能 import 导入 目标模块，否则报错！！\n\n![image-20211012184533216](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184533216.png)\n\n\n\n\n\n关于注意事项1的截图\n\n![image-20211012184548407](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184548407.png)\n\n\n\n\n\n\n\n## import的reload加载问题【重点】\n\n\n\n### 为什么要在一段程序中重新加载模块\n\n\n\n答：一段程序用到某模块运行时，其他人修改了这个模块的代码，但是运行的这段代码用的还是没修改之前的模块，这样就会造成损失，所以需要重新加载模块\n\n\n\n注意事项：import 有防止模块重复功能，就是导入两个相同的模块，后面导入的那个一样的模块就不起作用了！\n\n\n\n问题演示:\n\n![image-20211012184600024](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184600024.png)\n\n\n\n\n\n### 使用 reload 方法重新加载模块\n\n\n\n关键字：reload\n\n\n\n语法：\n```python\nfrom imp import reload\nreload（待加载的模块名）\n```\n\n\n\n代码演示：\n\n![image-20211012184615552](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211012184615552.png)\n\n\n\n\n\n\n\n\n## from…import * 的私有化问题【重点】\n\n\n\n\n### 什么是模块内变量私有化？\n\n答：只允许模块内的变量在模块内运行时被调用打印，在别的程序内无法调用此变量\n\n\n\n\n\n### 怎么实现模块内变量的私有化？\n\n关键词：_变量名\n\n语法：\n\n```python\nfrom 模块名 import *\nprint（_变量名）\n```\n\n\n\n注意：\n\n1：上述语法执行就会报错，因为用 from 模块名 import * 导入模块时，被下划线处理的变量是无法被导入的因此报错\n\n2：在模块内利用下划线_  处理的变量名，只有在 from 模块名 import * 时才能实现变量私有化，其他的任何导入方法都可以进行导入该变量！\n\n\n\n图示：\n\n模块内代码\n\n![image-20211012184711976](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184711976.png)\n\n\n\n导入模块代码\n\n![image-20211012184720347](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184720347.png)\n\n\n\n\n\n\n\n\n\n## import和from…import的区别【重点】\n\n\n\n目标：掌握 import 与 from …. import …. 两种导入模块方式的区别\n\n\n\n### import 与 from …. import …. 两种导入模块方式的区别\n\n\n\nimport导入模块：直接引用模块里面的所有内容，导入模块后对该模块内的函数、变量做出更改，那么原始模块内的数据也随之发生改变\n\n\n\nfrom …. import ….导入模块：复制导入模块的所有变量、函数以及类并且拷贝到当前py文件内，不是直接引用模块内的方法等，这样对模块内的变量等进行修改后，原始模块内的数据将不发生变化！\n\n\n\n\n\n注意事项：在掌握两种导入模块的区别之后，当遇到多个文件共享一个模块内的变量时（一个文件更改模块内容，其他文件可一接收到更改后的内容），那我们就要用到第一种导入模块的方式哦（import）\n\n\n\n图示：\n\n![image-20211012184743276](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184743276.png)\n\n\n\n\n代码：\n\ngirl模块内的代码\n\n![image-20211012184751624](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184751624.png)\n\n\n\n\n\n\n## 可变参数的拆包问题【重点】\n\n\n\n### 可变参数 *args 与 **kwargs 分别接受什么形式的数据？\n\n\n\n`*args`：将接收的数据存储在元组内\n\n接收数据形式：a ,b,c,d,e      数据之间逗号分割\n\n\n\n\n\n`**kwargs`：将接受的数据存储到字典内\n接受数据形式：a = 10，b = 20        赋值的方式\n\n\n\n图示：\n\n![image-20211012184810727](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184810727.png)\n\n\n\n\n\n### 如何将数据拆包并传递给其他函数\n\n\n\n首先分析出现下面问题的原因\n\n![image-20211012184824680](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184824680.png)\n\n\n\n问题修正\n\n加上` * `与 `**` 可将 元组和字典拆包\n\n![image-20211012184831694](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184831694.png)\n\n\n\n\n\n## 单继承中的super【重点】\n\n\n\n### 类中的 super（）方法的作用\n\n\n\n答：调用父类中的方法\n语法：super（）. 父类方法     例如 super.（）__init__(参数1，参数2…..）  调用父类的初始化方法 __init__(参数1，参数2…..)\n注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！\n\n\n\n\n\n图示：\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184831694.png)\n\n\n\n\n\n\n\n### 什么是__mro__序列\n\n\n\n功能：查看目标类的父类以及祖父类等等一直向上，直到 object\n\n语法：目标类.__mro__\n\n注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！\n\n\n\n代码：\n\n![image-20211012184855505](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184855505.png)\n\n\n\n\n\n### 单继承类中的 super 调用父类方法是遵循__mro__序列调用的\n\n\n\n代码截图：\n\n![image-20211012184915904](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184915904.png)\n\n\n\n\n\n结果截图：\n\n![image-20211012184922866](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184922866.png)\n\n\n\n\n\n\n\n## 多继承和MRO顺序1【重点】\n\n注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！\n\n\n\n目标：\n1：掌握子类继承父类时调用父类方法的两种形式以及区别\n\n2：掌握什么是多继承中的菱形继承（钻石继承）\n\n2：掌握多继承中的mro顺序作用\n\n\n\n\n\n### 子类继承父类时调用父类方法的两种形式以及区别\n\n\n\n方法一：父类名.方法名（self，参数1，参数2……..）   例如 parent . __init__(self , name , age , gender)\n\n\n\n方法二：super（）. 方法名（参数1，参数2…..）        例如 super（）.__init__（name，age，gender）\n\n\n\n两种方法的区别：第一种方法继承时要传递参数 self    第二种方法不需要传递 self ！！\n\n\n\n图示：\n\n\n\n父类名.方法名（self，参数1，参数2……..）\n\n![image-20211012184943566](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184943566.png)\n\n\n\n\n\nsuper（）. 方法名（参数1，参数2…..）\n\n![image-20211012184958749](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184958749.png)\n\n\n\n\n\n### 什么是多继承中的菱形继承（钻石继承）\n\n\n\n图示：\n\n![image-20211012185007087](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185007087.png)\n\n\n\n注意事项：\n\n1：出现菱形继承时，如果操作不当（利用父类名调用父类方法），可能会出现祖父类的某方法调用多次（只想调用一次），这是我们必须要用super（）继承父类方法来解决这一问题！！！\n\n2：因此在多继承中应该尽量避免使用父类名.父类方法  这种形式调用父类的方法，会造成有的父类方法调用两次，使用super调用了完美解决\n\n\n\n\n\n### 多继承中的mro顺序作用\n\n\n\n使用语法：\n\n1：类名.mro（）\n\n2：类名.__mro__\n\n![image-20211012185026156](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185026156.png)\n\n\n\n\n\n注意事项：\n\n1：多继承中利用 super 调用父类的方法，不一定是调用父类的方法，而是按照多继承中的 mro 顺序来调用的\n\n2：如果子类利用super调用父类方法，父类中没有super方法 就不会按照 mro 顺序调用方法，因此要想按照 mro 顺序调用方法，必须要求所有参与继承的家族类中都要有 super方法！\n\n\n\n注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！\n\n\n\n\n\n## property装饰的基本使用【重点】\n\n\n\n### property装饰类中的函数的作用！\n\n\n\n功能：在类中被 property 装饰后的函数，调用这个函数可像调用类中的属性一样使用（不用加括号了）！\n\n\n\n语法：\n```python\n@property\ndef function（self）\n\t…….\n```\n\n\n\n代码演示：\n\n![image-20211012185104567](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185104567.png)\n\n\n\n### 在类中使用 property 装饰的注意事项\n\n\n\n1：装饰的类函数中必须只有一个参数self，不允许有其他的参数！\n\n\n\n\n\n\n## property装饰的其他使用方法【重点】\n\n\n\n### property 装饰函数的 @xxxxx.setter 形式的功能！ \n\n\n\n功能：被 @xxxxx.setter 装饰的类里面的函数可以传递参数进去\n\n\n\n语法：\n\n```python\n@price.setter\ndef price（）\n\t……..\n```\n\n\n\n注意事项：\n\n1：@xxxxx.setter 中的 xxxxx 是被装饰的函数名！\n\n2：被@xxxxx.setter 装饰后的函数 通过实例对象.装饰函数名 = 参数   即可向被装饰后的函数传递参数！\n\n3：@xxxxx.setter 这种装饰函数必须要在 property 装饰函数的基础上才能使用，也就是说类里面必须有 property装饰方法，才能使用 @xxxxx.setter ，并且这两种方法装饰的函数名一样！\n\n\n\n代码演示：\n\n![image-20211012185131386](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185131386.png)\n\n\n\n\n\n### property 装饰函数的 @xxxxx.deleter 形式的功能！\n\n###  \n\n语法：\n```python\n@price.deleter\ndef price（）\n\t……..\n```\n\n\n\n代码体验：\n\n![image-20211012185142289](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185142289.png)\n\n\n\n\n\n\n## prepery作为类属性的值传入【重点】\n\n\n\n### 类属性与实例属性的区别\n\n\n\n定义区别：实例属性是在__init__方法里面定义的属性，而类属性是在类里面并且所有方法外面定义的属性\n\n\n\n调用区别：实例属性只能用类创建的实例调用，类属性可以用类名调用也可以用类创建的实例调用\n\n\n\n图示：\n\n![image-20211012185202109](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185202109.png)\n\n\n\n\n\n### property作为类属性的值传入其中四个参数作用及其使用方法！\n\n\n\n语法：类属性变量名 = property（参数1，参数2，参数3，参数4）\n\n其中参数1到参数3都是函数名，参数4是字符串类型的值！\n\n\n\n使用方法：\n\n1：当写下 类对象 . 类属性变量名   会自动调用名为参数1的函数\n\n2：当写下 类对象 . 类属性变量名 = 500  会自动调用名为参数2的函数（这个函数有参数 传递实参为500）\n\n3：当写下 del 类对象 . 类属性变量名      会自动调用名为参数3的函数\n\n4：当写下 类名.类属性变量名._ _doc_ _   可打印参数4的值\n\t\t\n\n注意事项：想打印参数4的值，要注意书写的不是类对象而是类名\n\t\t\n\n代码演示：\n\n![image-20211012185218659](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185218659.png)\n\n\n\n\n\n\n\n\n\n\n## 魔法属性和魔法方法【重点】\n\n\n\n### 类的魔法属性 _ _doc_ _的功能\n\n\n\n功能：查看类的说明（注释）或者类里面方法的注释\n\n\n\n语法：\n\n1：类名.__doc__    或 类对象.__doc__             查看类的注释\n\n2：类名.方法名.__doc__  或  类对象.方法名.__doc__              查看类里面方法的注释\n\t\n\n代码演示：\n\n![image-20211012185237938](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185237938.png)\n\n\n\n\n\n### 类的魔法属性 __module__ 与 __class__的功能\n\n\n\n__module__功能：查看当前类所在的模块！\n\n语法：类名.__module__  或   类对象.__module__\n\n\n\n\n\n__class__功能：查看当前对象所属的类！\n\n语法：类对象.__classes__\n\n\n\n\n\n代码：\n\n![image-20211012185248902](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185248902.png)\n\n\n\n\n\n### 类的魔法方法 __init__( ) 与 __del__( ) 的功能\n\n\n\n__init__( )功能：初始化魔法方法，在类创建对象时自动调用的方法！注意它不是构造方法，构造方法是__new__( ) 与 __init__( )的统称\n\n\n\n __del__( ) 功能：删除方法，当删除类创建的对象时自动调用的方法！\n\n\n\n代码：\n\n![image-20211012185258083](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185258083.png)\n\n\n\n\n\n### 魔术属性 __dict__ 的功能及其使用方法\n\n\n\n功能：查看类对象的实例属性并将属性以键值对的形式存放在字典内或查看类的所有类属性（实例属性除外）和类方法存放在字典内\n\n\n\n语法：\n\n1：类对象 . __dict__\n2：类名 . __dict__\n\n\n\n代码：\n\n![image-20211012185314019](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185314019.png)\n\n\n\n\n\n\n\n### 魔法方法 __call__( ) 与 __str__( ) 功能及其使用方法\n\n\n\n__call__( )功能：当实例化对象加上括号时，就会调用魔法方法__call__( )\n\n\n\n语法：实例对象（）\n\n\n\n__str__( ) 功能：当打印实例化对象时，就会调用__str__( ) 魔法方法，注意__str__方法内必须要有返回值，且返回值必须是字符串类型！\n\n\n\n语法：print（实例对象）\n\n\n\n代码演示：\n\n![image-20211012185335037](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185335037.png)\n\n\n\n\n\n### 魔法方法 __getitem__( key ) 、 __setitem__( key，value )、__delitem__( key )的调用方法\n\n\n\n__getitem__( key )调用方法：实例对象[key]      就会调用此方法\n\n\n\n __setitem__( key，value )调用方法：实例对象[key] = value          就会调用此方法\n\n\n\n__delitem__( key )调用方法：del 实例对象[key]        就会调用此方法\n\n\n\n代码演示：\n\n![image-20211012185346280](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185346280.png)\n\n\n\n\n\n\n\n## with管理上下文方式【重点】\n\n\n\n### 利用 with 操作文件的优点\n\n\n\n答：与单纯的 open 打开文件相比，当 open 打开文件出现错误时，因为资源已经分配，所以对这个文件资源进行关闭操作就会失败，with 方式操作文件可有效解决这一问题！不会出现文件关闭失败的情况！\n\n\n\n### with 操作文件的步骤！\n\n\n\n第一步：执行上下文管理类里面的上文方法即 __enter__（）并且返回一个对象，也就是 as 后面的那个变量（实质是打开文件返回的对象）！\n\n\n\n第二步：利用返回的对象对文件进行读写等操作！\n\n\n\n第三步：执行上下文管理类里面的下文方法即 __exit__( ) 即关闭文件！\n\n\n\n注意事项：\n\n1：执行 __enter__（）上文方法返回的对象也就是 as 后面的 file ，file的实质为  file = open（“文件名”，“打开方式”）的打开文件操作的语句，而非是 open类\n\n2：下面的注释中有一处错误就是 with open（“text.txt”，“r”） 的 open 不是一个类，而是一个上下文管理函数！！\n\n\n\n代码：\n\n![image-20211012185403180](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185403180.png)\n\n\n\n\n\n### 自己构建一个上下文管理器类实现读取指定文件内容\n\n\n\n什么是上下文管理器？\n\n答：即支持 with 操作的类或者函数！\n\n\n\n\n\n上下文管理器类包含的方法：\n\n1：初始化方法__init__( )  用来接收参数【文件名、打开方式】\n\n2：上文方法__enter__( ) 用来打开文件并且返回这个对象\n\n3：下文方法__exit__( ) 用来关闭打开的文件！\n\n\n\n注意事项：类里面如果有多个方法想共用一个变量，那么这个变量要变成实例属性的方式才行，也就是加上self\n\n\n\n代码：\n\n![image-20211012185419418](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185419418.png)\n\n\n\n\n\n\n\n### 利用装饰器装饰函数的方法实现 with 上下文管理操作文件（读取文件内所有数据）！\n\n\n\n实现关键字：\n\nyield：函数内 yield上方为上文，下方为下文，调用函数时，第一次调用执行到 yield 处，第二次执行从 yield 继续执行！\nyield有返回数据以及退出函数的功能\n\ncontextlib 库里面的装饰器 contextmanager ：利用 contextmanager 装饰器装饰写好的函数即可实现 with 上下文管理操作文件\n\t\n\t\n\t\n实现步骤：\n\n第一步：定义一个函数，传递两个参数即文件名以及文件打开方式\n\n第二步：在函数内部打开指定文件，并用 yield 返回打开文件的对象，yield上方的也就是上文\n\t\t\n第三步：在 yield 下方对打开的文件对象进行关闭！也就是上下文管理的下文\n\t\t\n第四步：导入 contextlib 模块里面的装饰器 contextmanager\n\t\t\n第五步：利用 @contextmanager 装饰写好的函数\n\t\t\n第六步：利用 \n\n```python\nwith 函数名（“文件名”，“打开方式”） as file ：\n\t\tresult = file.read（）\n\t\tprint（result）\n```\n读取指定文件的所有数据\n\n\n\n代码体验：\n\n![image-20211012185438098](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185438098.png)\n\n\n\n\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——GIL锁与深浅拷贝","url":"/2021/10/12/黑马程序员学Python——GIL锁与深浅拷贝/","content":"\n\n\n本文主讲：Python中的GIL锁以及怎么去解决这个问题，深浅拷贝等....\n\n\n\n<!--more-->\n\n\n\n\n\n## GIL锁对多任务的影响【重点】\n\n\n\n### unubtu 系统的 htop 指令查看CUP的使用情况（百分比）\n\n\n\n指令：终端输入 htop 即可\n\n\n\n图示：\n\n![image-20211012155420672](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155420672.png)\n\n\n\n\n\n### 单进程单线程死循环、多进程单线程死循环、多线程单进程死循环对CPU核的调用情况\n\n\n\n1.单进程单线程死循环使用情况：\n\n\n\n结论：单进程可完美利用cpu的核数\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155432451.png)\n\n\n\n\n\n2.多进程单线程\n\n结论：两个多进程死循环运行，两个cpu核利用率为百分之百，因此多进程可完美利用CPU的核数，不存在 cpu 利用不充分的问题哦！\n\n![image-20211012155447877](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155447877.png)\n\n\n\n3.多线程单进程\n\n结论：多个线程同时运行死循环函数，但是CPU的核却没有一个占满百分之百，可以说明多线程是伪多线程，并不能同时运行多个任务，这是因为GIL全局解释器锁的原因\n\n\n\n图示：\n\n![image-20211012155458246](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155458246.png)\n\n\n\n\n\n\n\n\n\n## GIL锁的概念及影响【重点、面试点】\n\n\n\n### 什么是GIL\n\n\n\n答：GIL称为全局解释器锁，python执行多线程任务之前，某线程会获得一把GIL，而且GIL又是一把互斥锁，某个线程执行任务调用cpu核资源时，其他线程就不能执行其他任务，只能等待GIL释放完毕才会执行任务，保证同一时间只有一个线程在使用GIL，简而言之，每个执行任务的线程都会获得一把GIL，有且整个程序只有一把GIL\n\n\n\n注意:GIL与python语言无关，而是与cpython解释器有关，比如jpython解释器就没有这个GIL\n\n\n\n\n\n### GIL存在的原因\n\n\n\n1：编写PYTHON的时候计算机普遍是单核cpu\n2：不加GIL执行多线程任务容易引起资源竞争\n\n\n\n\n\n### GIL对多任务的影响\n\n\n\n多线程：造成伪多线程，实际同一时间只有一个cpu内核在轮询执行任务，保证同一时间只有一个线程可以执行任务\n\n多进程：不会造成影响，两个进程，那就调度两个cpu内核执行这两个进程任务\n\n\n\n\n\n### 在什么时候可以释放GIL\n\n\n\n1：获得全局解释器锁的线程任务执行完毕\n\n2：获得全局解释器锁的线程超过时间片轮询时间，自动释放GIL，执行其他任务\n\n3：I/O操作阻塞时自动释放GIL\n\n4：获得全局解释器锁的线程执行阻塞时自动释放GIL\n\n\n\n\n\n你问我答：因为GIL也是一把互斥锁，那么是否意味着我们在操作多线程全局变量时不用添加互斥锁了呢？\n\n答：错误，因为无法控制GIL锁释放的时间，不能确保使用完全局变量的操作是否已经完成！\n\n\n\n课后习题：因为GIL存在的原因，多线程相当与伪多线程，那么为什么多线程的执行效率比多线程高呢？\n\n答：因为多线程执行任务时遇到I/O操作阻塞等原因会自动释放GIL\n\n\n\n\n\n## GIL解决方案【重点、面试点】\n\n\n\n### python多线程解决GIL问题的几种方案\n\n\n\n方案一：因为GIL是 python 底层解释器 Cpython 产生的，因此可以更换其他底层解释器，例如 jpython 【不推荐】\n不推荐原因：python默认解释器就是CPython，而不是Jpython，这肯定是有原因的\n\n\n\n\n方案二：将多线程改成多进程【推荐】\n\n优点：每一个进程都拥有一把GIL，不会因为互斥锁特性造成同一时间只有一个线程在执行任务，可以解决多线程利用 cpu 核不充分的问题\n\n缺点：进程是资源分配的基本单元，改成多进程会消耗更多的内存资源，当计算机内存紧张是不推荐使用！\n\n\n\n\n\n方案三：将多线程执行的任务（函数）改用 c语言代码编写，可避免GIL！\n\n\n\n详解：python是胶水语言，将 c文件编译为 so 文件，并在python内导入 ctypes 模块即可在python内执行 c文件代码！\n\n\n\n\n\n实现步骤：\n\n第一步：在pycharm内创建后缀为 c 的C语言文件  new → file →文件名.c  编写c语言任务代码（多线程执行任务的代码）\n\n![image-20211012155549163](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155549163.png)\n\n\n\n\n\n\n\n第二步：在 unubtu 终端内将后缀为 c 的文件编译为后缀为 so 的文件\n\n\n\n指令关键字：gcc\n\n语法：gcc  后缀为c的文件名  -shared  -o   待生成的后缀为so的文件名\n\n\n\n\n\n注意事项：\n\n1：待生成的后缀为so的文件名一般都是以lib三个字母开头\n\n2：需要进入c文件所在的文件夹内才能执行此命令\n\n3：-shares选项代表将目标文件编译为so文件\n\n4：-o选项是用来输入的文件名选项\n\n\n\n截图：\n\n![image-20211012155558587](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155558587.png)\n\n\n\n第三步：在python程序内导入 ctyes 库并导入 so 文件从而执行so文件内的多线程任务\n\n\n\n关键语法：\n```python\nimport ctypes\nlib = ctypes.cdll.LoadLibrary（“./so文件名”）\n```\n\n\n\n\n\n注意事项：\n1：导入so文件时，一定要在相对位置目录导入，并且要加上 ./\n\t\t\n\n代码演示：\n\n![image-20211012155611363](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155611363.png)\n\n\n\n第四步：执行代码查看cpu核的利用率判断是否解决了GIL\n\n![image-20211012155618933](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155618933.png)\n\n\n\n\n\n### 多线程的适用场景\n\n\n\n适用场景：I/O密集型可使用多线程（GIL锁会释放）\n不适用场景：CPU密集型不建议使用多线程（CPU利用率不高）\n\n\n\n\n\n\n\n## python可变与不可变【重点】\n\n\n\n### python中可变与不可变数据类型的分类以及区别\n\n\n\n可变数据类型：列表、字典\n\n不可变数据类型：数字、字符串、元组\n\n\n\n\n\n可变与不可变数据类型的区别：\n\n答：\n\n1.可变数据类型在内存创建变量后，如果这个变量发生改变（增加数据等），内存不会开辟新的空间来存放变化后的数据，而是在原位置增加内存空间用来存放变化后的数据\n\n\n\n2.不可变数据类型在内存创建变量后，如果这个变量发生变化，内存会开辟一块新的空间用来存放变化后的数据，而这个变量也会执行这个新的内存地址\n\n\n\n简而言之：可变数据类型在发生变化后，不会在内存中开辟新地址存放数据，不可变数据类型在数据发生变化后，会开辟新的内存地址存放数据，并且原地址数据会被内存释放掉\n\n\n\n\n\n注意事项：\n\n1：变量名指向的是变量的内存地址\n\n2：可变与不可变是数据发生改变后内存地址是否发生变化\n\n\n\n\n\n图示：\n\n![image-20211012155709565](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155709565.png)\n\n\n\n\n\n### 怎么用python代码验证可变与不可变数据类型\n\n\n\n关键字：id（变量名）\n\n方法：通过对比数据发生变化前后的内存地址变化从而确定是否为可变数据类型\n\n\n\n代码演示：\n\n不可变数据类型\n\n\n\n![image-20211012155721184](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155721184.png)\n\n\n\n\n\n可变数据类型\n\n![image-20211012155728120](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155728120.png)\n\n\n\n\n\n\n\n## 数据的浅拷贝与深拷贝区别【重中之重】\n\n\n\n### 数据的深浅拷贝区别\n\n\n\n浅拷贝：只拷贝数据的内存地址（引用），不会开辟新的内存空间，不能保证数据的独立性，如果拷贝的是对象【列表的嵌套】，原对象和copy对象都指向于同一个内存空间，不会拷贝对象内部的子对象\n\n\n\n深拷贝：拷贝后会开辟新的内存空间存放拷贝后的数据，如果拷贝的是对象【列表的嵌套】，原对象和copy对象指向不同的内存空间，会拷贝对象及其子对象\n\n\n\n注意事项：上述的深浅拷贝只是相对的，有些数据类型不能保证其正确性，比如简单可变数据类型（列表）的浅拷贝就会产生新的内存空间！\n\n\n\n\n\n### python怎么实现深浅拷贝\n\n\n\n关键字：\n\n浅拷贝：copy（变量名）\n\n深拷贝：deepcopy（变量名）\n\n\n语法：\n\n```python\nimport copy\nlist1 = [1,2,3,4]\nlist2 = copy.copy(list1)        浅拷贝\nlist3 = copy.deepcopy（list1）  深拷贝\n```\n\n\n\n图示：\n\n![image-20211012155801753](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155801753.png)\n\n\n\n\n\n\n\n## 简单可变类型深浅拷贝【重点】\n\n\n\n### 简单可变类型（列表）的深浅拷贝特点\n\n\n\n列表浅拷贝特点：产生新的内存空间，原列表与拷贝后的列表数据是相互独立的（互不影响），这与浅拷贝定义是不一样的一定要注意\n\n\n\n列表深拷贝特点：产生新的内存空间，原列表与拷贝后的列表数据是相互独立的（互不影响）\n\n\n\n注意事项：\n\n1：浅拷贝的定义是 对原数据进行拷贝不会产生新的内存空间，只是对原数据地址的拷贝，但是列表的浅拷贝却产生了新的内存空间\n\n2：拷贝后产生新的内存空间就是两个数据的内存地址不一样\n\t\t\n图示：\n\n浅拷贝\n\n![image-20211012155819140](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155819140.png)\n\n\n\n深拷贝\n\n![image-20211012155825294](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155825294.png)\n\n\n\n\n\n\n## 复杂可变类型深浅拷贝【重点】\n\n\n\n### 复杂可变类型【列表的嵌套】的深浅拷贝的区别\n\n\n\n注意：列表的嵌套可看做是一个对象，这样就更好的理解深浅拷贝定义的后两句话了！\n\n\n\n列表的嵌套浅拷贝：A是一个列表的嵌套对象，其中的子列表地址指向的是原列表的地址，相当于地址的引用，对A列表对象进行浅复制会产生新的内存空间，但是A列表内的子列表经过浅复制后不会产生新的空间，依旧是原列表地址的引用，因此对原列表数据进行更改，浅复制后的数据将发生变化！！\n\n\n\n简而言之：浅拷贝不会拷贝嵌套列表的子列表，只拷贝了地址（引用子列表）\n\n\n\n图示：\n\n![image-20211012155839315](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155839315.png)\n\n\n\n代码演示：\n\n注意：下面代码没有演示对A列表数据改变，观察C[0]与D[0]的数据变化   结果是也变化\n\n![image-20211012155847748](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155847748.png)\n\n\n\n\n\n列表的嵌套深拷贝：对嵌套的列表进行深复制会产生新的内存空间，并且嵌套的字列表也会产生新的内存空间，不再是地址的引用复制，这样对原数据进行更改，深复制后的数据将不再发生变化\n\n\n\n图示：\n\n![image-20211012155856726](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155856726.png)\n\n\n\n\n\n代码演示：\n\n![image-20211012155903218](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155903218.png)\n\n\n\n\n\n\n## 简单不可变类型深浅拷贝【重点】\n\n\n\n### 简单不可变数据类型（元组）的深浅拷贝\n\n\n\n答：简单可变数据类型（元组）不管是深拷贝还是浅拷贝都不会产生新的内存空间，只是单纯的拷贝地址（引用源对象），拷贝前后的数据也不是相互独立的\n\n\n\n代码：\n\n![image-20211012155911751](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155911751.png)\n\n\n\n\n\n## 复杂不不可变类型深浅拷贝【重点】\n\n\n\n目标：掌握复杂不可变类型（元组内嵌套列表）的深浅拷贝对比\n\n\n\n\n\n### 复杂不可变类型（元组内嵌套列表）的深浅拷贝对比\n\n\n\n元组内嵌套列表的浅拷贝：浅拷贝后元组不会产生新的内存空间，并且元组内嵌套的列表也不会产生新的内存空间，只是单纯的拷贝地址，原对象的引用！浅拷贝前后的数据也不是相互独立的！\n\n\n\n代码：\n\n![image-20211012155924656](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155924656.png)\n\n\n\n\n\n元组内嵌套列表的深拷贝：元组深拷贝之后会产生新的内存空间存放复制后的元组，并且元组内的列表也会开辟新的内存空间，不再是单纯的地址复制，这点从复制前后列表的地址不同可看出，而且复制后两个元组的数据是相互独立的（更改原元组内列表的数据，复制的元组列表内数据不会发生变化）\n\n\n\n代码：\n\n![image-20211012155937171](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155937171.png)\n\n\n\n重点：\n\n1：复杂不可变类型数据（元组内嵌套数据）的深拷贝，如果元组内嵌套的是可变数据类型（列表）就会开辟新的内存空间保存可变的嵌套数据，如果嵌套的是不可变数据类型（元组），则不会开辟新的内存空间存放嵌套的数据！\n\n2：复杂不可变类型数据（元组内嵌套数据）的浅拷贝，不管元组内嵌套的是可变还是不可变数据类型，都不会开辟新的内存空间，直接内存地址的引用，类似于超链接\n\n\n\n\n\n\n## 切片拷贝、字典拷贝【重点】\n\n\n\n### 简单可变数据类型（列表）的切片拷贝是深拷贝还是浅拷贝\n\n\n\n切片拷贝示例代码：\n\nlist1 = [1,2,3]\n\nlist2 = list1[ : ]\n\nlist2就是list2的切片拷贝\n\n\n\n实验结论：简单可变数据类型（列表）的切片拷贝是深拷贝\n\n代码体验：\n\n![image-20211012155954539](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155954539.png)\n\n\n\n\n\n### 复杂不可变数据类型（元组内嵌套列表）的切片拷贝是深拷贝还是浅拷贝\n\n\n\n结论：是浅拷贝\n\n\n\n代码演示：\n\n![image-20211012160004682](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012160004682.png)\n\n\n\n### 简单可变数据类型（字典）的字典拷贝是深拷贝还是浅拷贝\n\n\n\n关键字：copy\n\n语法：dict2 = dict1.copy（）\n\n注意事项：字典拷贝不需要导入 copy 模块即可使用 copy 方法\n\n结论：简单可变数据类型（字典）的字典拷贝是深拷贝\n\n\n\n代码演示：\n\n![image-20211012160018221](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012160018221.png)\n\n\n\n\n\n\n\n### 复杂可变数据类型（字典内嵌套列表）的字典拷贝是深拷贝还是浅拷贝\n\n\n\n结论：复杂可变数据类型（字典内嵌套列表）的字典拷贝是浅拷贝\n\n\n\n代码图示\n\n![image-20211012160030517](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012160030517.png)\n\n\n\n\n\n\n未完待续.......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——装饰器基础","url":"/2021/10/12/黑马程序员学Python——装饰器基础/","content":"\n\n\n本文主讲：闭包的概念，装饰器入门、类装饰器、多重装饰器等等....\n\n\n\n\n\n<!--more-->\n\n\n\n\n\n\n\n## 闭包基础【重点】\n\n\n\n### 将函数名赋值给变量并且打印，会打印出什么\n\n\n\n答：函数变量名保存的是这个函数在内存中存储的十六进制的地址\n\n\n\n注意事项：函数名只是函数地址的一个引用，也就是一个变量  它可以赋值给其他变量，也可以被其他值赋值\n\n\n\n图示：\n\n![image-20211012154150057](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154150057.png)\n\n\n\n代码：\n\n![image-20211012154157111](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154157111.png)\n\n\n\n### 了解函数的闭包\n\n\n\n闭包概念：在一个外函数中定义一个内函数，内函数里运用了外函数的临时变量，并且外函数返回值是内函数的函数名（引用）\n\n\n\n函数形成闭包的条件：\n\n1：在外函数内部又定义了一个内函数\n\n2：内函数可以引用（使用）外部函数的临时变量（内部函数引用外部变量）\n\n3：外部函数返回值是内部函数的引用（函数名）\n\n\n\n图示：\n\n\n\n注意：下面代码的result（10，20）  不指定参数10，也是可以打印10 的，因为这个参数定义的形参就是和外部函数一致的\n\n![image-20211012154211238](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154211238.png)\n\n\n\n\n\n## 闭包中的变量问题【重点】\n\n\n\n### 闭包中变量使用的一些问题\n\n\n\n问题图示：\n\n![image-20211012154222272](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154222272.png)\n\n\n\n解决办法：\n\n\n\n在内部函数打印前提前声明 num 变量不使用内部函数的nun即可！\n\n关键字：nonlocal\n\n\n\n图示\n\n![image-20211012154232949](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154232949.png)\n\n\n\n\n\n\n\n\n## 装饰器入门【面试点】\n\n\n\n### python内装饰器的使用场景\n\n\n\n答：装饰器可以在不改变函数源代码的前提下为函数增加新的功能\n\n\n\n\n\n装饰器的使用前提：\n\n1：有一个待扩展功能的普通函数（不改变这个函数的源代码增加新功能）\n\n2：装饰器要依赖于闭包才能实现扩展新功能（用于扩展函数新的功能）\n\n\n\n\n\n### 工作写代码的准则\n\n\n\n答：掌握开放封闭原则，即以前写好的功能尽量不要修改其源代码（封闭），但是可以对以前写的功能进行扩展也就是开放（装饰器）\n\n\n\n### 装饰器的语法及使用依赖和使用方法\n\n\n\n语法：@闭包内的外层函数名\n\n\n\n示例：\n```python\n\t@function_out\n\tdef test( ):\n\t\txxxx\n\t\tXxxx\n```\n\n\n\n其中function_out是闭包中的外层函数名，test（）是待扩展功能的普通函数\n\n\n\n使用依赖：\n\n1：必须要有一个待扩展功能的函数\n\n2：必须要有一个闭包，为待扩展函数在不修改源代码的前提下增加功能\n\n3：在装饰器模式下，原来的闭包就被称为装饰器了\n\n\n\n\n\n\n注意事项：\n\n1：闭包的外层函数必须要有参数，用于待扩展函数的函数名传递\n\n2：上方的 @function_out 等价于 test = function_out(test)\n\n\n\n使用方法图示：\n\n![image-20211012154304559](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154304559.png)\n\n\n\n\n\n注意事项：\n\n1：test = function_out(test) 前后两个test代表的函数地址是不一样的  前面test代表的是闭包内层函数的地址，后面test代表的是test函数的内存地址！\n\n2：闭包内的 func（）函数执行的就是待扩展的函数 test（）\n\n\n\n\n\n\n\n\n## 装饰器装饰有参数的函数【应用】\n\n\n\n### 装饰器如何装饰有不可变参数的函数\n\n![image-20211012154317998](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154317998.png)\n\n\n\n\n\n### 装饰器如何装饰有可变参数的函数\n\n\n\n答：function_in（闭包的内层函数参数）函数与 func 函数的参数设置同名！\n\n\n\n### 图示分析\n\n![image-20211012154328310](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154328310.png)\n\n\n\n\n\n## 装饰有返回值的函数【应用】\n\n\n\n### 如何装饰有返回值的函数\n\n\n\n目标需求：\n\n![image-20211012154344345](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154344345.png)\n\n\n\n实现代码：\n\n![image-20211012154351297](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154351297.png)\n\n\n\n\n\n## 实现通用版装饰器【重点】\n\n\n\n### 装饰器通用版的模板是什么样的！（既能传递参数也能有返回值）\n\n\n\n代码：\n\n![image-20211012154408237](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154408237.png)\n\n\n\n\n\n\n\n## 在装饰器外部设置变量（定义函数）【理解】\n\n\n\n### 如何在装饰器外部设置变量（定义函数）\n\n\n\n答：即在装饰器（原始闭包）的外部再次定义一个函数并且返回原装饰器外层函数的函数名\n\n\n\n注意事项：设置装饰器外部变量看着像是创造了装饰器，因此这种语法模式也被称为装饰器工厂模式\n\n\n\n图示：\n\n![image-20211012154420691](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154420691.png)\n\n\n\n### 怎么使用设置外部变量后的装饰器！\n\n\n\n关键字：@设置的外部变量函数名（参数）      例如   @variable（“haha”）\n\n\n\n注意：@variable（“haha”）  分为三步从而达到调用装饰器的目的\n\n第一步：先执行  variable（“haha”）函数\n\n第二步：执行   @第一步函数的返回值  例如 @function_out\n\n第三步：正常执行装饰器的步骤\n\n\n\n图示：\n\n![image-20211012154442599](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154442599.png)\n\n\n\n\n\n\n\n### 不设置外部变量的装饰器与设置外部变量装饰器的区别\n\n\n\n答：装饰器的调用一定要注意区别\n\n\n\n例如 @ viriable（“lala”）  与  @viriable   有参数和没参数就天差地别\n\n\n\n注意：装饰器的调用有参数就说明这个装饰器设置了外部变量，没有参数就没有设置外部变量！\n\n\n\n\n\n\n## 多重装饰器【面试点】\n\n\n\n### 什么是多重装饰器？\n\n\n\n答：多重装饰器就是多个装饰器（闭包）装饰一个待扩展的函数\n\n\n\n\n\n### 多重装饰器的工作流程\n\n\n\n实例：\n\n@ 第一个闭包外层函数名         → 这是第一个装饰器\n\n@ 第二个闭包外层函数名         → 这是第二个装饰器\n\n待扩展函数                              → 这是待装饰的函数\n\n\n\n工作流程：函数从上向下开始执行 执行到第一个装饰器之后因为装饰器下面没有函数因此先停止装饰，第二个装饰器开始装饰下面的待扩展函数装饰完毕后第一个装饰器再装饰已经被第二个装饰器扩展完毕的函数！\n\n\n\n也就是第二个装饰器装饰函数  →  第一个装饰器装饰被第二个装饰器扩展的函数！\n\n\n\n![image-20211012154520715](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154520715.png)\n\n\n\n\n\n### 多重装饰器的工作步骤（具体观看视频 p204）\n\n![image-20211012154528084](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154528084.png)\n\n\n\n\n\n\n\n## 类装饰器【重点】\n\n\n\n### 为一个类创建的对象加上括号会发生什么？\n\n\n\n答：为一个类创建的对象加上括号会调用这个类中的 __call__ 方法\n\n\n\n图示：\n\n![image-20211012154539853](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154539853.png)\n\n\n\n### 什么是类装饰器\n\n\n\n答：正常装饰器的扩展体是一个闭包，而类装饰器的扩展体是一个类！\n\n\n\n\n\n### 怎么使用类装饰器\n\n\n\n关键字：@类名     例如  @Test\n\n\n\n使用方法：在待扩展函数前面加上@类名   即可实现利用类装饰器装饰函数的功能\n\n\n\n实例：\n```python\n@Tset\ndef ceshi( ):\n\tXxx\n\tXxx\n\tXxx\n```\n\n\n\n注意事项：\n\n1：上面示例的 @Test  等价于  ceshi = Test（ceshi）\n\n2：实例化的对象加上括号就会调用类里面的 __call__( )方法\n\n3：类装饰器中的类必须包含两种方法，__init__( ) 与 __call__( ) 方法，而且 __init__( ) 方法必须接收 待扩展的函数名！并且初始化 例如 self.func = func   __call__( )方法内必须要执行 self.func（）才能达到装饰函数的目的\n\n\n\n代码演示：\n\n![image-20211012154600352](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154600352.png)\n\n\n\n\n\n\n\n## 数据库的主从配置【了解】\n\n\n\n### 数据库的主从配置使用场景\n\n\n\n答：当我们做一个项目时，一台服务器上的数据库保存着大量重要的数据，这时为了避免这个地区断电或者其他原因造成这个数据库（主服务器）不能正常访问，我们就可以访问从服务器，避免事故\n\n\n\n注意事项：\n\n1：主服务器与从服务器是即时通信的，主服务器上数据发生变化，会通过二进制报文与从服务器进行通信，从服务器可以实时更新数据\n\n2：主服务器与从服务器的数据库版本以及环境要一模一样，否则不能建立通信\n\n3：主服务器与从服务器不要放在同一地区\n\n​\t\t\n\n### 数据库主从配置的配置步骤\n\n\n\n请去浏览器搜索查看步骤！\n\n\n\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"Mysql操作——数据库高级","url":"/2021/10/12/Mysql操作——数据库高级/","content":"\n\n\n\n\n本文主讲：Mysql数据库中的高级操作，例如建立与删除索引、管理用户等......\n\n\n\n<!--more-->\n\n\n\n\n\n## 数据库索引——建立和删除索引【重点】\n\n\n\n### 数据库索引的应用场景\n\n\n\n答：假设数据库内有大量数据时，我们要查找某一行数据，为这个数据字段加上索引会大大的提高查询效率，提高查询速度！\n\n索引在数据库内的保存机制是平衡查询树机制，即 B+tree\n\n\n\n\n\n### 怎么在数据库内创建索引\n\n\n\n语法：\n\n1：create index 索引名称 on 数据表名（字段名（长度））\n\n2：create index 索引名称 on 数据表名（字段名）\n\n\n\n\n\n注意事项：\n\n1：如果数据库内是唯一索引，索引名称按照 unip_字段名称 来命名，非唯一索引按照 idx_字段名称来命名\n\n2：索引名称必须全部为小写\n\n3：如果需要加索引的那个字段是字符串类型，那么在创建索引时要加上这个字段的最大长度，例如 varchar（10），就要加上10\n\n4：单张表中索引数量不超过5个\n\t\t\n快速代码体验：\n\n![image-20211012153012185](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153012185.png)\n\n\n\n### 怎么查看数据库内的索引\n\n\n\n语法：show  index from 数据表名\n\n\n\n代码：\n\n![image-20211012153021236](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153021236.png)\n\n\n\n### 怎么删除数据库的索引\n\n\n\n语法：drop index 索引名称 on 数据表\n\n\n\n代码：\n\n![image-20211012153029769](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153029769.png)\n\n\n\n\n\n\n## 数据库索引——插入10万条数据\n\n\n\n### 怎么在 python 端向数据库插入100000 条数据\n\n\n\n答：利用 for 循环\n\n\n\n代码：\n\n![image-20211012153041798](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153041798.png)\n\n\n\n\n\n\n## 数据库索引——验证索引效率【重点】\n\n\n\n### 如何验证数据库插入索引后查询某条数据的效率会提升！\n\n\n\n答：利用 mysql 数据库内置的SQL语句耗时监视方法 —— profiling （耗时监视方法）\n\n\n\n\n\n验证步骤：\n\n\n\n第一步：打开 SQL语句耗时监视方法 即 set profiling = 1 ；\n\n\n\n第二步：执行查询某条数据的SQL语句 例如 select * from indes_ceshi where title = \"haha_99999\"；\n\n\n\n第三步：为要查询的数据字段加上索引再次查询第二步相同的数据\n\n\n\n第四步：执行显示耗时语句 即 show profiles；\n\n\n\n第五步：对比耗时，看加入索引是否提升了效率\n\n\n\n\n\n图示：\n\n![image-20211012153103669](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153103669.png)\n\n\n\n\n\n\n## 用户管理【重点】\n\n\n\n\n### Mysql用户的应用场景\n\n答：就像做公众号一样，多人团队协作，创建其他用户并分配一些权限用于多人协作，每一个用户有自己的职责\n\n\n\n\n\n### 怎么查看指定数据库的所有用户\n\n\n\n第一步：利用 root 用户登录数据库，并且进入默认创建的 mysql 数据库，即 use mysql；\n\n\n\n第二步：利用 desc 查看 user 数据表内的字段结构 即desc user；\n\n\n\n第三步：利用 select 查看用户、主机等字段信息，即 select host，host  from user；\n\n\n\n截图：\n\n![image-20211012153124479](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153124479.png)\n\n![image-20211012153133021](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153133021.png)\n\n\n\n\n\n\n\n### 怎么创建用户并且分配权限\n\n\n\n创建用户步骤：\n\n第一步：利用 root 登录数据库，进入指定数据库\n\n第二步：创建用户，即 create user “用户名”@“主机名”identified by “密码”；\n\n第三步：给这个用户分配权限，即 grant 权限 on python_ceshi2 . *  to“用户名”@“主机名”；\n\n\n\n其中 python_ceshi2 . * 表示为 python_ceshi2 数据库内的所有数据表添加这个用户权限，也可以是为特定数据表添加权限等！\n\n用户权限有很多种，例如 create select ，insert ，update，delete等，其中 all privileges 代表添加所有权限\n\n注意区分主机名是localhost与%的区别\n\n\n\n第四步：刷新权限，即 flush privileges；\n\n\n\n截图：\n\n注意：下面的截图忘记了第四步骤即刷新权限 flush privileges；\n\n\n\n![image-20211012153201477](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153201477.png)\n\n\n\n\n\n### 怎么查询一个用户的所有权限\n\n\n\n语法：show  grants for “用户名”@“主机”；\n\n\n\n截图：\n\n![image-20211012153218766](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153218766.png)\n\n\n\n\n\n\n## 用户管理——增加权限【重点】\n\n\n\n### 怎么增加指定用户的权限\n\n\n\n语法：grant update on 数据库.数据表 to “用户名”@“主机” with grant option；\n表示向指定用户新增 update 权限\n\n\n\n截图：\n\n![image-20211012153230513](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153230513.png)\n\n\n\n\n\n## 用户管理——重置密码【重点】\n\n\n\n### 如何在知道密码的情况下重置用户密码\n\n\n\n语法：alter user “用户名”@“主机” identified by “新密码”\n\n\n\n注意事项：这个操作需要用户先输入数据库原始密码进入数据库之后才能操作\n\n\n\n截图：\n\n![image-20211012153241543](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153241543.png)\n\n\n\n\n\n### 如何在丢失用户数据库密码的情况下修改密码\n\n\n\n第一步：停止数据库服务，即 sudo service mysql stop\n\n\n\n第二步：编辑数据库文件，即 sudo gedit  找到某一个数据库文件，在[mysqld]字段下面添加 skip-grant-tables\n\n\n\n第三步：重启数据库 service mysql start\n\n\n\n第四步：直接在命令行输入 mysql 即可进入数据库\n\n\n\n第五步：用这个指令修改密码 update user set authentication_string = \"\" where user=\"root\"  重置 root 用户的密码\n\n\n\n第六步：退出数据库 输入空密码进行登录数据库 即 mysql -u root -p \n\n\n\n第七步：通过指令 alter user “root”@“%”identified by “新密码”进行重置密码\n\n\n\n\n\n\n\n\n## 用户管理——删除用户【重点】\n\n\n\n\n\n### 如何指定用户远程登录数据库\n\n\n\n第一步：本地数据库内检查用户的主机是否为%，如果是localhost就不能远程登录，只能本机登录，需要修改\n\n第二步：在 Windows 中输入指令即可远程连接数据库，即 mysql -h windows的ip地址 -u 用户名 -p  然后输入密码即可\n\n\n\n### 如何删除数据库指定用户\n\n\n\n语法：\n\n1：drop user “用户名”@“主机”\n2：delete from user where user = “laowang”  （进入mysql数据库内的user表内删除用户）\n\n\n\n\n\n\n\n\n## 爬虫实战——爬取数据保存至数据库内【应用】\n\n\n........\n\n\n\n\n\n## 爬虫实战——展示爬取的数据【应用】\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Mysql操作"],"categories":["Mysql操作"]},{"title":"Mysql操作——数据库编程","url":"/2021/10/12/Mysql操作——数据库编程/","content":"\n\n\n\n\n本文主讲：Mysql数据库中外键的使用、事务的概念、Mysql数据库与Python进行交互等....\n\n\n\n<!--more-->\n\n\n\n\n\n## 外键使用\n\n\n\n### 外键的使用场景\n\n\n\n答：两个数据表相关联，一个数据表是产品名称，另一个数据表是这些产品的分类，向产品名称这个数据表添加数据时，但是产品分类这个数据表内没有这个产品的相应分类，我们就不能向名称数据表进行插入数据，这时就要用到外键！\n\n\n\n### 什么是外键\n\n\n\n答：两个数据表相关联时，一个数据表的主键出现在另外一个数据表中，称另外这个数据表内的这个字段为外键\n\n\n\n图示：\n\n![image-20211012151343486](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151343486.png)\n\n\n\n### 怎么向已经存在的字段添加外键约束\n\n\n\n关键字：foreign key 、references\n\n语法：`alter table product add foreign key (nid) references classification(id);`\n\n表示向 product 表的 nid 字段添加外键，这个外键引用于 classification数据表的主键（id字段）\n\n\n\n快速代码体验：\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151343486.png)\n\n\n\n### 怎么在创建数据表时添加外键\n\n\n\n语法：\n\n\n\n```\ncreate table product_test（\n\t\tid int not null primary key，\n\t\tname varchar（10）not null，\n\t\tmid int not null，\n\t\tforeign key (mid) references  classification（id））；\n```\n\n\n\n上面语法表示创建 product_test 数据表并且为mid字段加上外键，foreign key (mid) references  classification（id）语法表示将mid字段设置为外键，外键引用于 classification数据表的 id 字段\n\n\n\n注意事项：创建数据表添加外键，引用于哪个数据表的字段，那么这个数据表必须事先存在，例如上述的classification数据表之前就已经创建好！\n\n\n\n快速代码体验：\n\n![image-20211012151414268](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151414268.png)\n\n\n\n### 怎么查询数据表中的外键字段名称\n\n\n\n`show create table 要查找外键的数据表名`\n\n例如：`show create  table product_test;`\n\n代码演示\n\n![image-20211012151423481](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151423481.png)\n\n\n\n注意事项：上面查询的字段名称不是 mid 而是刚开始的那段字符串，即 product_test_ibfk_1 才是字段名称\n\n\n\n### 怎么删除数据表中的字段外键\n\n\n\n`alter table 数据表名 drop foreign key 外键字段名`\n\n\n\n快速代码体验\n\n![image-20211012151433707](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151433707.png)\n\n\n\n\n\n## 视图的概念【重点】\n\n\n\n### 什么是视图，视图的使用场景\n\n\n\n\n答：简而言之就是将复杂的 SQL 语句封装成一张视图！只可查询数据，不可更改\n\n使用场景：需要重复使用某条SQL语句时，就可以将这条 SQL 语句封装成视图\n\n图示：\n\n\n\n![image-20211012151443532](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151443532.png)\n\n\n\n\n\n\n\n\n## 视图的使用【重点】\n\n\n\n### 视图的创建语法以及怎么查看视图是否创建成功\n\n\n\n创建语法：`create view 视图名 as 封装的SQL语句；`\n\n查看语法：`show tables；`\n\n\n\n注意事项：\n\n1：视图名一般要以 v_ 开头 例如 v_name\n\n2：视图只是一个虚拟的表，当视图数据来源的表数据发生变化时，视图内的数据也会发生变化！\n\n\n\n快速代码体验：\n\n![image-20211012151514095](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151514095.png)\n\n\n\n\n\n### 怎么查看视图内的数据以及怎么删除视图\n\n\n\n查看视图数据语法：`select * from 视图名；`\n\n\n\n删除视图语法：`drop view 视图名`\n\n\n\n快速代码体验；\n\n![image-20211012151525693](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151525693.png)\n\n\n\n\n\n## 事务概念及特性【面试题】\n\n\n\n\n\n### 事物的使用场景\n\n\n\n答：假设控制数据库查询某些数据需要好几条SQL语句，而且这几条语句要么全都执行成功，要么全都执行失败，我们就可以把这几条SQL语句加到事物当中！比如说去银行给别人汇钱操作，分为 查询余额、你给别人汇款操作、别人收款操作，要么这几个步骤全部执行成功，要么这几个步骤全部执行失败！\n\n\n\n简而言之，数据库的事务，就是当执行某操作，其中一个步骤失败，就回到未执行前的状态！要么事务所有步骤全部执行成功，要么全部失败！\n\n\n\n事务功能：保证某个操作要么一定成功执行，要么一定失败执行\n\n\n\n### 事务的四大特性（ACID）\n\n\n\n1.原子性：一个事物必须被视为不可分割的最小单元，也就是事务内的所有步骤都是不可分割，要么所有步骤全部成功执行，要么全都失败回滚\n\n\n\n2.一致性：数据库总是从一个状态转换到另外一个状态，汇钱例子，我向你打款500元，我余额减少500，你的余额必须增加500\n\n\n\n3.隔离性：一个事务所做的修改在最终提交以前，对外是不可见的，例如汇款，我的余额600，正在向你汇款500，汇款的过程未结束时，别人是不可在用你卡向别人汇款的，因为他看到你的余额还是600元\n\n\n\n4.持久性：一旦事务提交，则其所做的修改将永久保存到数据库\n\n\n\n图示\n\n![image-20211012151606508](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151606508.png)\n\n\n\n\n\n## 事务使用【重点】\n\n\n\n### 什么是表引擎以及怎么查看数据表表引擎分类\n\n\n\n答：表引擎就是数据表在系统中的存储方式\n\n\n\n查看数据表表引擎分类语法：show engines；\n\n\n\n代码演示：\n\n![image-20211012151624749](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151624749.png)\n\n\n\n### 怎么查看数据表使用的是什么表引擎\n\n\n\n语法：`show create table  数据表名；`\n\n\n\n代码演示：\n\n![image-20211012151633154](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151633154.png)\n\n\n\n\n\n### begin、commit、rollback关键字对事务的影响\n\n\n\nbegin：开启事务，开启事务之后对数据库的更改都要符合事务的使用规范\n\n\n\ncommit：提交事务，开启事务后对数据库修改数据，如果不 commit 一下，别人看见的数据还是未修改之前的，所以数据修改完成后，需要commit才能正式生效，注意 commit之后 在 rollback 不能回滚之前的数据库状态\n\n\n\nrollback：事务回滚，开启事务后修改数据，没有 commit 之前，执行 rollback后，数据库会回到事务begin之前的状态\n\n\n\n注意事项：在事务开启之后，执行了 commit 或者 rollback 之后，事务就关闭了，想在再次开启事务，需再次执行 begin 指令！\n\n\n\n代码演示：\n\n![image-20211012151646638](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151646638.png)\n\n\n\n![image-20211012151656081](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151656081.png)\n\n\n\n\n\n## 验证事务的ACID特性【重点】\n\n\n\n目标：掌握如何验证事务的隔离性（I）\n\n\n\n### 如何验证事务的隔离性（I）\n\n\n\n答：LINUX同时开启两个客户端，一个客户端开启事务，对数据进行修改，并且不要commit与rollback（代表事务没有结束），另一个客户端不需要开启事务，同时对这个数据进行更改，就会发现没开启事务的更改数据不成功！\n\n\n\n代码演示：\n\n![image-20211012151709986](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151709986.png)\n\n\n\n\n\n\n## 数据库的三范式【了解】\n\n\n\n前言：数据库设计三范式就是设置数据库时的注意事项\n\n\n\n### 数据库设计的第一、第二、第三范式\n\n\n\n第一范式：强调列的原子性，即每一个字段都不能再次拆分成其他几个字段\n\n![image-20211012151722041](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151722041.png)\n\n\n\n\n\n\n第二范式：需满足第一范式，一个表内必须要有一个主键，非主键字段必须要完全依赖于主键字段，不能只有一部分字段依赖主键，即所有非主键字段全都要完全依赖于一个主键，不能有一部分依赖这个主键，其他不依赖这个主键\n\n注意事项：如果数据表不满足第二范式，可以将数据表进行拆分\n\n![image-20211012151738763](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151738763.png)\n\n\n\n\n\n第三范式：必须要满足第二范式，非主键字段必须直接依赖于主键字段，不能存在传递依赖\n\n![image-20211012151747531](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151747531.png)\n\n\n\n注意事项：如果数据表不满足第二范式，可以将数据表进行拆分\n\n\n\n![image-20211012151758531](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151758531.png)\n\n\n\n\n\n\n\n## E-R模型及表间关系【了解】\n\n\n\n### E-R模型的使用场景\n\n![image-20211012151819642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151819642.png)\n\n\n\n\n\n### E-R模型的组成部分\n\n\n\n组成部分：实体、实体属性、联系\n\n![image-20211012151831293](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151831293.png)\n\n\n\n\n\n### 数据表之间的一对一、一对多、多对多关系\n\n\n\n一对一：数据表1中的一个字段数据对应数据表2中的一个字段数据，可以靠两个表来实现关系，符号是 1-1\n\n![image-20211012151842427](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151842427.png)\n\n\n\n\n\n\n\n\n\n一对多：数据表1中的一个字段数据对应数据表2中的多个字段数据，可以靠两个表来实现关系，图示一个班级对应多名学生，符号为 1-N表示\n\n![image-20211012151850087](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151850087.png)\n\n\n\n多对多：数据表1中的一个字段数据对应数据表2中的多个字段数据，数据表2中的一个字段数据对应数据表1中的多个字段数据，不能靠两个表来实现关系，需要第三个中间表才能实现数据的保存，图示一个科目可以有多个学生选，一个学生也可以选多们课程，符号为 N-N表示\n\n\n\n![image-20211012151857844](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151857844.png)\n\n\n\n\n\n\n\n## 58到家数据库的30条军规解读【重点】\n\n\n\n军规阅读地址：\n\n\n\nhttps://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959906&idx=1&sn=2cbdc66cfb5b53cf4327a1e0d18d9b4a&chksm=bd2d07be8a5a8ea86dc3c04eced3f411ee5ec207f73d317245e1fefea1628feb037ad71531bc&scene=21&key=e82f935468864c7d48052912f819a6dd5e6242373178c6cf6b2a30bc7a3bc45cf528644761f1c83760a26aa894abf4ecc9a77152e7a9d688d98cf9acbefe04f63cb0dbecd86ed0463d85e6e4022081a7&ascene=7&uin=MjE4OTMzMzMwNA%3D%3D&devicetype=Windows+10&version=6203005d&pass_ticket=HwLIq9t4Fwuxfe3EcHX5%2B6GOZG4yYlLMCZ8YH%2FvGq5QnbR%2FjduDlkLzmQa2Y%2BuiY&winzoom=1#%23\n\n\n\n\n\n重点内容提取：\n\n1：数据库必须使用 InnoDB存储引擎\n\n2：数据库必须使用 utf-8进行编码\n\n3：并发量大、数据量大的互联网业务禁止使用外键\n\n4：禁止使用小数存储货币\n\n5：禁止使用select * 只获取必要的字段，需要显示说明列属性\n\n6：禁止大表使用join（连接）\n\n\n\n\n\n\n\n## python连接操作MySQL【重点】\n\n\n\n### python 连接数据库的功能\n\n\n\n答：用 python 代码充当客户端，对数据进行增删改查等操作\n\n\n\n\n\n### python 连接数据库的步骤并实现查询数据库操作\n\n\n\n连接前准备： pip3 install pymysql 安装 pymysql 包\n\n\n\n第一步：导入 pymysql 模块 即 import pymysql\n\n\n\n第二步：建立数据库连接对象（相当于建立一条通信的高速公路）\n\n\n\n\n\n语法：connection = pymysql.connect（host，port，root，possword，database，charset）\n\n\n\n参数详解：\n\nhost：数据库所在的主机\n\nport：连接数据库主机的端口号，可省略，默认3306\n\nuser：连接数据库用户名\n\npassword：连接数据库密码\n\ndatabase：要连接的数据库名\n\ncharset：通信采用的编码，可省略，默认是 utf-8\n\n\n\n\n\n第三步：在连接（公路）的基础上，（利用高速公路）创建游标对象（相当于高速公路上的通信兵）\n详解：cursor 相当于数据库与 python 端的通信兵，数据库数据的操作以及取出都是靠这通信兵来完成\n\n\n\n语法：游标对象 = 连接对象.cursor（）  例如 cursor_obj = connection.cursor（）\n\n\n\n\n\n第四步：利用通信兵的 execute 方法对数据库的数据进行查询操作，并返回影响数据库几行数据的结果！\n\n关键字：execute\n\n语法：num_result = cursor_obj.execute（SQL语句）\n\n\n\n注意：\n\n1：返回的结果是num类型\n\n2：SQL语句是查询语句那就影响所有行数\n\n3：SQL语句是字符串类型\n\n\n\n\n\n第五步：利用通信兵的fetchone或者fetchall方法查询数据库的数据\n\n\n\n关键字：\n\nfetchone（）：查询数据库第一行数据\n\nfetchall（）：查询数据库所有数据\n\n\n\n语法：\n\n1：data_result = cursor_obj.fetchone( )\n\n2：data_result = cursor_obj.fetchall( )\n\n注意：fetchone或者fetchall方法查询数据返回的结果都是元组，不同的是fetchone返回的是一个元组，如果数据库有多行数据则fetchall返回的是元组的嵌套\n\n\n\n\n\n第六步：关闭通信兵以及高速公路\n\n\n\n关键字：close\n\n语法：\n```\nconnection.close（）\ncursor_obj.close( )\n```\n\t\n\n\n\n截图演示：\n\n![image-20211012152014285](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152014285.png)\n\n\n\n\n\n代码演示：\n\n![image-20211012152021827](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152021827.png)\n\n\n\n\n\n\n\n\n\n### 用 python 连接数据库并实现数据库的增删改操作\n\n\n\n关键字：execute\n\n语法：\n\n返回影响行数值 = 游标对象 . execute（增删改SQL语句） 例如 result_num = cursor_obj.execute(SQL语句)\n\n连接对象.commit（）  即对数据表修改后需要提交！！\n\t\n\n注意事项：\n\n1：在对数据库进行增删改操作之后，需要提交修改，做的更改才会生效，否则不生效\n\n2：对数据库进行增删改需要提交，查询操作不需要提交！\n\n3：commit提交不是用游标对象提交，而是用连接对象来提交\n\n\n\n\n代码演示：\n\n![image-20211012152039698](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152039698.png)\n\n\n\n\n\n### 游标对象的 fetchone 与 fetchall 方法在数据库不同操作时打印结果的不同！\n\n\n\n\n答：fetchone（）与fetchall（）方法只有在查询数据库（即查询数据库的SQL语句：select……）的时候才能打印出数据，当增删改数据库里面数据的时候，使用fetchone（）或fetchall（）方法是查询不出来数据的\n\n\n\n\n\n## SQL防注入【重点】\n\n\n\n### 什么是SQL注入\n\n\n\n答：在查询数据库数据操作时，当别人在输入一些特殊的字符串的时候，可能会获得我们数据库里面的大量数据，但是这些数据我们是不想让它获取的，这样就造成了数据泄露，也称为SQL注入\n\n\n\n\n\n### 怎么防止SQL注入\n\n\n\n实现点：在利用 cursor 通信兵对象的 execute 方法时，向这个方法内传入第二个参数可有效防止SQL注入（占位符）\n\n\n\n实现语法：num_result = cur_obj.execute(SQL语句，params)  其中 params 是一个列表参数，列表内存放着SQL语句要查询的字段名或其他参数\n\n\n\n注意：参数列表中可以有多个参数，因此SQL语句中也要有多个占位符与其一一对应，\n\n\n\n代码演示：\n\n![image-20211012152104800](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152104800.png)\n\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Mysql操作"],"categories":["Mysql操作"]},{"title":"Mysql操作——进阶指令语法","url":"/2021/10/11/Mysql操作——进阶指令语法/","content":"\n\n\n\n\n本文主讲：Mysql数据库内高级的操作指令，例如where比较运算、order排序、grep分组、连接查询等..\n\n\n\n<!--more-->\n\n\n\n\n\n## 强化练习——去重复【重点】\n\n\n\n### 查询结果去重复关键字 —— distinct\n\n\n\n功能：将查询结果去重复\n\n语法： select distinct  字段名 from 数据表名；\n\n\n\n快速代码\n\n![image-20211011202331816](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202331816.png)\n\n\n\n## where之比较运算【重点】\n\n\n\n### Mysql数据库中几种比较运算符\n\n\n\n常见几种Mysql运算符：\n\n大于：>\n\n小于：<\n\n大于等于：>=\n\n小于等于：<=\n\n等于：=\n\n不等于：!= 或者 <>\n\n\n注意事项：在Mysql内，等于号是 = 而不是 ==\n\n\n\n\n\n### where之比较查询的方法\n\n\n\n功能：利用比较运算符查询符合条件的数据\n\n\n\n语法：\n\n1：select * from 数据表名 where id <> 15；(表示查询id不等于15的所有字段数据)\n\n2：select * from 数据表名 where id = 15; （表示查询id等于15的所有字段数据）\n\n\n\n快速代码体验\n\n`<>`   不等于运算符\n\n![image-20211011202447791](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202447791.png)\n\n\n\n=   等于运算符\n\n![image-20211011202455234](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202455234.png)\n\n\n\n\n\n## where之逻辑运算【重点】\n\n\n\n### Mysql的几种逻辑运算符\n\n\n\n和运算符：and\n\n或运算符：or\n\n非运算符：not\n\n\n\n### where之逻辑运算符查询的语法\n\n\n\n功能：按照逻辑运算符查询符合条件所有字段的数据\n\n\n\n语法：\n1：select * from 数据表名 where id > 15 and gender = “女”; (表示查询id大于15并且性别为女的所有字段数据)\n\n2：select * from 数据表名 where id > 15 or new_age  > 20 ; (表示查询 id 大于 15 或者 new_age 大于 20 的所有字段数据)\n\n3：select * from 数据表名 where not id > 15 ; (表示查询id小于等于15的所有字段数据)\n\n4：select * from 数据表名 where not id > 15 and gender = “女”; (表示查询id小于等于15并且性别为女的所有字段数据)\n\n\n\n快速代码体验\n\nand和or的代码体验\n\n![image-20211011202535900](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202535900.png)\n\n\n\nnot代码体验\n\n![image-20211011202554729](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202554729.png)\n\n\n\n\n\n\n## where之模糊查询（类似于正则）【重点、常用】\n\n\n\n### 模糊查询的几个关键字\n\n\n\nlike：放在字段后面使用用于模糊查询\n\n%：表示匹配0个或多个任意字符，类似于正则表达式中的 *\n\n_：表示匹配单个任意字符，类似于正则表达式中的 . \n\n\n\n### where之模糊查询的使用方法\n\n\n\n功能：模糊查询符合规则的字段所有数据，类似于正则表达式匹配字符串\n\n应用场景：百度搜索引擎的模糊关键字查询\n\n\n\n语法：\n1：select * from 数据表名 where name like “张%”; （表示查询name字段中 第一个字符是张的所有名字信息）\n\n2：select * from 数据表名 where name like “张_”；（表示查询name字段第一个字符是张，第二个字符任意的所有名字信息，注意名字只有两个字符）\n\n3：select * from 数据表名 where name like “%莉%”；（表示查询name字段中包含莉这个字符的所有数据信息）\n\n\n\n快速代码体验\n\n语法一代码\n\n![image-20211011202631791](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202631791.png)\n\n\n\n语法二代码\n\n![image-20211011202640661](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202640661.png)\n\n\n\n语法三代码\n\n![image-20211011202647375](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202647375.png)\n\n\n\n\n\n## where之范围查询【重点】\n\n\n\n### in、not in、between and、not between and 关键字的作用\n\n\n\nin：表示查询在非连续范围内的所有数据\n\nnot in ：表示查询不在这个非连续范围内的所有数据\n\nbetween and：表示查询在连续范围内的所有数据\n\nnot between and ：表示查询不在这个连续范围内的所有数据\n\n\n\n\n\n### where之范围查询的使用方法\n\n\n\n功能：查询指定范围内（非连续范围与连续范围）的所有数据\n\n语法：\n\n1：select * from 数据表名 where id in（14，16，18）；（表示查询id为14，16，18的所有字段数据）\n\n2：select * from 数据表名 where id not in （14，16，18）；（表示查询id不是14，16，18的所有字段数据）\n\n3：select * from 数据表名 where id between 14 and 16；（表示查询id在14到16之间的所有字段数据，包括14与16）\n\n4：select * from 数据表名 where id not between 14 and 16；（表示查询id不在14到16之间的所有字段数据）\n\n\n\n\n\n注意事项：\n\n1：利用关键字 between 16 and 18 在连续范围内查询数据时，包含16与18\n\n2：利用关键字 not between 16 and 18 查询数据时不能这么写 not （between 16 and 18）即不能加括号！\n\n\n\n\n快速代码体验：\n\nin关键字与not in 关键字\n\n![image-20211011202723777](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202723777.png)\n\n\n\nBetween and 关键字与 not between and 关键字\n\n![image-20211011202732020](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202732020.png)\n\n\n\n\n\n\n\n## where之空值判断【重点】\n\n\n\n###  is null 关键字与  is not null 关键字的作用\n\n\n\nis null ：查询指定字段内数值为空（null）的所有数据（将指定字段内数据为空的数据查询出来）\n\nis not null：查询指定字段内数据非空的所有数据\n\n\n\n\n\n### where值空值判断的使用方法\n\n\n\n功能：查询某一个字段内的空（null）与非空的所有数据值\n\n\n\n语法：\n\n1：select * from 数据表名 where new_age is null；（表示查询new_age字段中所有数值为空（null）的所有数据）\n\n2：select * from 数据表名 where new_age is not null；（表示查询new_age字段中所有数值不为空的所有数据）\n\n\n注意事项：在查询非空数据的时候，不能写成 not is null 而是 is not null 这是甲鱼的臀部\n\n\n\n快速代码体验\n\n![image-20211011202821485](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202821485.png)\n\n\n\n\n\n## order排序【重点】\n\n\n\n### Mysql排序关键字 order by\n\n\n\n当sql语句中出现 where 关键字时就说明要按照条件查询数据， 当出现 order by 关键字时就说明要对查询数据进行排序啦\n\n\n\nwhere 关键字与 order by 关键字关系图示\n\n\n\n\n\n### Mysql 升序（asc）与降序（desc）的关键字\n\n\n\nasc：当字段后面出现 asc 关键字时就说明将这个字段内的所有数据按照升序排列\n\ndesc：当字段后面出现 desc 关键字时就说明将这个字段内的所有数据按照降序排列\n\n\n\n注意事项：\n1：在写sql排序语句时，字段后面没有出现 asc与desc 默认按照升序（asc）进行排序\n2：字母的升序是 a-z ，降序为 z-a\n\n\n\n\n\n### order by 排序的使用方法\n\n功能：将查询的数据按照升序或者降序进行排序\n\n\n\n语法：\n\n1：select * from 数据表名 where id between 14 and 18 and gender = “男”order by new_age asc ;\n(表示先查询id在14到18之间的所有男性信息，然后将这些信息再次按照 new_age 字段内的数据进行升序排序)\n\n\n\n2：select * from 数据表名 where id between 14 and 18 and gender = “男”order by new_age desc\n(表示先查询id在14到18之间的所有男性信息，然后将这些信息再次按照 new_age 字段内的数据进行降序排序)\n\n\n\n注意事项：where关键字先按照后面的条件查询出符合条件的数据信息，然后 order by 关键字将 where查询的数据按照升序或者降序的规则进行排序，有点类似于linux指令的通道指令！\n\n\n\n快速代码体验：\n\n升序排列\n\n![image-20211011202943725](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202943725.png)\n\n\n\n\n\n降序排列\n\n![image-20211011202951809](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202951809.png)\n\n\n\n\n\n### 多字段排序\n\n\n\n应用场景：按照单个字段进行排序时，如果有几个数据是一样的，就可以使用另一个字段将相同的数据再次进行排序\n语法：select * from 数据表名 where id between 14 and 18 and gender= “男”order by new_age desc，id desc；\n（表示先查询id在14到18之间的所有男性信息，然后将这些信息再次按照 new_age 字段内的数据进行降序排序，如果new_age字段内有相同的数据信息，将相同的数据信息再次按照 id字段进行降序排列）\n\n\n\n快速代码体验：\n\n![image-20211011203007534](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203007534.png)\n\n\n\n\n\n\n\n\n## 聚合函数【重点】\n\n\n\n### 聚合函数的几个关键字\n\n\n\ncount（*）：查询整个数据表内有几行数据\n\nmax（字段名）：查询指定字段内的数据最大值\n\nmin（字段名）：查询指定字段的数据最小值\n\nsum（字段名）：计算指定字段内的所有数据总和\n\navg（字段名）：计算指定字段内所有数据的平均值\n\n\n\n\n\n### 使用聚合函数的注意事项\n\n\n\n1：聚合函数不能嵌套使用，例如 sum（max（字段名））\n\n2：聚合函数内的数据一般为字段名或者表达式\n\n\n\n\n\n### 聚合函数的使用方法\n\n\n\n#### 计算数据表内总共几行数据——count（*）\n\n\n\n语法：\n\n1：select count（*） from classes；表示查询classes数据表内一共有几行数据*\n\n2：select count（*）as 总数量 from classes；表示查询classes数据表内一共有几行数据，并将count（*）替换为总数量显示出来\n\n3：select count（*） from classes where gender = \"男\"; 表示查询数据表内所有男性一共几行数据\n\t\n\n快速代码体验：\n\n![image-20211011203105924](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203105924.png)\n\n\n\n#### 查询指定字段内的最大、最小值\n\n\n\n语法：\n\n最大值\n\n1：select max（new_age） from classes；表示查询new_age字段内数据的最大值\n\n2：select max（new_age） from classes where gender = \"女\"； 表示查询所有女性new_age字段内的最大值\n\n\n\n最小值\n\n1：select min（new_age） from classes；表示查询new_age字段内数据的最小值\n\n2：select min（new_age） from classes where gender = \"女\"；表示查询所有女性new_age字段内的最小值\n\n\n\n快速代码体验\n\n![image-20211011203126427](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203126427.png)\n\n\n\n####  计算指定字段所有数据的总和以及平均值\n\n\n\n语法：\n\n总和：select sum（new_age）from  classes；\n\n平均值：select avg（new_age）from  classes；\n\n\n\n快速代码体验：\n\n总和\n\n![image-20211011203407105](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203407105.png)\n\n\n\n平均值\n\n![image-20211011203414077](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203414077.png)\n\n\n\n\n\n### round函数对数据的四舍五入以及保留几位小数的处理\n\n\n\n语法简洁：round（数值，num）num代表保留几位小数\n\n\n\n语法：select round（avg（new_age）,2）from classes；表示计算classes数据表内new_age字段所有数据的平均值并且保留两位小数\n\n\n\n注意事项：round（数据，num）不是聚合函数\n\n\n\n快速代码体验：\n\n![image-20211011203438263](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203438263.png)\n\n\n\n\n\n## grep分组【重点】\n\n\n\n### 分组关键字是什么？\n\n答：分组关键字是 group by 类似于 order by 以及 where\n\n\n\n\n\n### 对数据的分组\n\n\n\n功能：将数据表内的某一个字段的所有数据进行分组（分类），有便于聚合函数计算统计\n\n\n\n语法：\n\n1：select gender from classes group by gender；表示将gender这个字段内数据进行分组（去重复）\n\n2：select gender ，count（*）from classes group by gender；表示将gender这个字段内数据进行分组（去重复），并且计算每一个分组的人数（数量）\n\n3：select gender,max(new_age) from classes group by gender ;表示按照gender进行分组然后查找这些分组内new_age字段中的最大值打印\n\n注意事项：在写分组语法的时候 select 后面的字段必须是 group by 后面那个字段或者是聚合函数字段\n\t\t\n快速代码体验：\n\n语法1\n\n![image-20211011203506120](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203506120.png)\n\n\n\n语法2\n\n![image-20211011203515195](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203515195.png)\n\n\n\n### group by + group_concat 的功能以及使用方法\n\n\n\n功能：对分组之后的数据的某个字段的所有数据进行拼接\n\n语法：\n\n1：select gender ,count（*）， group_concat(name)  from classes group by gender;*\n表示按照 gender 字段进行分组后，显示每个分组内有几行数据（count（*））并将分组后的数据的name字段内的所有数据进行拼接显示出来\n\n\n\n快速代码体验：\n\n![image-20211011203601072](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203601072.png)\n\n\n\n\n\n### group by + having 的功能以及使用方法及其注意事项\n\n\n\n功能：一个数据表内的数据进行group by 分组后，在按照一定条件查询数据就要使用 having 关键字，而不能使用 where关键字了\n\n\n\n语法：\n\n1：select gender , avg(new_age)  as avg ,group_concat(name) from classes group by gender having avg > 18 ;\n表示按照gender进行分组后查询所有分组后数据的年龄平均值以及所有name字段的拼接字符串，在查询平均年龄大于18的数据\n\n\n\n注意事项：\n\n1：where关键字只能用在 group by 关键字前面，而having关键字只能用在group by 关键字前面\n\n2：order by 关键字也只能放在 group by 关键字后面\n\n3：where与having关键字的功能相同，都是按照某个条件查询数据\n\n\n\n快速代码体验\n\n\n\n![image-20211011203633969](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203633969.png)\n\n\n\n\n\n## limit限制记录【重点】\n\n\n\n### limit 关键字的功能\n\n功能：在海量数据内查询部分数据是就可以用到limit关键字啦\n\n\n\n\n\n### limit 关键字的使用方法及其注意事项\n\n\n\n语法：select * from 数据表名 limit 1 ，2；\n\n\n\n其中 1 代表数据存储位置代号，2 代表从代号为 1 的数据开始查询2条数据\n\n\n\n注意事项：limit关键字一定要写在mysql语法的最后面\n\n\n\n快速代码体验：\n\n![image-20211011203715243](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203715243.png)\n\n\n\n\n## 连接查询【重点、面试点】\n\n\n\n### 连接查询的使用场景\n\n答：当数据库内有多张表时，要从几张数据表内取一些数据并且连接到一张表内，这是就要用到连接查询\n\n\n\n###  mysql 数据库的几种连接查询方式\n\n\n\n1：内连接查询（inner join）【常用】\n\n查询的结果为两个表所产生交集的数据\n\n![image-20211011203728204](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203728204.png)\n\n\n\n2：外左连接查询（left join）\n\n查询的结果为两个表交集部分加上左表特有的数据\n\n![image-20211011203737285](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203737285.png)\n\n\n\n\n3：外右连接查询（right join）\n\n查询的结果为两个表交集部分加上表特有的数据\n\n![image-20211011203742496](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203742496.png)\n\n\n\n\n### 什么是笛卡尔积\n\n答：对于两个数据表使用笛卡尔积，就是将第1张表的每一个数据与第2张表的每一个数据都进行一次排列产生总数据的表\n\n![image-20211011203752250](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203752250.png)\n\n\n\n\n\n注意事项：笛卡尔积是表1的数据先与表2最后一项数据进行排列，依次类推\n\n\n\n\n\n### 内连接查询的使用方法\n\n\n\n关键字：inner join\n\n功能：查询两个表内有交集的数据\n\n语法：select * from 表1 inner join 表2 where/on 表1.字段名 = 表2.字段名\n\n表示查询表1与表2某个字段相等的那些数据项（条件关键字可以是where也可以是on）\n\n注意事项：内连接语法内不加条件判断，默认是笛卡尔积\n\n\n\n代码体验\n\n![image-20211011204209868](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204209868.png)\n\n\n\n### 外左连接查询的使用方法\n\n\n\n功能：查询两个表内相同的数据信息在加上左边表为空的那部分信息（主表的字段数据与从表的字段数据进行比对）\n\n\n\n关键字：主表 left join 从表\n\n\n\n其中主表为左表，从表为右表\n\n\n\n语法：select * from classes left join phone on/where classes.new_age = phone.age;\n\n\n\n表示classes主表内第一条记录的new_age字段值与phone从表的每一条记录的age字段值比对，有相同的则查询出来，当字段数据不相同时，也将数据显示出来，并且将从表phone的那部位用null补空，以此类推直到classes主表内的每一条记录的new_age字段值都比对完毕！\n\n\n\n注意事项：主表第一行记录的字段数据与从表每一行记录都要进行比对，有相等的查询出来，全都比对完还是没有相等的，从表那部分字段数据用null补空！\n\n\n\n快速代码体验\n\n![image-20211011204228413](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204228413.png)\n\n\n\n\n\n### 外右连接查询的使用方法\n\n\n\n功能：查询两个表内相同的数据信息在加上右边表为空的那部分信息（主表的字段数据与从表的字段数据进行比对）\n\n\n\n关键字：从表 right join 主表表\n\n\n\n其中主表为右表，从表为做表\n\n\n\n语法：select * from classes right join phone on/where classes.new_age = phone.age;\n\n\n\n表示phone主表内的第一条记录的age字段值与classes从表的每一条记录的new_age字段值比对，\n有相同的则查询出来，当字段数据不相同时，也将数据显示出来，并且将从表classes的那部位用null补空，以此类推直到phone主表内的每一条记录的age字段值都比对完毕！\n\n\n\n快速代码体验：\n\n![image-20211011204241438](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204241438.png)\n\n\n\n\n\n## 自连接查询【理解】\n\n\n\n### 自连接的使用场景\n\n\n\n答：比如说省、市、县三级联动式就要用到自连接来查询数据，即找到自身数据表内的某种关系，从而取出某些数据\n\n\n\n\n\n### 自连接的使用方法\n\n含义：特殊的内连接，自己连接自己\n\n关键字：数据表名 as 数据表别名1 inner join 数据表名 as 数据表别名2\n\n例如： classes as a inner join classes as b\n\n语法: select * from aress as a inner aress as b on a.aid = b.pid where a.name = “内蒙古”;\n\n表示 aress 数据表自连接，查询a（aress）表的aid字段与b（aress）表的pid字段相等的数据项并且连接打印出来，从而实现查找某某县是属于哪个市的！\n\n\n\n快速代码体验：\n\n![image-20211011204317242](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204317242.png)\n\n\n\n注意事项：数据表自连接时必须给自己取两个别名，否则会造成混淆，报错！！\n\n\n\n\n\n\n\n## 子查询【重点、面试点】\n\n\n\n### 子查询的应用场景\n\n答：查询某个信息，一条SQL语句不能成功查询，需要多条SQL语句才可成功查询，这是就可以用到子查询（sql语句的嵌套）\n\n\n\n\n\n### 什么是子查询以及分类及其用法\n\n\n\n子查询：子查询就是将一条或多条sql语句嵌套进另外一条SQL语句内，嵌套语句是子查询语句，被嵌套语句（外部）是主查询语句\n\n\n\n例如 select * from classes where age > (select avg(new_age) from phone);   黄色区域的就是子查询语句，外面的就是主查询语句\n\n\n\n子查询语句的分类：\n\n\n\n【重点】1.标量子查询：子查询语句返回的是一个数据，但不局限于数据（一行一列）\n\n\n\n【重点】2.列子查询：子查询语句返回的是一列多行的数据\n\n\n\n3.行子查询：子查询语句返回的是一行多列的数据\n\n\n\n4.表子查询：子查询语句返回的是多行多列的数据\n\n\n\n\n\n注意事项：子查询是一条完整独立的SQL语句\n\n\n\n子查询的用法（代码示例）：\n\n\n\n标量子查询语法：select * from classes where age > (select avg(age) from classes) ;\n\n表示查询 classes表内学生年龄age 大于学生平均年龄avg（age）的所有学生信息\n\n——————————————————————————————————————————\n\n普通语法：为了达到上面的结果，不使用子查询，需要写两条SQL语句才能实现\n\n语句1：select avg（age） from classes；   先求出学生的平均年龄，假设是28\n语句2：select * from classes where age > 28； 在查询比平均年龄大的学生信息\n\n———————————————————————————————————————————\n\n快速代码体验：\n\n![image-20211011204342655](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204342655.png)\n\n\n\n\n\n\n列子查询语法：select * from classes where classes.new_age in (select age from phone）;\n 表示查询出classes表内的new_age字段信息等于 phone表的age字段的所有学生信息\n\n——————————————————————————————\n\n普通语法：\n\n语句1：select age from phone   先查询出phone表内的所有age字段信息，返回值是一列多行，假设为1，2，5\n\n语句2：select * from classes where classes.new_age in (1，2，5）;\n\n\n\n快速代码体验：\n\n![image-20211011204402251](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204402251.png)\n\n\n\n\n\n\n## 数据的分页查询显示【目标】\n\n\n\n\n### 分页查询的使用场景\n\n答：数据库内有大量数据且要呈现给用户时，我们就要将所有数据进行分页显示，每页规定好有几条数据！\n\n\n\n\n\n\n### 怎么实现数据的分页查询\n\n答：利用 limit 限制记录可以实现分页查询\n\n\n\n实现公式：limit （显示第几页 - 1 ）* 每页展示给用户的数据数量（每页几条数据），每页几条数据\n\n\n\n公式详解：\n\n1：（显示第几页 - 1 ）* 每页展示给用户的数据数量（每页几条数据） 代表数据存储代号\n\n2：每页几条数据  代表查询几条数据\n\n\n\n公式实例： limit （4-1）*6 ，6  实例表示向用户展示第四页数据，每页数据有6条，那么就会从数据存储代号为18的数据考试显示，显示6条！\n\n公式截图：\n\n![image-20211011204427513](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204427513.png)\n\n\n\n\n\n实例语法：select * from classes limit （3-1）*2 ，2 ；  这个语第法表示从classes数据表的所有数据内显示第3页的数据，每页2条数据\n其中（3-1）*2 等于4 表示从数据存储代号为4的数据开始显示！！！\n\n\n\n快速代码体验\n\n![image-20211011204436010](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204436010.png)\n\n\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Mysql操作"],"categories":["Mysql操作"]},{"title":"Mysql操作——常用指令","url":"/2021/10/11/Mysql操作——常用指令/","content":"\n\n\n\n\n\n\n本文主讲：常用的SQL指令等等....【重点】\n\n\n\n<!--more-->\n\n\n\n\n\n## SQL指令——数据库的一般操作【重点】\n\n\n\n### SQL指令——show——查看所有数据库\n\n\n\n指令功能：\n1：查看当前连接的服务器所有的数据库信息\n2：查看创建数据库的过程\n\n\n\n\n指令示例：\n\n1（查看所有数据库）：`show databases`\n\n2（查看数据库的创建过程）：`show create database 数据库名`\n\n\n\n截图：\n\n![image-20211011194938794](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011194938794.png)\n\n![image-20211011194953090](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011194953090.png)\n\n\n\n\n\n\n\n### SQL指令——select——查看当前所在的数据库\n\n\n\n功能：查看当前所在的数据库\n\n指令格式：`select database（）；`\n\n截图：\n\n![image-20211011195019906](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195019906.png)\n\n\n\n\n\n### SQL指令——create——创建数据库\n\n\n\n功能：创建数据库\n\n指令：\n\n1(创建不指定编码的数据库)：`create database 数据库名;`\n2（创建指定编码的字符集）：`create database 数据库名 charset = 字符集;`\n\n\n\n​\t\n\n指令示例：\n\n1：`create database name1；` 表示创建一个名为name1不指定编码的数据库\n\n2：`create database name1 charset = utf8；` 表示创建一个名为name1编码为utf8的数据库\n\n\n\n\n\n截图：\n\n![image-20211011195036096](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195036096.png)\n\n\n\n\n\n### SQL指令——drop——删除数据库\n\n\n\n功能：删除指定MySQL数据库\n\n\n指令：`drop database 数据库名`\n\n示例：`drop database python_ceshi1`\n\n截图：\n\n![image-20211011195048859](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195048859.png)\n\n\n\n\n\n### SQL指令——use——选择指定数据库\n\n\n\n功能：选择指定的数据库\n\n指令：`use 数据库名`\n\n指令示例：`use python_database`\n\n截图：\n\n![image-20211011195058818](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195058818.png)\n\n\n\n\n总结：\n1：在使用 create 创建数据库的时候建议加上charset = utf8，要不然数据库容易出现乱码\n2：最常用的数据库操作指令 show 、create 、use\n\n\n\n\n\n\n\n## SQL指令——表的创建【重点】\n\n\n\n### SQL指令——create 在数据库内创建数据表\n\n\n\n功能：在指定的数据库内创建数据表，用来存放数据\n\n\n```\n指令语法：create table 表名（\n字段1的名称  字段1的数据类型 字段1的约束条件 ，\n字段2的名称  字段2的数据类型 字段2的约束条件 ，\n字段3的名称  字段3的数据类型 字段3的约束条件 \n\n\t\t）；\n```\n\n\n\n注意事项：\n\n1：每一个字段类型创建完毕后，都要在后面加上，最后一个字段除外\n\n2：字段的约束条件很多，可以是不为空（not null）、自动增长（auto_increment）、无符号(unsight)、主键约束（primary key）等等\n\n3：创建表时不要忘记最后括号外面的；号\n\n4：id字段（数据表第一个字段）一般约束为 (primary key主键) 与 (auto_increment自动增长)\n\n5：字段的约束条件可不写\n\n\n\n快速代码体验：\n\n![image-20211011195129435](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195129435.png)\n\n\n\n### SQL指令——show查看数据库内的数据表\n\n\n\n功能：查看指定数据库内的所有数据表\n\n语法：`show tables；`\n\n快速代码体验\n\n![image-20211011195142293](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195142293.png)\n\n\n\n\n\n### SQL指令——desc查看一个数据表内的所有字段信息\n\n\n\n功能：查看指定数据表内的所有字段信息\n\n语法：`desc 数据表名；`\n\n快速代码体验\n\n![image-20211011195153531](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195153531.png)\n\n\n\n### SQL指令——show create table 查看一个数据表的创建过程\n\n\n\n功能：查看指定数据表的创建过程\n\n\n\n语法：\n\n1：`show create table 数据表名 ; `   (虚线模式查看建表过程，较乱)\n2：`show create table 数据表名 \\G ;  `  （星号模式查看建表过程）\n\n\n\n\n快速代码体验：\n\n![image-20211011195209887](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195209887.png)\n\n![image-20211011195216854](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195216854.png)\n\n\n\n\n\n### SQL指令——drop 删除指定的数据表\n\n\n\n功能：删除指定的数据表\n\n语法：`drop table 数据表名`\n\n快速代码体验\n\n![image-20211011195226698](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195226698.png)\n\n\n\n\n\n\n\n## SQL指令——清除表内数据【重点】\n\n\n\n### 如何清除表内的数据\n\n语法：`truncate table 数据表名`\n\n\n\n\n\n\n\n\n\n## SQL指令——表结构（字段）的修改【重点】\n\n\n\n前言：本节课适用场景\n\n\n\n答：在创建好一个数据表情况下，发现这个数据表内的结构不满足条件，这时我们就要对这个数据表进行修改！\n\n\n\n\n\n本节必须注意：一个项目运行起来之后，我们就要谨慎修改数据表内的字段！否则会造成项目的瘫痪，那有什么办法可以避免修改数据库字段的情况呢？\n\n\n\n答：在创建数据表时，多创建几个空闲字段！\n\n\n\n\n\n\n\n目标：\n\n1：掌握SQL指令——add 向数据表内添加字段\n2：掌握SQL指令——change 修改数据表内字段的名称\n3：掌握SQL指令——modify 修改数据表内字段类型\n4：掌握SQL指令——drop 删除数据表内某一个字段\n\t\n\t\n\n### SQL指令——add 向数据表内添加字段\n\n\n\n功能：向指定数据表内添加一个新的字段\n\n语法：`alter table 表名 add 新字段名 字段类型 约束条件；`\n\n注意事项：在添加字段时约束条件可有可无\n\n快速代码体验\n\n![image-20211011195257504](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195257504.png)\n\n\n\n\n\n\n\n### SQL指令——change 修改数据表内字段的名称\n\n\n\n功能：修改指定数据表内指定字段的名称\n\n语法：`alter table 表名 change 原字段名 新字段名 新字段类型 约束条件；`\n\n快速代码体验\n\n![image-20211011195308611](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195308611.png)\n\n\n\n\n\n### SQL指令——modify 修改数据表内字段类型\n\n\n\n功能：修改指定数据表内的指定字段的数据类型\n\n语法：`alter table 表名 modify 字段名 新的数据类型 约束条件`\n\n注意事项：约束条件可不写\n\n快速代码体验\n\n![image-20211011195319203](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195319203.png)\n\n\n\n\n\n### SQL指令——drop 删除数据表内某一个字段\n\n\n\n功能：删除指定数据表内的指定字段\n\n语法：`alter table 表名 drop 字段名`\n\n快速代码体验\n\n![image-20211011195328433](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195328433.png)\n\n\n\n\n\n\n## SQL指令——数据表内数据的增删改查【重点】\n\n\n\n### SQL指令——select 查看数据表内字段的数据\n\n\n\n功能：查看数据表内字段的数据信息\n\n语法：\n\n1：`select * from 数据表名 ； ` （表示查看数据表内所有字段的数据信息）\n\n2：`select id ，name from 数据表名；`  （表示查看数据表内id和name字段的所有信息）\n\n3：`select id as “编号”,name as \"姓名\" from 数据表名 ；` （表示查询id与name字段的数据，以id别名编号与name别名姓名显示出来！！！）\n\n4：`select id  “编号”，name  “姓名” from 数据表名；`（表示查询id与name字段的数据，以id别名编号与name别名姓名显示出来！！！）注意: id与name后面的空格类似于as的功能\n\n5：`select * from 数据表名 where id = 1；` （表示查看id为1那个记录的所有字段的信息） \n\n\n\n\n\n\n\n注意事项：\n\n1：`select  id ，name from 数据表名；` 这样查出来的数据 id字段数据在 name字段数据前面显示\n\n2：查询字段的数据信息，如果一个数据表内没有数据，查询为空\n\n\n\n\n快速代码体验\n\n\n字段有数据查询全部\n\n![image-20211011195406050](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195406050.png)\n\n\n\n \n\n字段有数据查询全部\n\n![image-20211011195429410](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195429410.png)\n\n\n\n\n\n\n\n有数据查询指定别名字段数据\n\n![image-20211011195439947](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195439947.png)\n\n\n\n\n\n### SQL指令——insert 向数据表内增加数据\n\n\n\n功能：向指定数据表内添加数据\n\n\n\n语法：\n\n1：`insert  into  数据表名  value（字段1的值，字段2的值…….）`  【表示向数据表内添加所有字段的一行（记录）数据信息】\n\n2：`insert into 数据表名 value （字段1的值，字段2的值…）`，（字段1的值，字段2的值…）  【表示向数据表内添加所有字段的两行数据信息】\n\n3：`insert into 数据表名（id，name）value（id字段的值，name字段的值…）`   【表示向数据表内添加id字段与name字段的一行信息】\n\n\n\n注意事项：\n\n1：如果某个字段设置为自动增长，那么在向这个字段添加数据时可为空（null），系统会实现数据自动增长\n\n2：书写增加数据语句时可以写 value 也可以写 values\n\n\n\n快速代码体验：\n\n向数据表内添加多个记录（多行）数据\n\n![image-20211011195504599](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195504599.png)\n\n\n\n向指定字段添加数据\n\n![image-20211011195511467](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195511467.png)\n\n\n\n\n\n### SQL指令——update 更改数据表内的数据\n\n\n\n功能：对数据表内的已存在数据进行更改更新\n\n语法：\n\n1：`update 数据表名 set  字段名 = 更改值 `  （表示对数据表内某个字段的所有数据【全部记录】全部更改）\n\n2：`update 数据表名 set 字段名 = 更改值 where id = 1`   （表示对数据表内id等于1的记录的某个字段的数据进行更改）\n\n3：`update 数据表名 set 字段名1 = 更改值1，字段名2 = 更改值2` （表示更改多个字段的所有数据）\n\n\n\n快速代码体验\n\n更改一个字段的所有数据\n\n![image-20211011195534216](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195534216.png)\n\n\n\n\n\n更改指定一个记录的数据\n\n![image-20211011195540970](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195540970.png)\n\n\n\n\n\n### SQL指令——delete 删除数据表中的指定数据\n\n\n\n功能：物理删除指定数据表内的指定数据\n\n语法：\n\n1：`delete from 数据表名 ` （表示删除数据表内的所有数据）\n\n2：`delete from 数据表名 where id = 1 ` （表示删除数据表内 id字段等于 1 那个记录的数据）\n\n\n注意事项：delete指令是物理删除数据，不能恢复，我们可以选择逻辑删除从而更好地保存数据\n\n\n快速代码体验\n\n删除数据表内所有数据\n\n![image-20211011195556152](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195556152.png)\n\n\n\n删除指定条件（指定记录）的数据\n\n![image-20211011195602737](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195602737.png)\n\n\n\n\n\n### 逻辑删除数据表内的数据\n\n\n\n实现方法：\n\n第一步：向数据表内添加一个新的字段 字段名为 is_delete  字段属性为bit 字段默认值为 0\n\n第二步：将需要删除的一个记录（一行）数据的 is_delete那个字段数据默认值更改为 1\n\n第三步：查找is_delete 那个字段值为0的所有记录信息，默认值为0的那个记录不出现 就实现了逻辑删除\n\n\n\n实现代码：\n\n1.添加新字段：`alter table 数据表名 add  is_delete  bit  default 0 ;`\n\n2.更给默认值：` update 数据表名 set is_delect default = 1 where id = 2;`\n\n3.查找数据：`select * from 数据表名 where is_delete = 0 ;`\n\n\n\n\n\n注意事项：\n1：新建一个字段名为 is_delete的字段而不是 is_delect的字段（截图创建的就是错误的）\n\n2：创建is_delete字段时，字段的类型为bit，且默认值为0\n\n3：bit数据类型只能存放两个值即0与1\n\n\n\n\n\n快速代码体验\n\n![image-20211011195700792](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195700792.png)\n\n\n\n\n\n## SQL指令——数据库的备份与恢复【重点】\n\n\n\n### 在Linux终端将指定数据库备份（导出）为SQL文件\n\n\n\n功能：将数据库导出到计算机磁盘中（后缀为sql的文件）\n\n导出语法： `mysqldump -u 用户名 -p  数据库名  >  数据库文件名.sql`\n\n示例： `mysqldump -u root -p python_ceshi1 > python_ceshi2.sql`\n\n快速代码体验\n\n![image-20211011195716350](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195716350.png)\n\n\n\n\n\n### 在Linux终端将SQL文件导入到创建好的数据库中，以实现恢复数据库数据\n\n\n\n功能：将后缀为SQL文件导入创建好的数据库中，实现恢复数据库数据（数据表）功能\n\n导入语法：`mysql -u 用户名 -p 数据库名 < 后缀为SQL的文件`\n\n示例：`mysql -u root -p python_ceshi < python_ceshi2.sql `  (表示将python_ceshi2.sql脚本文件导入到名为python_ceshi这个数据库中)\n\n\n\n注意事项：因意外原因造成数据库删除，这是我们要新建一个同名的数据库，然后再把后缀为sql的备份文件导入才会成功，否则导入失败！\n\n\n\n快速代码体验\n\n![image-20211011195734526](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195734526.png)\n\n\n\n未完待续....\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Mysql操作"],"categories":["Mysql操作"]},{"title":"Mysql操作——数据库基础","url":"/2021/10/11/Mysql操作——数据库基础/","content":"\n\n\n\n\n本文主讲：关系型数据库的概念、及其一些核心的元素与简单的语法等等.....\n\n\n\n<!--more-->\n\n\n\n\n\n## 数据库概念及作用【了解】\n\n\n\n### 数据库的功能\n\n\n\n概念：数据库是以一定格式组织的数据集合，通俗来说就是计算机内一些具有特殊格式的数据文件集合（数据库是文件）\n\n\n\n作用：存储数据\n\n![image-20211011192834538](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011192834538.png)\n\n\n\n\n\n抛出问题：既然数据库是一种文件，那么我们为什么不用其他文件存储数据呢？因为数据库有以下优点！\n\n\n\n1：持久化存储\n\n2：读写速度极快\n\n3：保证数据的有效性\n\n4：对程序的兼容性好，容易扩展\n\n\n\n\n\n\n\n\n## 数据库的分类及特点【了解】\n\n\n\n\n据库排名网站：https://db-engines.com/en/ranking\n\n\n\n### 数据库的分类\n\n数据库一般分为关系型数据以及非关系型数据库\n\n\n\n### 不同分类数据库的概念与特点\n\n\n\n关系型数据库：是指采用关系模型来组织数据的数据库，通俗来说采用二维表格组织数据的数据库就是关系型数据库\n\n\n\n二维表示例\n\n![image-20211011192909691](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011192909691.png)\n\n\n\n\n\n关系型数据库的主要产品：MySQL 、Orcle、SQLite（移动端）SQLServer\n\n\n\nMySQL官网：https://www.mysql.com/\n\n\n\n\n\n————————————————————————————————————————————————————\n\n非关系型数据库概念：非关系型数据库也称为 NoSQL，即 not only SQL  ，它是利用键值对 key-value等方式来存储数据的！\n\n\n\n非关系型数据库主要产品：MongoDB 、Redis\n\n\n\n\n\n### 关系型数据库与非关系型数据库的对比分析\n\n\n\n关系型数据库优点：\n\n1：用的是表结构存储数据，容易理解\n\n2：使用的是通用的SQL语言\n\n3：减少了数据的冗余和数据不一致的情况发生\n\n4：可以进行表与表之间的复杂查询\n\n\n\n\n\n关系型数据库缺点：\n\n1：固定的表结构、灵活性不高\n\n2：为了维护表结构而牺牲大量的读写速度\n\n3：高并发读写能力差\n\n\n\n\n\n\n\n非关系型数据库优点：\n\n1：格式灵活，数据类型多种多样，可以是键对值，甚至是文档，图片，应用场景广泛，但是关系型数据库只支持原有的数据类型\n\n2：数据没有耦合性，容易扩展\n\n3：无需通过SQL层解析，读写能力较高\n\n4：成本低、NoSQL基本都是开源，部署简单\n\t\t\t\t\n\n\n\n非关系型数据库缺点：\n\n1：不提供SQL支持、学习成本高\n\n2：在数据复杂查询方面比较麻烦\n\n\n\n以上信息参考网站：https://www.cnblogs.com/zedian752/p/11338139.html\n\n\n\n\n\n## 数据库管理系统与SQL【了解】\n\n\n\n### 数据库与数据库管理系统的关系\n\n\n\n数据库管理系统概念：为了管理数据库而设计开发的软件系统，简称DBMS，它分为三大部分，如下！\n\n\n\n1.数据库文件集合：主要是一系列文件，这些文件用来存储数据\n\n2.数据库服务端：主要负责对数据库的文件和文件内数据进行管理\n\n3.数据库客户端：与数据库服务端进行通信，负责用来传输数据以及接收数据\n\n\n\n图示\n\n![image-20211011192948605](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011192948605.png)\n\n\n\n\n\n注意事项：数据库客户端想要通过数据库服务器获得或存储数据需要使用特殊的语言（SQL）\n\n\n数据库与数据库管理系统的关系：数据库是一些特殊格式文件的集合，而数据库管理系统是对数据库文件进行管理的软件系统\n\n\n\n\n\n### SQL语句\n\n\n\n概念：SQL是结构化查询语言，是一种用来操作 RDBMS (关系型数据库) 的数据库语言，它几乎支持所有的关系型数据库的数据管理操作，也就是说SQL是关系型数据库实现数据库客户端与数据库服务端通信的语言\n\n\n\n语法表现形式：具有特殊格式的字符串\n\n\n\nSQL语言的分类：\n\nDQL：数据查询语言、用于对数据的查询，例如select命令\n\nDML：数据操作语言、用于对数据记性增加、删除、修改，例如insert、delete、udpate命令\n\nDDL： 数据定义语言、用于新建、删除数据库、表等，例如create（新建）、drop（删除）命令\n\nTPL：  数据库处理语言、…….\n\nDCL： 数据库控制语言、……..\n\n\n\n\n\n主要学习前三个SQL语言即DQL（数据库查询语言） DML（数据库操作语言） DDL（数据库定义语言）\n\n\n\n\n\n\n## 关系型数据库中的核心元素【重点】\n\n\n\n一：关系型数据库中的核心元素\n\n\n\n前言：关系型数据库是由不同数目的数据二维表构成，而数据二维表由数据行与数据列构成\n\n\n\n\n\n关系型数据库的核心元素：\n\n数据库：数据表的集合\n\n数据表：用来存放数据的二维表\n\n数据行（记录）：构成数据表的行\n\n数据列（字段）：构成数据表的列\n\n\n\n图示：\n\n![image-20211011193040501](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193040501.png)\n\n\n\n\n\n注意事项：\n\n1：数据表中每一个数据列（每一列）的数据类型都是相同的（字段），每一个数据行都是一个完成的数据实体（记录）\n\n2：在关系型数据中心将二维表内的一行称为一个记录，一列称为一个字段\n\n​\t\t\n\n二：数据存入关系型数据库的步骤\n\n1：新建一个数据库\n\n2：创建存放数据的二维表\n\n3：将数据存入到数据表内\n\n\n\n\n\n\n\n## MySQL数据库的环境搭建【了解】\n\n\n\n### 掌握MySQL数据库的环境搭建及其操作方法\n\n\n\n第一步：安装MySQL数据库的服务端（默认创建服务端以及数据库文件）\n终端指令：sudo apt-get install  mysql-server\n\n\n\n截图：\n\n![image-20211011193105730](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193105730.png)\n\n\n\n\n\n\n\n第二步：安装mysql数据库的客户端（图形化客户端）—— navicat \n\n\n\n1：网上下载 navicat安装包 \n\n2：运行navicat这个包即可\n\n看截图：\n\n![image-20211011193117486](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193117486.png)\n\n\n\n\n\n### 数据库操作指令\n\n\n\n1：启动数据库 sudo service mysql start\n\n2：重启数据库 sudo service mysql restart\n\n3：停止数据库 sudo service mysql stop\n\n4：查看进程中是否存在 mysql服务   ps -ajx | grep mysql\n\n\n\n指令解析：其中 ps 为linux查看所有进程指令 -ajx 为选项 -a 代表显示所有用户进程 -j代表任务格式显示进程 -x代表显示无控制终端进程    | 是管道指令    grep mysql 表示查看mysql的进程\n\n\n\n截图：\n\n![image-20211011193158819](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193158819.png)\n\n\n\n\n\n### mysql数据库配置文件位置\n\n\n\n路径：/etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n\n截图：\n\n![image-20211011193208464](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193208464.png)\n\n\n\n配置属性如下：\n\n![image-20211011193215786](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193215786.png)\n\n\n\n\n\n### linux终端（客户端）连接mysql数据库与退出数据库\n\n\n\n前言：在利用指令 sudo apt-get install  mysql-server  安装mysql数据库服务端时，默认也安装了mysql客户端，我们可以实现在Linux终端连接 mysql 数据库\n\n\n\n连接数据库指令：mysql -u root -p \n\n\n\n\n\n注意事项：\n\n1：再终端利用上述指令连接mysql数据库时，应先利用指令 sudo -s 进入管理员用户 才能连接mysql数据库\n\n2：mysql刚安装时默认密码为空，在后期可以通过指令更改密码\n\n3：linux终端连接数据库成功后，我们在终端输入SQL语句指令就可以控制 mysql 数据库了\n\n\n\n指令解析：-u 代表用户选项 root代表用户名 -p 代表数据库密码选项\n\n\n\n截图：\n\n![image-20211011193244856](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193244856.png)\n\n\n\n退出数据库指令：exit 、 quit 、Ctrl键+D键\n\n\n\n\n\n## MySQL数据库完整性约束【重点】\n\n\n\n### 数据库完整性约束\n\n\n\n概念：数据库完整性约束用于保证数据的正确性，数据库客户端在更新、插入、删除数据时需要检查数据的完整性，核实其约束条件，从而保证更新数据时是正确的。\n\n\n\n关系型数据库（mysql、二维表）完整性约束的分类：实体完整性、域完整性、参照完整性、用户定义完整性\n\n\n\n### 关系型数据库的几类完整性约束\n\n\n\n1：实体完整性约束\n\n\n\n概念：实体完整性要求关系型数据库二维表的一个记录中（一行）只有一个主键，且不同记录的主键值不能重复也不能为空\n\n\n\n图示（主键约束）：\n\n![image-20211011193303887](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193303887.png)\n\n\n\n\n\n2：域完整性约束\n\n\n\n概念：域完整性是指关系型数据库二维表内的一列（字段）的数据类型都是相同的，还有可以约束字段其取值范围、精度等\n\n![image-20211011193316428](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193316428.png)\n\n\n\n\n\n3：参照完整性约束\n\n概念：参照完整性是关系型数据库内的父表删除某一个记录（一行）后，子表内的该记录（一行）也要删除！（父表与子表存在一定联系！）\n\n\n\n\n\n4：用户定义完整性约束\n\n\n\n概念：用户定义完整性是指关系型数据库二维表内的一个字段数据类型需要满足用户规定的类型，比如说，用户规定一个字段数据类型只能是数字，那么就不能向字段内添加其余的数据类型，再比如，用户要求一个字段内数据只能填写 男、女，用户就不能向这个字段内填写其他的数据！！\n\n\n\n\n\n————————————————————————————————————————\n\n\n\n\n\n### not null 、primary key、unique key、default、foreign key 这几个约束分别属于什么类型的约束！\n\n\n\nprimary key：主键约束（要求主键列的数据唯一，且不为空！）它属于实体完整性约束\n\n\n\nunique key：唯一约束（唯一性、可以空，但只能有一个）它属于实体完整性约束\n\n\n\nnot null：非空约束（设置该字段不能为空） 它属于域完整性约束\n\n\n\ndefault：默认约束 （设置该字段数据的默认值）它属于域完整性约束\n\n\n\nforeign key：外键约束（建立两表的关系）它数据参照完整性约束\n\n\n\n\n\n\n\n## 客户端Navicat的使用【理解】\n\n\n\n### navicat 连接 本地mysql数据库的界面\n\n![image-20211011193402647](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193402647.png)\n\n\n\n\n\n连接本地数据库服务器！成功后，本地数据库自带的四个数据库文件！\n\n![image-20211011193409940](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193409940.png)\n\n\n\n### 使用 Navica t创建数据库\n\n![image-20211011193417066](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193417066.png)\n\n\n\n\n\n### 使用 Navicat 在数据库内创建数据二维表\n\n![image-20211011193426124](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193426124.png)\n\n\n\n![image-20211011193434572](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193434572.png)\n\n\n\n![image-20211011193443505](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193443505.png)\n\n![image-20211011193450447](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193450447.png)\n\n\n\n注意事项：在新建的表栏右击选择设计表可重新编辑这个二维表\n\n\n\n\n\n### 使用 Navicat 向数据库内添加数据！\n\n\n\n增加数据\n\n![image-20211011193502928](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193502928.png)\n\n\n\n删除数据\n\n![image-20211011193510093](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193510093.png)\n\n\n\n### Navicat 共享数据库（导出SQL文件）以及导入别人的SQL文件\n\n\n\n导出 SQL 文件\n\n![image-20211011193527692](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193527692.png)\n\n\n\n导入别人的 SQL 文件\n\n![image-20211011193534749](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193534749.png)\n\n\n\n注意事项：\n\n1：需要在建立的数据库栏右击才有运行 SQL 文件\n\n2：导入别人的SQL文件成功后，需要重启数据库才能看到导入的数据表（图示的数据库为 python_database）\n\n\n\n\n\n\n\n## Navicat远程连接服务区数据库【重点】\n\n\n\n目标：掌握怎么在 Windows 系统内的 Navicat 软件上远程连接在Linux服务器上的数据库！\n\n\n\n前言：我们在做web开发时，我们的数据库都是存放在服务器上面（linux系统），而且这个服务器是远程服务器，不在我们身边，这是我们就要学会利用 windows系统远程连接服务器数据库了！\n\n\n\n\n\n### 在 Windows 系统内的 Navicat 软件上远程连接在Linux服务器上的 mysql 数据库！\n\n\n\n准备工作：利用服务器上的 Navicat软件将服务器数据库用户权限更改（更改为可远程连接！）\n\n![image-20211011193556888](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193556888.png)\n\n\n\n\n\n远程登录步骤：\n\n第一步：Windows系统打开Navicat软件\n\n![image-20211011193607264](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193607264.png)\n\n\n\n\n\n第二步：填写数据库信息远程登录\n\n![image-20211011193617724](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193617724.png)\n\n\n\n\n\n## MySQL数据类型【重点】\n\n\n\n你问我答：为什么要有不同的数据库数据类型的分类\n\n\n\n答：MySQL定义数据字段的类型（数据类型）对数据库的优化是非常重要的，MySQL数据库常见三种数据类型为数值（整形、浮点型）、日期/时间、字符串\n\n\n\n\n\n### MySQL数据库三大数据类型【数值（整形与浮点型）、日期、字符串】的分类！\n\n\n\n1.数值——整形数据类型分类：\n\n![image-20211011193630371](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193630371.png)\n\n\n\n应用场景：\n\n\n\n1：存储一个班级学生的年龄选择TINYINT整形类型（因为年龄最大不超过255），这样占用的空间最少还能存储数据\n\n2：存储中国人数选择INT整形类型（因为之前的类型范围不够），INT范围是42亿多呢，够用，用BIGINT的话就浪费资源，没有达到优化数据库的目的\n\n\n\n\n\n注意事项：\n\n1：在存储数据时同一数据类型的不同分类对数据库的优化是非常重要的！\n\n2：最常用的两大整形即 tinyint与int\n\n\n\n数值——浮点型数据类型分类\n\n![image-20211011193655835](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193655835.png)\n\n\n\n注意事项：除了float与double浮点数类型，decimal 类型也可以表示小数，decimal定义的小数更加精确\n\n\n\n![image-20211011193705556](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193705556.png)\n\n\n\n\n\n2.字符串数据类型分类\n\n\n\n数据库字符串类型常见分类：char、varchar、text、enum、set\n\n\n\n定长字符类型——char\n\n\n\n适用场景：存储字符长度固定的字符串，比如说中国邮政编码、手机号、身份证号等\n\n定义形式：字段名称 char（字符个数）\n\n\n\n\n\n特点：\n\n1：最长储存255个字符\n\n2：如果实际写入的字符不足设定长度，内部会自动用空格填充到设定的长度，例如 char（5）存储数据 he（两个字符长度），但是却占用五个字符的空间（补全空格）\n\n3：相对于varchar，读取数据速度更快\n\n\n\n\n\n\n\n\n\n变长字符类型——varchar\n\n\n\n适用场景：存储的字符长度不确定，比如姓名、用户名等\n\n定义形式：字段名称 varchar（字符个数）\n\n特点：\n\n1：最大可存储65535（2的16次方减1）个字节的字符\n\n\n\n注释：\n• 一个英文字符占用一个字节\n\n• UTF-8编码的中文字符占用三个字节\n\n• GBK编码的中文字符占用两个字节\n\n\n\n\n\n2：当存储的字符长度小于设定的长度时，按照实际的长度存储，例如varchar（5）存储he，实际占用三个字符（最后是/0）的空间，这是与char的区别\n\n\n\n3：相较于char，存取数据速度更快\n\t\n注意事项：char最大存储255个字符，varchar最大存储65535个字节\n\n\n\n\n\n长文本类型——text\n\n适用场景：较长文章的存储，最长可存储65535（2的16次方减1）个字符，如果需要更长的字符可选择 mediumtext（1600万左右）或longtext（40亿左右）\n\n定义方式：字段名称 text\n\n\n\n注意事项：\n\n1：长文本类型不能设置默认字符长度\n\n2：text类型的数据不存在行中\n\n3： mediumtext（1600万左右）或longtext（40亿左右）都是字符\n\n4：65535个字符大约 64kb\n\n5：utf-8的编码 text存储的字符数可能减半\n\n\n\n\n\n枚举类型——enum、set\n\n概念：在定义字段时预先规定好几个值，然后插入数据时只能从这几个规定好的值中选择一个\n\n适用场景：字段插入数据时，有固定的几个值，比如性别、星期、月份时可用枚举类型\n\n定义方式：gender enum（“男”，“女”），这样在插入数据时，只能选择男或者女\n\n\n\n注意事项：\n\n1：一个enum最多可存储65535个值\n\n2：利用enum设置的字段最终只占用1或2个字节的空间，比较节省空间\n\n3：枚举类型的enum与set的不同是，enum只能从枚举的数据中选取一个，而set可以从枚举的类型中选取多个！\n\n\n\n\n\n3.日期数据类型分类\n\n\n\n![image-20211011193808869](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193808869.png)\n\n\n\n你问我答：datatime类型与timestamp类型都是定义到年月日时分秒，他俩有啥不同呢？\n\n\n\n答：定义时间的范围不同 datatime定义的范围是1000-01-01 00:00:00/9999-12-31 23:59:59 \n而timestamp定义的范围是1970-01-01 00:00:00 / 2038-1-19 11:14:07\n\n\n\n### 知道选择一种合适的数据库数据类型的好处\n\n\n\n好处1：节省数据库空间\n好处2：增加数据的查询效率\n好处3：优化数据库\n\n\n\n\n\n\n## 登录和退出MySQL数据库及其SQL指令查询数据库版本等【重点】\n\n\n\n\n\n### MySQL数据库的操作步骤\n\n\n\n步骤：终端连接数据库→对数据库进行操作→终端退出数据库\n\n![image-20211011193837280](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193837280.png)\n\n\n\n\n\n### 使用终端命令登录（连接）数据库\n\n\n\n前言：终端（客户端）连接数据库的原理是，终端（客户端）连接数据库服务器，利用服务器管理数据库内的数据\n\n\n\n指令： \n\nmysql -u root -p \n\n回车输入密码即可连接数据库服务器\n\n指令解释：-u 用户选项 root 用户名  -p 密码选项\n\n\n\n\n\n注意事项：\n\n1：必须先切换到管理员用户在输入上面指令才能连接到数据库，否则失败\n\n2：在连接到数据库之后，你就要输入SQL指令才能操作数据库\n\n3：连接到数据库之后，每一行SQL指令都要以分号；结尾\n\n\n\n图示：\n\n![image-20211011193855313](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193855313.png)\n\n![image-20211011193909652](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193909652.png)\n\n\n\n\n\n### 退出数据库\n\n\n\n退出指令：exit 、quit 、Ctrl+D\n\n\n\n\n\n### 数据库的常见 SQL操作指令（查看数据库版本号等）\n\n\n\n常见指令：\n\n1：select version( ) ；查看mysql数据库的版本号\n\n2：select now（）；查看当前时间\n\n\n\n\n\n\n截图：\n\n![image-20211011193929670](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193929670.png)\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Mysql操作"],"categories":["Mysql操作"]},{"title":"多任务编程——协程","url":"/2021/10/11/多任务编程——协程/","content":"\n\n\n\n\n本文主讲：Python中关于协程相关的知识......\n\n\n\n<!--more-->\n\n\n\n\n\n## 可迭代对象及其检测方法\n\n\n\n### 为什么学习可迭代对象（迭代器）\n\n\n\n答：因为学习迭代器是为了学习生成器，学习生成器是为了学习协程！\n\n\n\n\n\n### 什么是可迭代对象\n\n\n\n答：可迭代对象就是可以被for循环遍历的对象，因此可迭代也称为可遍历\n\n\n\n可迭代（遍历）对象举例：列表、元组、字典、字符串、range（）\n\n\n\n不可迭代对象举例：自定义类对象（不包括内含迭代器的类对象）、函数、整数（int）\n\n\n\n注意事项：遍历字典默认遍历的字典的key值\n\n\n\n可迭代判断截图：\n\n![image-20211011172657007](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172657007.png)\n\n\n\n\n\n### 判断对象是否可迭代的方法\n\n\n\n方法：isinstance（判断对象，Iterable）\n\n判断实例：bool = isinstance（判断对象，Iterable）\n\n\n\n注意事项：\n\n1：在利用 isinstance（判断对象，Iterable）方法判断对象是否可迭代时，要先导入collections模块内的 Iterable类！！，即 from collections import Iterable语句 ，否则程序报错\n\n2：Iterable是一个可迭代对象类，isinstance（）判断方法就是判断目标对象是否为Iterable类的一个子类\n\n3：判断对象是可迭代对象返回 True，不是返回 False\n\n4：默认的自定义类对象是不可迭代的，但是如果类中含有__iter__( ) 方法，那么这个类创建的对象就是可迭代的，其中__iter__( ) 方法也称为迭代器\n\n\n\n快速代码体验\n\n![image-20211011172714995](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172714995.png)\n\n\n\n### 初识迭代器 （__iter__( )魔法方法）\n\n\n\n概念：类默认是不可迭代对象，但是在类中如果含有__iter__( ) 这个方法，那么这个类创建的对象就是可迭代对象，__iter__( ) 魔法方法就是迭代器\n\n可迭代对象的本质：创建对象的所属类中含有迭代器（__iter__( )），可向外提供一个迭代器\n\n注意事项：默认类是不可迭代的，如果一个类创建的对象判定为可迭代，那么这个对象所属的类中一定含有__iter__方法\n\n\n\n快速代码体验：\n\n![image-20211011172803597](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172803597.png)\n\n\n\n\n\n\n\n## 迭代器及其使用方法\n\n\n\n课前回顾：默认类创建的对象是不可迭代的，如果一个类创建的对象判定为可迭代，那么这个对象所属的类中一定含有__iter__方法（迭代器）\n\n\n\n### 什么是迭代器？\n\n\n\n概念：用 for 循环遍历可迭代对象过程中，要有一个“人”来记录遍历访问第几个数据了，并且返回数据，以便于下一次遍历时返回的是下一个数据，这是把帮助我们记录遍历第几个数据的“人”称为迭代器（iterable）\n\n\n\n注意事项：\n\n1：类创建的可迭代对象通过__iter__方法向我们提供了一个迭代器，我们在遍历一个可迭代对象时，其实是先获取可迭代对象提供的的迭代器，然后再通过这个迭代器依次获取对象中的每一个数据！\n\n\n\n2：比如说列表是一个可迭代对象，那么列表会向外提供一个迭代器，这个迭代器会获取列表内每个数据用于遍历\n\n\n\n3：只要是可迭代对象，都可以获取这个对象的迭代器\n\n\n\n\n迭代器特点：\n\n1：记录遍历的位置\n2：提供下一个元素的值（配合next（迭代器）函数使用）\n\n\n\n\n\n### 循环遍历可迭代对象依次获取数据的原理\n\n\n\n列表（可迭代对象）→iter（）函数获取迭代器→next（迭代器）函数依次获取迭代器内的数据！（执行几次next函数，获得几个可迭代对象数据）→捕获异常\n\n\n\n### 获取可迭代对象的迭代器函数——iter（）\n\n\n\n功能：获取可迭代对象的迭代器\n\n语法：`iteratro_obj = iter（可迭代对象）`\n快速代码体验\n\n![image-20211011172840216](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172840216.png)\n\n\n\n\n\n### next（）函数\n\n\n\n功能：获取迭代器中的下一个元素的数据\n\n语法：`print（next（迭代器对象））`\n\n\n\n注意事项：\n\n1：调用了几次next（迭代器对象）函数，就打印几次迭代器内的数据\n\n2：如果调用next（）函数的次数大于迭代器内的数据数量，程序报错\n\n\n\n快速代码体验：\n\n![image-20211011172920020](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172920020.png)\n\n\n\n\n\n### for循环遍历可迭代对象的底层原理\n\n\n\n第一步：iter（可迭代对象）方法获取可迭代对象的迭代器    即调用可迭代对象类内的__iter__( )方法，__iter__( )方法返回的是一个迭代器类创建的迭代器\n\n\n\n第二步：利用next（迭代器）方法依次获取数据，即多次调用迭代器类里面的__next__( )函数获取数据，直到数据全部获取成功结束迭代\n\n\n\n第三步：捕获异常，如果next（）函数调用次数大于迭代器内的数据数，程序报错，捕获这个异常防止程序报错\n\n\n\n快速代码体验（异常截图）：\n\n![image-20211011173000787](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173000787.png)\n\n\n\nfor循环底层原理截图：\n\n![image-20211011173007032](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173007032.png)\n\n\n\n### 自定义迭代器类\n\n\n\n自定义迭代器类注意事项：\n\n1：类里面必须含有__iter( )__方法\n\n2：类里面必须含有 __next__( )方法\n\n\n\n快速代码体验\n\n![image-20211011173018655](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173018655.png)\n\n\n\n\n\n\n## 自定义迭代对象、迭代器【重点、难点】\n\n\n\n### 自定义一个可迭代对象类（列表）\n\n\n\n构造必要条件：一个类默认是不可以迭代的，要想让一个类可迭代，类里面必须有 __iter__ 方法（提供迭代器），其中提供的迭代器是另外定义的一个类，迭代器类里面必须包含__iter__ ( ）方法与__next__（）方法，而且自定义一个列表类，类里面还要有增加数据以及其他的基本方法，还有最起码的 __init__构造方法\n\n\n\n自定义可迭代对象类(列表)条件清单：\n\n1：两个类（自定义列表类与自定义迭代器类）\n\n2：列表类里面的__iter__ ( ）、__init__()、基本数据构造等方法\n\n3：迭代器类里面的__iter__ ( ）、__next__( )、__init__( )方法\n\n\n\n\n\n注意事项：\n\n1：自定义迭代器类是为自定义列表类的__iter__( )方法提供一个迭代器\n\n\n\n条件截图：\n\n![image-20211011173038555](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173038555.png)\n\n\n\n自定义列表类代码截图（三段代码组成一段程序）\n\n\n\n![image-20211011173109740](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173109740.png)\n\n![image-20211011173118610](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173118610.png)\n\n![image-20211011173125582](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173125582.png)\n\n\n\n\n\n### 自定义可迭代对象的方法步骤\n\n\n\n第一步：自定义可迭代对象类，内含__init__( )、 __iter__( )、  其他基本功能方法如添加数据等方法\n\n\n\n第二步：自定义一个迭代器类，用来给自定义可迭代对象类提供一个迭代器，内含__init__( )、 __iter__( )、__next__( ) 方法\n\n\n\n第三步：自定义可迭代对象类的__init( )方法要初始化一个容器保存数据，可以是列表、元组等\n\n\n\n第四步：创建的可迭代对象类中的__iter__( )方法要返回创建的迭代类实例化的迭代器\n\n\n\n第五步：创建的迭代器类里面的__next__( )方法要返回数据容器存放的数据！每调用一次返回一个数\n据\n\n\n\n第六步：创建的迭代器类里面的__next__( )方法要进行抛出异常即在遍历完成时结束迭代\n\n\n\n\n\n\n\n## 常见问题【重点、重点】\n\n\n\n目标：知道 a = b  b = a + b 与   a ，b = b , a + b 的区别【重点】斐波那契数列必须知道这两个的区别才能书写代码\n\n\n\n### 代码区别\n\n\n\na = b  \nb = a + b\n上面代码先将 b 的值赋值给 a 在计算 b 的数值\n\n\n\n————————————————————————————————————\n\n\n\na ，b = b , a + b\n\n上面代码是先计算等号右面的数值，即 b 与 a + b 的数值，在赋值给等号左面类似于下面的代码\n\n\n\ntemp = b\nb = a + b\na = temp\n\n\n\n代码演示\n\n![image-20211011173228774](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173228774.png)\n\n\n\n\n\n## 迭代器应用——斐波那契数列【重点】\n\n\n\n\n\n### 什么是斐波那契数列？\n\n![image-20211011173257483](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173257483.png)\n\n\n\n斐波那契数列实现原理：\n\n![image-20211011173306874](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173306874.png)\n\n\n\n\n\n### 创建一个迭代器类实现输出打印斐波那契数列\n\n\n\n创建迭代器类满足条件：__init__( )、  __iter__( )、  __next__( )、三个函数\n\n\n\n注意事项：\n\n1：迭代器类本身就是一个迭代器，因此迭代器类创建的实例可以被for循环遍历\n\n2：想要迭代器类创建的对象可以被for循环遍历，那么迭代器类里面的__iter__( )方法就要返回迭代器本身，即return self\n\n\n\n斐波那契数列代码实现：\n\n![image-20211011173407453](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173407453.png)\n\n![image-20211011173416687](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173416687.png)\n\n\n\n### 掌握斐波那契数列底层代码不能书写的样式\n\n\n\n答：底层重要代码不能这么写 a = b  b = a + b\n\n\n\n\n\n\n\n## 生成器——基本使用\n\n\n\n### 什么是生成器（generator）？\n\n\n\n概念：生成器是一种特殊的迭代器（按照一定规律生成数列），是一种更加简洁的迭代器，生成器可以理解为可暂停的函数！\n\n\n\n创建生成器两种方式：\n\n1：根据列表推导式演变创建生成器 → generator_obj = （ i for i in range(10) ）\n\n2：函数中使用了 yield 关键字\n\n\n\n注意事项：\n\n1：生成器是特殊迭代器，因此生成器也可以用next（生成器）来获取数据\n\n2：生成器也可以被遍历\n\n\n\n快速代码体验（推导式创建生成器）\n\n![image-20211011173500784](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173500784.png)\n\n\n\n函数中使用 yield 创建生成器（函数为一个生成器）\n\n![image-20211011173507678](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173507678.png)\n\n\n\n\n\n\n## 生成器案例——斐波那契数列【重点】\n\n\n\n### 利用函数内的 yield 关键字创建斐波那契数列生成器\n\n\n\n注意事项：调用一次next（生成器对象）函数，就会执行一次生成器函数到 yield 关键字处返回数据且暂停程序，直到下一次调用next（生成器对象）函数或者send（）函数才可以再次唤醒生成器程序函数继续执行！\n\n\n\n代码截图\n\n![image-20211011173537699](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173537699.png)\n\n\n\n### 生成器函数内 yield 关键字功能\n\n\n\n功能1：返回数据\n\n功能2：暂停函数，不是退出函数，是暂停函数，这也是yield与return的区别！直到下一次调用next（）函数时程序继续执行\n也可以理解为遇到yield关键字记录位置退出函数，下一次调用next（）函数从记录的位置继续执行代码！\n\n![image-20211011173547455](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173547455.png)\n\n\n\n\n\n\n\n\n## 生成器使用注意事项【send、return】\n\n\n\n### 函数生成器中 return 的作用\n\n\n\n功能：退出生成器函数，不在继续生成数据，当继续执行 next（）函数时报错，报错内容就是 return 返回的数据内容，对此我们可以对下面执行的 next（）进行异常捕获\n\n\n\n注意事项：生成器内的 return 一般要配合 if 条件使用，在满足规定条件后才执行return语句，退出生成器函数\n\n\n\n快速代码体验\n\n![image-20211011173604573](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173604573.png)\n\n\n\n\n\n### send 方法启动生成器并且传递参数\n\n\n\nsend（参数）功能：可以唤醒暂停的生成器程序（生成器内部遇见 yield 关键字就会暂停，直到继续调用next（）或send（）函数），并且向生成器内传递参数即 参数 = yieid result\n\n\n\n使用语法：生成器对象.send（参数）\n\n\n\n快速代码体验\n\n![image-20211011173816824](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173816824.png)\n\n\n\n\n\n\n\n## 协程——基本使用（yield实现协程）\n\n\n\n### 什么是协程\n\n\n\n概念：协程可以理解为一种特殊的生成器，在不开辟其他子线程的情况下（只有主线程）可以实现多任务，并且协程有暂停函数的功能，且协程也称为微线程或者纤程\n\n\n\n协程适用场景：在程序中存在大量不需要 cpu 的操作时，如I/O操作\n\n\n\n线程与协程的差异：在实现多任务时，线程的切换非常耗性能，协程切换没有线程那么耗能\n\n\n\n图示：\n\n![image-20211011173908875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173908875.png)\n\n\n\n\n\n### 函数使用yield关键字可以实现协程\n\n\n\n实现步骤：\n\n1：创建两个生成器函数（内涵yield）\n\n2：获取这两个生成器\n\n3：value = next（生成器）来获取生成器返回的值\n\n\n\n代码演示：\n\n![image-20211011173921881](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173921881.png)\n\n\n\n\n\n## greenlet 实现协程\n\n\n\n### 什么是 greenlet ？\n\n\n\n答：greenlet 是 python 的一个 c 扩展，旨在提供一个可自行调度的 “微线程”（协程）方法\n\n安装 greenlet 第三方库指令：pip3 install greenlet\n\n\n\n### 怎么用 greenlet 实现协程多任务(步骤)\n\n\n\n第一步：导入 greenlet 模块   from greenlet import greenlet（导入greenlet模块里面的greenlet类）\n\n\n\n第二步：创建任务函数（不含yield 必须含有任务切换方法 switch（））\n\n\n\n第三步：创建协程 greenlet 对象，几个任务函数创建几个协程对象，并为协程对象指定函数任务（函数无括号）  即  协程对象 = greenlet（函数任务）\n\n\n\n第四步：手动选择协程先执行哪个任务函数 即 协程对象.switch（）\n\n\n\n\n\n注意事项：\n\n1：创建的任务函数一定要包含 switch（） 切换任务函数\n\n2：greenlet实现协程在只有主线程情况下进行多任务\n\n\n\n快速代码体验：\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173941458.png)\n\n\n\n\n\n\n## gevent 实现协程【重中之重】\n\n\n\n### 什么是 gevent\n\n\n\n答：上一集我们用 greenlet 实现了协程多任务，但是多任务却要我们手动切换任务函数，不要捉急 python 有一个更为强大的第三方库 gevent 它可以实现自动切换任务函数\n\n\n\ngevent 第三方库可以自动检测代码中哪些是耗时操作，遇到耗时较长的代码就会立刻切换到另一个任务去执行，然后在一个合适的时间返回执行刚开始的函数\n\n\n\n### gevent 怎么使用及实现协程多任务\n\n\n\ngevent实现多任务步骤：\n\n\n\n1：导入模块 import gevent\n\t\t\t\t\t\n2：创建任务函数，任务函数内含耗时操作（gevent.sleep（0.5））\n\t\t\t\t\t\n3：为 gevent 指派任务 并且返回一个 gevent 对象 即 对象 =  gvenv.spawn（任务函数，参数1，参数2，…….），注意有几个任务就指派几次任务返回几个对象，先指派的哪个任务就先执行哪个任务函数\n\t\t\t\t\t\n4：让主线程等待协程执行结束后在结束，即  gevent对象.join（）\n\n\n\n注意事项：\n\n1：在任务函数中耗时操作为什么不能使用 time.sleep（0.5）只能使用 gevent.sleep（0.5），因为gevent只能识别自己的gevent.sleep（0.5）是耗时操作，不能识别time.sleep（0.5）是耗时操作，但是它们两个的效果是一样的\n\t\t\n2：第四步的join（）必须书写，否则在协程没有执行结束，主线程就结束了并且释放数据和内存，不能输出任何数据\n\t\t\n3：耗时操作包括 I/O操作，比如文件的读取写入\n\n\n\n快速代码体验：\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174348804.png)\n\n\n\n\n\n### 给一个 gevent 不能识别为耗时操作的代码（time.sleep（0.5）），转变成可以识别为耗时代码操作（打补丁）\n\n\n\n什么是打补丁：打补丁就是在不修改程序源代码的情况下为程序增加新的功能\n\n给 gevent 打补丁：在不改变 gevent 原始代码的情况下，为 gevent 增加新的功能\n\n\n\n\n利用打补丁操作将 gevent 不能识别为耗时操作的代码（time.sleep（0.5））识别为耗时操作步骤：\n\n第一步：导入模块   from gevent import monkey\n\n\n\n第二步：破解所有即可  monkey.patch_all( )  这样就可以识别 time.sleep（0.5）代码为耗时操作了\n\n\n\n\n\n注意事项：上面的这两行代码一般都写在一个程序的最上方！\n\n\n\n快速代码体验：\n\n![image-20211011174538875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174538875.png)\n\n\n\n\n\n猴子补丁功能：\n1：在不修改第三方源代码的情况下增加原来不支持的功能\n2：在运行时为内存中的对象增加补丁，而不是在磁盘的源代码中增加补丁\n\n\n\n\n\n\n\n\n## 线程、进程、协程区别【重点】\n\n\n\n### 进程、线程、协程\n\n\n\n![image-20211011174623986](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174623986.png)\n\n\n\n\n\n### 进程、线程、协程关系\n\n![image-20211011174631826](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174631826.png)\n\n\n\n### 线程、进程、协程应用场景\n\n\n\n多进程：密集 cpu 任务，需要充分使用多核cpu资源\n缺点：多个进程间通信成本高、切换开销大\n\n\n\n多线程：密集 I/O任务（网络I/O，磁盘I/O，数据库I/O） 网络I/O即联网下载上传文件\n缺点：同一个时间切片只能运行一个线程，不能做到高并行，能做到高并发\n\n\n\n多协程：不需要大量 cup 操作时，应用于网络 I/O 下载时\n缺点：单线程执行，处理大量cpu操作以及磁盘I/O操作时性能较低，但是处理网络I/O性能比较高\n\n\n\n注意事项：性能最高的组合即进程+协程，进程可调度多个cpu\n\n\n\n\n\n\n\n## 案例：并发下载器\n\n\n\n### urllib.request 第三方库的 urlopen（url） 方法\n\n\n\n功能：打开指定 url 的网站并且返回一个类文件，这个类文件支持一般文件的操作比如说read（）、readlin（）等\n\n\n\n注意事项：类文件对象 = urllib.reques.urlopen（url）返回一个类文件，但是要对这个类文件执行read（）方法才能读取到其中的数据从而实现保存文件的结果\n\n具体功能详解：https://www.cnblogs.com/langdashu/p/4963053.html\n\n\n\n\n\n使用步骤：\n\n\n\n第一步：导入模块 import urllib.request\n\n第二步：返回类文件对象，类文件对象 = urllib.reques.urlopen（url）\n\n第三步：对这个类文件对象进行操作（读取这个文件数据） 即：类文件对象.read（）等操作\n\n\n\n图示：\n\n![image-20211011174757294](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174757294.png)\n\n\n\n\n\n### 给所有的 gevent 协程任务 join（）的方法 gevent.joinall（）\n\n\n\n功能：给所有指定任务的协程进行 join（）\n\n语法：gevent.joinall（[协程任务1，协程任务2，协程任务3]）\n\n图示：\n\n![image-20211011174805756](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174805756.png)\n\n\n\n\n\n### 协程并发下载多种图片\n\n\n\n原理图示：\n\n![image-20211011175004393](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011175004393.png)\n\n\n\n\n\n实现并发下载器的步骤：\n\n\n\n第一步：导入猴子补丁模块并且破解所有 即 from gevent import monkey        monkey.patch（）\n\n第二步：导入urllib.request 与 gevent 模块\n\n第三步：定义down_load（）函数用于下载内容\n\n1：获取图片的类文件\n2：打开本地文件写入图片的二进制文件\n3...\n\n\n\n\n\n第四步：定义 main（）函数保存下载内容的 url 网站 并且调用 down_load( )函数对文件进行下载\n\n第五步：对 down_load（ ）函数进行异常捕获\n\n\n\n代码演示：\n\n\n\n![image-20211011175102556](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011175102556.png)\n\n\n\n\n\n## 案例：web协程服务器\n\n\n\n略......\n\n\n\n未完待续....\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["多任务编程"],"categories":["多任务编程"]},{"title":"多任务编程——多进程","url":"/2021/10/11/多任务编程——多进程/","content":"\n\n\n本文主讲：Python中有关于多进程相关的知识.....\n\n\n\n<!--more-->\n\n\n\n\n\n## 进程以及状态【重点】\n\n\n\n### 一：什么是进程？\n\n\n\n概念：进程（Process）是系统资源分配的基本单位，也是线程的容器，即线程是轻量级的进程，一个进程包含多个线程\n\n\n\n程序与进程的区别：\n\n\n\n程序：例如xxxx.py就是程序，是静态的\n\n进程：进程是程序运行起来后，程序代码+用到的资源，它是动态的，是操作系统分配资源的基本单位，即操作系统先将资源分配给进程，进程在分配给其他线程等\n\n\n\n注意事项：如果没有进程线程是不能独立运行的\n\n\n\n截图说明\n\n![image-20211011165051015](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165051015.png)\n\n\n\n\n\n\n\n### 进程的几种状态\n\n\n\n读前须知：cpu处理多任务的方式为时间片轮询！\n\n\n\n新建状态：cpu在处理一个任务时，另一个新的任务加入进来，加入的任务为进程新建状态，或者任务没有获取到资源的状态\n\n\n\n就绪状态：两种可能是就绪状态，第一种刚加入的任务获取到资源进入就绪状态，等待运行，第二种是任务刚从运行状态结束等待下一次运行为就绪状态\n\n\n\n运行状态：cpu通过时间片轮询方式轮询到这个任务时为运行状态\n\n\n\n等待状态：在cpu处理一个任务时，这个任务意外关闭（time.sleep（2））（阻塞），则这个任务进入等待状态，满足条件后进入就绪状态\n\n\n\n死亡状态：一个任务运行结束后，没有其他的任务即机死亡状态\n\n\n\n\n\n流程演示：\n\n![image-20211011165111519](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165111519.png)\n\n\n\n\n\n流程图解：\n\n![image-20211011165117851](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165117851.png)\n\n\n\n\n\n\n\n## 进程——基本使用【重点】\n\n\n\n### 创建子进程\n\n\n\n语法：\n\n1：导入模块 import multiprocessing\n2：创建进程对象 process_obj = multiprocessing.Process（target = 函数任务名无括号）\n3：启动进程 process_obj . start( )\n\n\n\n创建的子进程对象的参数作用：\n\ntarget：为子进程传递任务函数\n\nargs：给任务函数传参（元组形式）\n\nkwargs：给认为函数传参（字典形式）\n\nname：为创建的子进程命名，也可以不命名\n\ngroup：为创建的子进程指定组，大多数用不到\n\n\n\n\n\nProcess类创建的子进程方法及功能：\n\n\n\n创建的子进程对象.start（）：启动子进程\n\n创建的子进程对象.is_alive（）：判断子进程是否还活着\n\n创建的子进程对象.join（）：是否等待其他子进程执行完毕再执行\n\n创建的子进程对象.terminate（）：不管任务是否完成立刻结束子进程\n\nProcess类创建的子进程属性：pid：当前进程的pid号（进程号）\n\n\n\n\n\n注意事项：\n\n1：进程与线程是受操作系统调配的，因此不同的操作系统执行的结果可能会不同\n\n2：程序启动会建立一个主进程，主进程内又包含了主线程，因此一个程序启动就会建立一个主线程\n\n3：target方法指定的函数任务没有括号！\n\n4：创建子进程的方法和创建子线程的方法类似\n\n\n\n快速代码体验\n\n![image-20211011165152621](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165152621.png)\n\n\n\n\n截图感悟：从代码打印结果上来看，主线程和子进程是同时运行的！\n\n\n\n\n\n\n\n## 进程——获取名称、PID号、PPID号【重点】\n\n\n\n### 获取当前进程名称——multiprocessing.current_process( )\n\n\n\n功能：获取当前运行的进程名称（可以是主进程也可以是子进程）\n\n语法：`print（multiprocessing.current_process( )）`\n\n\n\n注意事项：获取进程名称是主进程还是子进程要看代码书写的位置\n\n\n\n快速代码体验\n\n![image-20211011165215259](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165215259.png)\n\n\n\n\n\n### 获取进程id的几种方法\n\n\n\n你问我答：什么是进程id？为什么要获取进程id？\n\n\n\n答：进程id就是进程的编号，获取进程id是为了在终端输入特定指令（kill -9）杀死该进程\n\n\n\n\n\n方法一：multiprocess.current_process( ).pid 即可获取当前线程的id号，pid是 process id 的缩写，是进程id的意思\n\n快速代码体验\n\n![image-20211011165244981](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165244981.png)\n\n\n\n\n\n方法二：os 模块下的 getpid（）方法获取进程的编号（id）即 os . getpid（）\n\n\n\n注意事项：os . getpid（）写在什么位置就获取的是什么位置的进程id号\n\n快速代码体验\n\n![image-20211011165258464](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165258464.png)\n\n\n\n\n\n### 获取进程 父id 的方法\n\n\n\n你问我答：什么是进程的 父id\n\n答：进程的 父id 就是创建这个进程的那个进程的id号就是父id\n\n\n\n进程父id获取方法：os 模块下的 getppid（）方法 ，即 os . getppid（ ）\n\n注意事项：os . getppid（）写在什么位置就获取的是什么位置的进程父id号\n\n快速代码体验\n\n\n\n![image-20211011165414564](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165414564.png)\n\n\n\n\n\n## 进程——终端指令杀死进程【重点】\n\n\n\n目标：掌握在终端输入指令 kill -9 进程编号 作用\n\n​\t\n\n### 终端输入指令 kill -9 进程编号 以及 kill -15 进程编号 的作用\n\n\n\nKill -9 进程id：在终端输入这个指令，不管这个进程id的进程是否结束，直接杀死该进程（结束掉）\n\n\n\n注意事项：\n1：如果用 kill -9 指令杀死的是主进程，那么其余的子进程也随之结束\n2：如果用 kill -9 指令杀死的是子进程，那么主进程不受影响，继续执行，直到结束！\n\n\n\n快速代码体验\n\n![image-20211011165432815](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165432815.png)\n\n\n\n\n\n\n\n\n## 进程——参数、全局变量【重点】\n\n\n\n### 验证子进程之间不能共享一个全局变量\n\n\n\n验证思想：定义一个函数work1，对一个全局变量进行累加处理，在定义一个work2函数读取这个全局变量，再定义两个子进程，两个子进程分别执行这两个函数任务，如果执行读取全局变量的进程可以成功读取到另一个进程修改后的全局变量，那么说明多个进程间可以共享全局变量，如果执行读取全局变量的进程读取到的全局变量是没有修改的全局变量，说明多个进程之间不可以共享全局变量！！！\n\n\n\n为什么子进程间不能共享全局变量？\n\n答：因为子进程只是把全局变量的值都复制到自己内部然后独立修改，不会修改全局变量的值，因此多个子进程间互不影响\n\n\n\n子进程间不能共享全局变量的例子：计算机打开微信（子进程1）与浏览器（子进程2）如果子进程间可以共享全局变量的话，那么在微信上的聊天记录不就被浏览器获取了嘛！\n\n\n\n程序设计截图\n\n![image-20211011165448042](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165448042.png)\n\n\n\n### 子进程访问（修改、读取）全局变量的底层原理\n\n\n\n原理图示：\n\n![image-20211011165457888](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165457888.png)\n\n**注意事项：子进程访问（修改）全局变量时并不会真正改变全局变量的值，而是将全局变量的值复制下来供自己使用，并不会真正的改变全局变量的值！**\n\n \n\n### 给子进程指定的任务函数传递参数\n\n \n\n传递方法：\n\n1：args（元组法）\n\n2：kwargs（字典法）\n\n3：args、kwargs（元组字典法）\n\n \n\n快速代码体验\n\n![image-20211011165524119](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165524119.png)\n\n\n\n\n\n## 进程——设置守护主线程【重点】\n\n\n\n### 设置子进程守护主线程\n\n\n\n功能：将子进程设置为守护主进程，即主进程结束，子进程也随之结束\n\n实现代码：子进程对象 . daemon = True\n\n注意事项：设置子进程守护主进程要在子进程开始运行（start（））之前设置\n\n快速代码体验\n\n![image-20211011165541588](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165541588.png)\n\n\n\n\n\n## 进程——强制杀死子进程【重点】\n\n\n\n### 强制杀死子进程\n\n\n\n功能：不管子进程是否结束，强制杀死子进程\n\n语法：创建的子进程对象 . terminate（）\n\n\n\n注意事项：强制杀死子进程与设置子进程守护主进程不一样\n\n\n\n快速代码体验\n\n![image-20211011165618187](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165618187.png)\n\n\n\n\n\n\n## 多进程与多线程的区别【面试】【重中之重】\n\n\n\n### 掌握进程与线程之间的区别\n\n\n\n进程：可以完成多任务，一个进程就相当于计算机中一个应用程序，多进程就相当于在计算机中打开多个qq应用程序\n\n\n\n线程：可以完成多任务，一个线程就相当于计算机中一个应用中的一个功能窗口，多线程相当于一个qq应用程序打开多个聊天窗口\n\n\n\n实例截图\n\n![image-20211011165634999](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165634999.png)\n\n\n\n\n\n使用区别：\n\n\n\n1：进程是系统进行资源分配的进本单元，线程是cpu调度和分派的基本单位，进程包括线程\n\n2：线程占用内存资源比进程少（划分尺度小），这使的多线程程序有高并发行\n\n3：多个进程运行时，每个进程都拥有独立的内存资源（多进程间不能共享全局变量），而多个线程运行时，共享一个内存（因此多线程间可共享全局变量），因此多进程相对于多线程更稳定\n\n\n\n图解：\n\n![image-20211011165700391](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165700391.png)\n\n\n\n\n\n进程与线程对比图示\n\n![image-20211011165708935](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165708935.png)\n\n\n\n注意事项：\n\n1：一个程序至少有一个进程（主进程），一个进程至少有一个线程（主线程）\n\n2：线程不能单独运行，必须依赖进程中运行（进程提供线程运行的资源），比如必须开启qq（进程）才能聊天（线程）\n\n\n\n\n\n### 实际处理问题时进程与线程的优先选择：\n\n\n\n1：需要频繁的创建销毁，优先选择线程，因为进程占用资源多，创建销毁慢，例如WEB服务器\n\n2：线程切换速度快，在需要大量计算，频繁切换时，使用线程，例如算法、图像处理\n\n3：多机分布用进程、多核分布用线程\n\n4：需要运行稳定优先用进程，想要运行速度快优先用线程\n\n5：cpu密集型（频繁操作），优先使用进程，因为现在python的解释器cpython存在GIL（全局解释器锁）创建互斥锁，会造成线程处理问题时，多核cpu处理问题变为单核cpu，进程不会出现这种现象\n\n6：i/o密集型可以使用线程\n\n\n\n注意事项：\n\n1：在以后实际处理问题时，要用进程+线程+协程的思想，不要选入非此即彼的思想中，灵活运用\n\n\n\n\n\n\n\n\n## 消息队列——基本操作【重点】\n\n\n\n### 为什么要学习消息队列？什么是队列？\n\n\n\n答：进程之间是不可以进行共享全局变量的，但是我们可以创建一个消息队列，用来传递进程间的数据，从而间接进行数据共享，消息队列相当于两个进程间的对接人，媒婆，进程靠着消息队列传递消息\n\n\n\n什么是队列：队列是一种线性数据结构类型，队列存放数据在队尾存放，而取数据在队首取走\n\n\n\n图示\n\n![image-20211011165746751](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165746751.png)\n\n\n\npython中怎么创建消息队列：multiprocessing模块中的Queue（num）类可创建消息队列\n\n\n\n例如：queue1 = multiprocessing.Queue(3)  代表创建一个长度为3的队列\n\n\n\n\n\n\n### Queue（队列）的 put（）以及 put_nowait( ) 与 get（）和 get_nowait( ) 的基本作用\n\n\n\n功能：\n\nput（“3”）: 向队列中存放“3”数据（从队尾存入）,如果队列数据已满，那么会等待队列释放后再存入，程序处于阻塞状态\n\t\t\nput_nowait( \"3\"): 向队列中存放“3”数据，如果队列已满，程序不会进入阻塞状态，直接报错\n\t\t\nget（）：在队列中取出数据（从队首取出），执行一次在队列中取走一个数据！如果队列已空，程序进入阻塞状态，等待数据存入队列中在取出\n\t\t\nget_nowait( ) :在队列中取出数据（从队首取出），执行一次在队列中取走一个数据！如果队列已空，程序不会进入阻塞状态，直接报错\n\t\t\n\n快速代码体验（put方法）\n\n![image-20211011165804154](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165804154.png)\n\n\n\n\n\nput_nowait（）方法\n\n![image-20211011165810714](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165810714.png)\n\n\n\nget（）方法\n\n![image-20211011165817853](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165817853.png)\n\n\n\nget_nowait( )方法\n\n![image-20211011165823789](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165823789.png)\n\n\n\n\n\n## 消息队列—常见判断【重点】\n\n\n\n### 队列中 full（）方法与 empty（）方法的作用\n\n\n\n消息队列的full（）方法：判断消息队列是否为满，如果消息队列已满返回True，反之False\n\n实例：bool = queue.full（） 判断queue这个消息队列是否已满，并且返回值\n\n\n\n快速代码体验\n\n![image-20211011165837547](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165837547.png)\n\n\n\n\n\n消息队列的empty（）方法：判断消息队列是否为空，为空返回True，反之False\n\n实例：bool = queue.empty（）  判断queue这个队列是否为空，并且返回值\n\n\n\n快速代码体验\n\n![image-20211011165851708](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165851708.png)\n\n\n\n\n\n### 消息队列中qsize（）方法的作用\n\n\n\n功能：返回消息队列中尚存的数据个数，注意是尚存，不是消息队列的长度！\n\n语法：num = 消息队列对象 . qsize（）\n\n\n\n快速代码体验\n\n![image-20211011165909972](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165909972.png)\n\n\n\n\n\n\n## 消息队列——判断是否为空的坑【重点】\n\n\n\n### 判断消息队列是否为空的坑！！\n\n\n\n你问我答：是什么坑？\n\n答：当消息队列被数据项填满，用empty（）判断消息队列是否为空时，返回值为True，说明消息队列已空，这就是坑\n\n\n\n\n\n二：出现这种坑的原因\n\n\n\n答：可以理解为向队列中存数据为子进程1控制，判断队列是否为空是子进程2控制，但是子进程2的运行速度快过于子进程1，造成了数据还没有存入队列，就进行了判断，因此出现了队列中明明有数据却判断为空的原因\n\n\n\n原理截图：\n\n![image-20211011165946447](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165946447.png)\n\n\n\n代码图示（坑）\n\n![image-20211011165953349](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165953349.png)\n\n\n\n解决这个坑的方法代码截图\n\n![image-20211011165959275](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165959275.png)\n\n\n\n\n\n## Queue实现进程间的通信【重点】\n\n\n\n### 消息队列可以实现进程间的通信与通信原理\n\n\n\n通信原理：Queue（消息队列）相当于一个中介，它可以存储进程1的数据，从而让进程2取出，这样就实现了进程间数据的传递\n\n\n\n原理模型截图：\n\n![image-20211011170016420](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170016420.png)\n\n\n\n代码截图：\n\n![image-20211011170023558](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170023558.png)\n\n\n\n\n\n\n## 进程——进程池【重点】\n\n\n\n### 什么是进程池？\n\n\n\n进程池概念：当创建大量进程的时候，multiprocess的Process（）方法就太过麻烦，我们需要采用multiprocess内的Pool（）来创建进程池，用来保存大量进程，即进程池是进程的容器，我们可以用它创建指定数量的进程\n\n\n\n进程序功能：管理与维护进程池\n\n\n\n创建进程池语法：pool_obj = multiprocess.Pool( 3 ) 表示最大创建一个内含三个进程的进程池\n\n\n\n注意事项：multiprocess.Pool( 3 )表示最大可以创建三个进程，在只有一个任务的时候，只需创建一个进程完成任务即可\n\n\n\n不需要把三个进程都创建出来完成任务\n\n\n\n图示：\n\n![image-20211011170039772](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170039772.png)\n\n\n\n\n\n进程池工作方式（同步与异步）：\n\n\n\n同步工作方式\n\n\n\n概念：进程池内的进程执行函数任务时，同一时间只允许一个进程工作\n函数方法：进程池对象 . apply（函数任务，（函数参数1，参数2…….））：以同步的方式执行任务\n注意事项：同步的方法给任务函数传递参数只有以元组的方式进行传递\n\n\n\n图示：\n\n![image-20211011170055846](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170055846.png)\n\n\n\n快速代码体验\n\n![image-20211011170103268](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170103268.png)\n\n\n\n\n\n异步工作方式：\n\n概念：进程池内的进程同一时间可以一起工作\n\n函数方法：进程池对象 . apply_async(函数参数1，参数2….) \n\n\n\n注意事项：\n\n1：异步的方法给任务函数传递参数只有以元组的方式进行传递\n\n2：在使用进程池异步工作方式时，一定要将添加完任务的线程池执行close（）操作，表示不再接受新的任务，否则的话会造成进程池不运行！\n\n3：采用进程池异步工作方式，主进程将不再等待进程池执行结束后退出！！为了避免数据在主进程退出时销毁，要对进程池采用 join（）方法！\n\n\n\n图示：\n\n\n\n![image-20211011170127948](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170127948.png)\n\n\n\n快速代码体验\n\n\n\n![image-20211011170134678](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170134678.png)\n\n\n\n\n\n\n\n## 进程——进程池间的通信\n\n\n\n### 进程池内进程间的通信\n\n\n\n通信原理：利用进程池内创建的Queue（队列）来实现进程池内进程间的通信\n\n进程池内创建队列方法：pool_queue = multiprocessing.Manager（）.Queue（3）   【创建一个长度为3的线程池队列】\n\n\n\n注意事项：\n\n1：在进程池中创建队列，一定要用multiprocessing模块内的Manager（）类里面的Queue（）类来创建！\n\n2：在采用异步方法实现进程池中进程的通信时，不要在最后忘记close（）方法和join（）方法\n\n\n\n通信图示\n\n![image-20211011170154915](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170154915.png)\n\n\n\n快速代码体验（同步）：\n\n![image-20211011170201954](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170201954.png)\n\n\n\n异步【重点】：\n\n![image-20211011170208591](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170208591.png)\n\n\n\n\n## 案例：多进程文件夹copy器\n\n\n\n怎么创建文件夹？\n\nos.mkdir（“文件夹名称”）\n\n\n\n\n\n怎么获取文件夹内所有文件名并且保存至一个列表内？（包括文件名和文件夹名）\n\nos.listdir（“目标文件夹名称”）\n\n\n\n\n\n\n## 案例：多进程简单web服务器\n\n\n略.....\n\n\n未完待续.....\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["多任务编程"],"categories":["多任务编程"]},{"title":"多任务编程——多线程","url":"/2021/10/11/多任务编程——多线程/","content":"\n\n\n\n\n本文主讲：在Python内多任务编程中的多线程实现方法.....\n\n\n\n<!--more-->\n\n\n\n\n\n## 多任务介绍\n\n\n\n### 什么是多任务？\n\n\n\n多任务就是操作系统同一时间执行多个任务，现在多核CPU已经很普及了，但是即便单核CPU也可以实现多任务（单核CPU采用时间片轮询方法实现多任务，因为CPU没秒计算速度特别快！，2.6GHZ的CPU每秒可运行26亿次）\n\n\n\n多任务效率极高，在文件下载、爬虫等应用都很广泛！！\n\n\n\n多任务优势\n\n\n\n![image-20211011162739207](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162739207.png)\n\n\n\n\n\n### 单任务与多任务的区别\n\n\n\n1：多任务是操作系统同一时间执行多个任务，单任务是同一时间执行单个任务\n\n2：多任务相较于单任务效率快，广泛应用在文件下载、python爬虫等\n\n\n\n\n\n### python程序默认是单任务执行\n\n![image-20211011162754107](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162754107.png)\n\n\n\n\n\n## 线程——基本使用【重中之重】\n\n\n\n### 什么是线程？主线程与子线程的关系？\n\n\n\n什么是线程？线程可以理解为程序执行的一条分支，也是程序执行流的最小单元，线程是被系统独立调动的和分派的基本单元，线程不拥有自己的系统资源，只拥有一点在运行中必不可少的资源，但是它可以与同属于同一个进程的其他线程共享所拥有的资源\n\n\n\n主线程：当一个程序启动时，就会建立一个主进程，这个主进程内又包含了一个主线程，简而言之，系统启动就会建立一个主进程，主进程包含主线程，因此程序启动就会建立一个主线程！！\n\n\n\n子线程：子线程是由主线程（程序启动自动生成主线程）创建的，建立之后子线程与主线程一起同时向下执行\n\n\n\n理解主线程与子线程的关系：\n\n![image-20211011162829936](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162829936.png)\n\n\n\n\n\n主线程重要的方面：\n\n1：主线程创建子线程\n\n2：主线程通常最后执行结束（子线程全部结束执行主线程才结束），打扫战场，如各种关闭操作\n\n​\t\t\t\n​\t\t\t\n\n### threading模块的Thread类创建线程（子线程）步骤\n\n\n\n1：导入threading模块\n\n2：利用threading模块的Thread类创建子线程对象\n\n3：利用类的target参数为子线程指定分支任务（例如 target = 函数名，注意函数没有括号）\n\n4：启动创建的子线程，创建子线程对象 . start（）\n\n\n\n创建步骤代码演示\n\n![image-20211011162851447](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162851447.png)\n\n\n\n注意事项：\n\n1：在利用 Thread 类创建的子线程对象用targrt参数指定任务是函数，且没有括号！！！\n\n2：创建的子线程对象只有调用start（）方法，子线程才会执行！\n\n3：主线程只有在所有子线程全部执行结束后才结束执行！\n\n4：创建多个子线程对象，利用start（）方法启动，因为计算机运算速度超快，故可看做多个子线程是同时启动运行的！\n\n\n\n\n\n\n线程实例应用（唱歌跳舞）：\n\n![image-20211011162908067](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162908067.png)\n\n\n\n\n\n\n## 线程——查看线程名称、总数量（活跃）【重点】\n\n\n\n目标：掌握如何查看正在活跃（执行）的线程数量（名称）\n\n\n\n### threading.enumerate（）函数\n\n\n\n功能：查看程序中正在活跃的线程数量及其名称，并存放至列表内\n\n语法：`thread_list = threading.enumerate( )`\n\n注意事项：threading.enumerate（）函数只能查看正在活跃（运行）的线程（主线程与子线程）\n\n\n\n快速代码体验（查看数量）\n\n![image-20211011162928409](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162928409.png)\n\n\n\n查看线程名称\n\n![image-20211011162949302](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162949302.png)\n\n\n\n\n\n## 线程——线程函数传参、线程执行顺序【重点】\n\n\n\n### 向线程函数传参数方法1——args元组传参\n\n\n\n功能：向子线程target指定的函数任务传递参数，因为有的函数是要有参数的\n\n语法：thread_obj = threading.Thread（target = 函数名 ， agrs = （函数参数1，函数参数2，函数参数3））\n\n\n\n快速代码体验\n\n![image-20211011163010242](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163010242.png)\n\n\n\n### 线程函数传递参数方法2——kwargs字典传参\n\n\n\n功能：向子线程target指定的函数任务传递参数，因为有的函数是要有参数的\n\n语法：`thread_obj = threading.Thread（target = 函数名 ， kwagrs = {“函数参数1”：参数1的值，…….}`\n\n\n\n快速代码体验\n\n![image-20211011163100543](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163100543.png)\n\n\n\n\n\n### 线程函数传递参数方法2——args元组传参以及kwargs字典混合搭配\n\n\n\n功能：向子线程target指定的函数任务传递参数，因为有的函数是要有参数的\n\n语法：`thread_obj = threading.Thread（target = 函数名 ，args=（参数1，）  kwargs = {“函数参数2”：参数2的值，…….}`\n\n注意事项：混合传参，也是总共传递那几个参数\n\n快速代码体验\n\n![image-20211011163136019](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163136019.png)\n\n\n\n### 子线程的执行顺序\n\n\n\n答：子线程是由系统独立调动的和分派的基本单元，所以子线程的执行顺序是无序的，是cpu决定的，不是程序员决定的\n\n\n\n总结：\n\n1：每一个线程（子线程、主线程）都有自己的名字，它们由python自动指定\n\n2：线程的run（）方法结束时该线程结束执行\n\n3：我们无法控制线程的执行顺序，但是我们可以通过其他方式影响调度方式\n\n\n\n\n\n\n\n\n## 线程——守护线程【重点】\n\n\n\n### 什么是守护线程？\n\n\n\n答：即子线程与主线程的一种约定！将子线程设置为守护主线程后，主线程结束运行后，守护线程（子线程）也会自动结束，反之，主线程没有结束运行，守护线程也不会结束运行。可以将主线程比作皇上，设置为守护线程的子线程比作妃子，皇上驾崩（主线程结束），则妃子们全部殉葬（全部守护线程全部结束执行）\n\n\n\n答：如果不将子线程设置为守护线程，在主线程意外结束执行后，子线程还会继续执行，这样是缺乏逻辑的，因此要设置守护线程！\n\n\n\n### 子线程设置为守护线程—— 创建的子线程对象.setDaemon（True）\n\n\n\n功能：将子线程设置为守护线程，在主线程结束运行后（意外结束等），守护线程（子线程）也全部结束运行！\n\n语法：创建的子线程对象 . setDaemon（True）\n\n\n\n注意事项：\n\n1：将子线程设置为守护线程要在 thread.start（）之前设置！\n\n2：如果不将子线程设置为守护线程，主线程意外结束后，子线程会继续执行，这样是不允许的！\n\n3：什么情况下主程序执行完毕？就是在if __name__ == '__main__':这行代码下面除了守护线程的代码外，其余代码均执行完毕即主程序执行结束！！\n\n\n\n快速代码体验（没将子线程设置为守护线程的结果\n\n![image-20211011163209160](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163209160.png)\n\n\n\n将子线程设置为守护线程后的结果截图\n\n![image-20211011163220727](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163220727.png)\n\n\n\n### pycharm软件按住结束程序按钮显示骷髅头是为什么？\n\n\n\n答：因为按下程序结束按钮，主程序结束，但因为多线程，故子线程没有结束执行，子线程还在继续执行，这是没有将子线程设置为守护线程的缘故！！！\n\n![image-20211011163236159](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163236159.png)\n\n\n\n\n\n## 线程——并发和并行【了解】\n\n\n\n### 多任务的底层原理\n\n![image-20211011163317896](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163317896.png)\n\n\n\n### 并发与并行概念及区别\n\n\n\n并发：当操作系统需要执行的任务数大于计算机CPU数量时，计算机通过系统的各种跳读算法（时间片轮询），实现多个任务一起“执行”（其实不是一起执行的，只不过是计算机运行速度飞快，看上去所有的任务一起执行）\n\n\n\n并行：操作系统需要执行的任务数小于或等于cpu内核数，一个cpu会最多执行一个任务，即任务真的是一起执行！\n\n\n\n注意事项：计算机一般多任务方式都为并发\n\n\n\n\n\n\n\n\n## 线程——自定义线程类【重中之重】\n\n\n\n目标：通过继承 threading . Thread 类来自定义线程类（应用于多线程下载、爬虫等）\n\n\n\n你问我答：已经有现成的子线程类 threading.Thread 可创建子线程，为啥还要自定义线程类创建子线程呢？\n\n\n\n答：为了让每个线程的封装更加完美，所以使用 threading 模块时，需要自定义线程类，这样才会更加完美！！！\n\n\n\n### 通过继承 threading . Thread 类来自定义线程类的步骤\n\n\n\n1：class新建一个类，并且继承 threading.Thread 父类\n\n2：重写父类 threading.Thread 的 run（）方法\n\n3：通过实例化对象（子线程）的 start（）方法（继承父类的start（）方法）启动这个自定义线程类\n\n\n\n注意事项：\n\n1：父类的start（）方法只能调用一次\n\n2：子类在重写父类的__init__方法时，一定要先调用父类的__init__方法，即super（）.__init__继承父类的属性\n\n3：不管是什么问题，只要是子类继承了父类，那么在给子类实例化属性时，一定要继承父类的实例化属性，即super（）.__init__( )\n\n\n\n快速代码体验\n\n![image-20211011163356240](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163356240.png)\n\n\n\n注意事项代码演示：子类在重写父类的__init__方法时，一定要先调用父类的__init__方法，即super（）.__init__\n\n![image-20211011163413276](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163413276.png)\n\n\n\n\n\n## 线程——多线程之间共享全局变量【重点】\n\n\n\n### 函数中修改全局变量的注意事项\n\n\n\n答：在函数内修改全局变量之前，要先声明这个变量为全局变量，方法为 global 全局变量名\n\n![image-20211011163426671](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163426671.png)\n\n\n\n\n\n### 多个线程之间（子线程、主线程）是可以共享全局变量的！\n\n\n\n证明逻辑步骤：\n\n\n\n1：定义全局变量\n2：定义函数1（子线程1）修改全局变量的值\n3：定义函数2（子线程2）读取全局变量的值，看读取的全局变量值，是否是被函数1修改后的全局变量值！是的话就证明全局变量是可以在多线程之间共享的！\n\n\n\n快速代码体验\n\n![image-20211011163441280](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163441280.png)\n\n\n\n\n\n## 线程——多线程共享一个全局变量产生的问题【重点】\n\n\n\n### 多线程间共享同一个全局变量（同时处理这个全局变量）会产生资源竞争等问题\n\n\n\n你问我答：多线程什么情况会产生资源竞争的问题呢？\n\n\n\n答：两个（多个）子线程同时处理一个公共资源时（比如说同一个全局变量），就会产生资源竞争的问题\n\n\n\n图片详解\n\n![image-20211011163501152](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163501152.png)\n\n\n\n问题代码解释\n\n![image-20211011163508863](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163508863.png)\n\n\n\n### 解决多线程间资源竞争的方法—— join（）\n\n\n\n功能：可以有效解决多线程间资源竞争问题，即让一个指定线程先执行完在执行其他线程，即从多线程变为单线程但是会造成程序效率变低\n\n语法：指定线程 . join（)\n\n\n\n注意事项：\n\n1：子线程的join方法要在子线程的start方法后加入！\n\n2：给某个子线程加入join方法后，这个子线程执行任务时另一个子线程则不启动了，等待这个子线程执行结束，另一个子线程才启动继续执行任务\n\n\n快速代码体验\n\n![image-20211011163533848](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163533848.png)\n\n\n\n\n## 线程——同步与异步【重点】\n\n\n\n### 同步与异步\n\n\n\n同步：多任务执行时要求有先后顺序，必须一个先执行完毕，另一个线程才能继续执行，只有一个主线！（一个子线程执行，另一个子线程等待这个子线程执行结束，等待期间什么也不做）\n\n\n\n异步：多任务执行时没有先后顺序，可以同时执行，存在多条运行主线！\n\n\n\n### 解决多线程同时修改同一个全局变量产生的资源竞争问题（线程锁）\n\n\n\n答：可以通过线程同步（同一时间只能有一个线程对全局变量进行修改）的方式（线程锁）来修改多线程间资源竞争问题！思路如下\n\n\n\n线程锁机制（同步）：两个子线程同时对一个全局变量进行修改，会产生资源竞争问题，采用线程锁机制可以解决此问题，线程锁是在一个子线程修改全局变量时，子线程会对这个全局变量上一把锁，这样其他子线程无法对这个全局变量进行修改，修改完全局变量后，在把锁打开，让其他线程进行修改（线程锁同理）！这就是线程锁机制\n\n\n\n图解：\n\n![image-20211011163554812](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163554812.png)\n\n\n\n\n## 线程——互斥锁【重点】\n\n\n\n### 什么是互斥锁？\n\n\n\n答：互斥锁是将线程同步思想落实的一种机制（锁机制），多个线程几乎同时执行同一任务时（注意一定是同一任务！！！），需要进行同步控制！\n\n\n\n互斥锁是最简单的线程同步机制！\n\n\n\n互斥锁两种状态：锁定/非锁定\n\n\n\n互斥锁实现原理：当一个线程执行某个任务时，该线程对这个任务进行锁定，锁定期间不允许其他线程访问执行这个任务，直到该线程执行完当前任务，将锁打开，变为非锁定状态，其他线程才可以对这个任务进行访问执行，这样就避免了资源竞争问题，互斥锁实现了每次只有一个线程执行任务，保证了多线程情况下数据的正确性\n\n\n\n\n\n### 创建互斥锁方法—— threading模块的 Lock（）类创建互斥锁\n\n\n\n功能：对资源进行锁定以及非锁定，解决多任务（多线程）间资源竞争问题\n\n\n\n创建互斥锁步骤：\n\n1：创建互斥锁 mutex = threading . Lock( )\n2：对资源上锁 mutex . acquire（ ）\n3：对资源进行解锁 mutex . release（ ）\n\n\n\n注意事项：\n\n1：threading模块下的Lock是一个类\n\n2：子线程访问某个资源竞争任务（全局变量）时，为了避免资源竞争问题，要先对这个资源进行上锁，访问结束进行解锁\n\n3：给多任务加互斥锁时，多个线程全部启动，只是一个线程在处理资源时，另一个线程等待这个资源处理完毕后再次处理，这是和join方法的最大区别（join只启动一个线程）\n\n4：利用互斥锁锁资源时，要尽可能少锁竞争资源（代码）\n\n5：互斥锁应用于多个线程几乎同时执行一个任务时才用互斥锁！！这是使用互斥锁条件！！\n\n\n\n快速代码体验\n\n![image-20211011163627613](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163627613.png)\n\n\n\n\n\n## 线程——死锁【重点】\n\n\n\n### 什么是死锁？\n\n\n\n答：死锁发生在多线程间，比如两个子线程同时处理一个共同任务，每个子线程都会占用这个任务的一部分资源，且两个子线程间都在等待对方释放其占有的那部分资源，这样就会造成线程死锁（一个子线程将资源锁住，未释放，另一个子线程还在等待这个子线程释放其资源，造成程序无响应、这就叫死锁）\n\n\n\n尽管在多线程间死锁很少发生，但是一旦发生就会造成程序无法响应\n\n\n\n死锁案例代码截图\n\n![image-20211011163705429](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163705429.png)\n\n\n\n死锁原理截图\n\n![image-20211011163713245](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163713245.png)\n\n\n\n\n\n### 多线程怎么避免死锁情况\n\n\n\n答：在函数任务退出之前，就要将锁住的数据进行释放，这样就避免了死锁发生！\n\n\n\n上面案例解决办法：将数据释放语句mutex.release()，放在return语句前面执行即可完成退出程序前对锁住的数据进行释放\n\n\n\n代码演示\n\n![image-20211011163732152](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163732152.png)\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["多任务编程"],"categories":["多任务编程"]},{"title":"通信协议——HTTP协议【重点】","url":"/2021/10/11/通信协议——HTTP协议【重点】/","content":"\n\n\n\n\n本文主讲：在网络传输协议中常用的B/S架构以及HTTP传输协议【对爬虫来说非常重要】！\n\n\n\n\n\n<!--more-->\n\n\n\n## HTTP协议概述【重点】\n\n\n\n### 什么是HTTP协议\n\n\n\n概念：\n\n\n\nHTTP（Hypertext Transfer Protocol）叫超文本传输协议，是互联网上应用最为广泛的网络协议，所有的WWW文件必须遵守这个标准，设计HTTP的目的是提供一种发送和接收HTML页面（网页）的方法，因此HTTP协议就是在网络上传输HTML文本的协议，用于浏览器与服务器的通信\n\n\n\nHTTP是客户端和网站服务端请求与响应的标准（TCP），客户端与服务器建立TCP连接后（客户端可以是浏览器、爬虫工具），客户端（浏览器、爬虫等）向服务端发送一个指定端口（默认端口为80）的HTTP请求协议，服务端一定会做出HTTP响应协议\n\n\n超文本传输协议（HTTP）是一种应用层协议，它是基于TCP（面向有连接）的一种网络协议\n\n\n\nHTTP模式：请求（requset）—— 响应（response）模式\n\n![image-20211011160351917](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160351917.png)\n\n\n\n因此，HTTP协议分成了两个部分：请求协议、响应协议\n\n\n\n\n\n### HTTP协议的构成和作用\n\n![image-20211011160412649](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160412649.png)\n\n\n\n构成：不管是请求协议还是响应协议，都是由一个一个协议项所构成的，协议项形式如下：\n\n协议名：协议内容（值）\n\n例如：Host ： www.gaoyang.com\n\n注意事项：每一个协议项都要单独占一行！\n\n\n\n\n\n\n\n## 通过浏览器查看HTTP协议【重点】\n\n\n\n\n目标：学会使用 Edge 浏览器查看浏览器与百度网站的HTTP协议（请求协议、响应协议）！\n\n\n\n### Edge浏览器查看HTTP协议（请求协议、响应协议）\n\n\n\n第一步：在Edeg浏览器内按下F12进入开发者模式\n\n\n\n![image-20211011160434388](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160434388.png)\n\n第二步：点击网络进入\n\n![image-20211011160443401](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160443401.png)\n\n\n\n第三步：点击浏览器的刷新后点击www.baidu.com\n\n![image-20211011160452193](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160452193.png)\n\n\n\n第四步：点击标头，查看请求协议与响应协议\n\n![image-20211011160459972](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160459972.png)\n\n\n\n第五步：查看响应协议与请求协议的协议源（服务器发给客户端的原数据，没有被浏览器加工过的）\n\n![image-20211011160507379](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160507379.png)\n\n\n\n第六步：协议源（服务器发给客户端没有经过浏览器加工过的数据）截图\n\n![image-20211011160514369](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160514369.png)\n\n\n\n\n\n\n## HTTP请求协议报文格式【重点】\n\n\n\n### 一：请求协议的报文格式\n\n\n\n![image-20211011160549702](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160549702.png)\n\n\n\n你问我答：在HTTP请求协议中，有两种常用的HTTP请求方式即 GET 模式与 POST 模式，那么它们两个在请求协议报文格式上有什么不同呢？\n\n\n\nGET请求方式包含的内容：请求行、请求头、请求空行\n\nPOST请求方式包含的内容：请求行、请求头、请求空行、请求体\n\n\n\n\n\n### 请求行、请求头、请求空行和请求体的格式与代表的含义及注意事项\n\n\n\n请求行：\n\n格式示例：GET / HTTP/1.1 \n\n代表含义：其中GET代表请求方式、/ 代表浏览器（客户端）请求访问服务器上资源的路径 、HTTP/1.1是请求协议及版本\n\n\n\n注意事项：\n\n1：请求行需要单独占一行，来说明当前请求协议的基本信息\n\n2：浏览器请求服务器的资源路径不包括域名\n\n3：HTTP以前的版本是1.0，现在的版本是1.1\n\n\n\n\n\n\n\n请求头******（很重要）**：\n\n![image-20211011160621760](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160621760.png)\n\n\n\n\n\n请求空行：用来分隔请求头和请求主体\n\n\n\n请求主体：只有请求协议的方式是 POST 的时候，请求协议才有请求主体，请求主体是服务器发给浏览器的HTML数据\n\n\n\n### 利用网络调试助手充当TCP网站服务器，在利用浏览器（客户端）对这个服务器进行请求协议\n\n\n\n注意事项：客户端（浏览器）与网站服务器先要建立TCP连接，客户端才能向服务端发起请求协议\n\n\n\n网络调试助手截图\n\n\n\n![image-20211011160637788](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160637788.png)\n\n\n\n\n\n\n\n浏览器（客户端）与调试助手建立 TCP 连接后发送请求协议截图\n\n\n\n![image-20211011160702158](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160702158.png)\n\n\n\n\n\n调试助手（服务端）接收到来自客户端的请求协议截图\n\n![image-20211011160708618](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160708618.png)\n\n\n\n\n\n\n\n## HTTP响应协议报文格式内容\n\n\n\n### 响应协议\n\n\n\n概念：响应协议就是服务器收到客户端的请求协议后返回给浏览器数据的协议\n\n\n\n\n\n### 响应协议的报文内容\n\n\n\n响应行（状态行）：\n\n\n\n响应行格式：响应的协议及版本 响应状态码 响应状态的描述\n\n响应行示例：HTTP/1.1  200  ok\n\n响应行截图（百度服务器）：\n\n![image-20211011160729326](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160729326.png)\n\n\n\n状态码的分类及含义\n\n![image-20211011160738595](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160738595.png)\n\n\n\n\n\n注意事项：响应协议的响应行的状态码和状态码描述是一一对应的\n\n\n\n响应头：由一些协议项所构成\n\n\n\n\n\n响应头格式：协议名：协议值\n响应头截图：\n\n![image-20211011160755144](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160755144.png)\n\n\n\n响应空行：分隔响应头与响应主体（响应数据）\n\n\n\n响应体（响应数据）：即网站服务器接收到浏览器（客户端）的请求后响应，发送给客户端的HTML数据！\n\n![image-20211011160805951](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160805951.png)\n\n\n\n### 响应协议的响应行的状态码为 404 的含义\n\n\n\n答：响应行状态码为 404 代表浏览器请求的服务器页面（服务器资源），在服务器内找不到，即请求的资源在服务器内不存在\n\n\n\n\n\n### 网络调试助手模拟百度服务器向请求的浏览器发送数据（html）\n\n\n\n调试助手截图\n\n![image-20211011160824147](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160824147.png)\n\n\n\n浏览器（客户端）的截图\n\n![image-20211011160838554](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160838554.png)\n\n\n\n\n\n## 长连接与短连接【重点】\n\n\n\n\n\n### 长连接与短连接\n\n\n\n短连接：在HTTP1.0中，默认使用连接方式是短连接，浏览器与服务器每进行一次HTTP操作，就会建立、关闭一次TCP连接，即传输一个数据就要建立一次连接，两个就是建立两次连接\n\n![image-20211011160853203](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160853203.png)\n\n\n\n\n\n长连接：在HTTP1.1版本后，默认使用的是长连接，使用长连接的的HTTP协议，在响应头里面会有下面这段代码\n\n`Connection ： keep—alive`\n\n![image-20211011160904256](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160904256.png)\n\n\n\n\n\n### HTTP请求响应的短连接与长连接的优缺点\n\n\n\n长连接：长连接可以省去较多的TCP建立、关闭连接的操作，节省时间，并且响应客户端的时间比短连接快很多，但是如果服务器访问人数过多的情况下会造成服务器负载过大而不可用（比如一台服务器同时支持500人访问，且长连接持续时间为10分钟，那么第501个人连接这台服务器，就要等十分钟以内的时间才可以访问即不可用，网站打不开）\n\n\n\n短连接：短连接服务器实现起来比较简单，创建的都是有用的TCP连接，但是如果请求服务器的人数过多，就会在短时间内创建大量的连接（因为要建立连接、断开连接），会造成服务器响应客户端速度变慢（网站可以打开，但是速度贼慢，比如说民大选课官网）\n\n\n\n总结：\n\n1：一般小型Web网站都采用短连接，因为消耗服务器资源小\n\n2：中大型Web网站一般采用长连接，优点是响应客户端的请求快，用户体验好\n\n3：数据库的连接是长连接，因为短连接会频繁的建立、断开TCP连接，可能会造成socket错误\n\n\n\n\n\n\n\n## 案例）模拟浏览器（网络调试助手）请求服务器的过程【重点】\n\n\n\n### 利用代码将网站域名解析为IP地址\n\n\n\n代码方法：套接字 . connect（（“网站域名”，80）） 在 connect（）方法底层，会自动将填写的域名解析为IP地址，从而与网站服务器建立 TCP 连接\n\n\n\n注意事项：\n\n1：浏览器请求网站服务器的步骤：与网站服务器建立TCP连接→浏览器向服务器发送请求协议→网站服务器响应浏览器发送响应协议→关闭TCP连接\n\n2：在 python 中编写TCP客户端的 connect（）方法会自动网站域名解析为IP地址，用来与网站服务端创建TCP连接\n\n3：网站服务器的端口默认为 80\n\n​\t\t\n\n快速代码体验\n\n![image-20211011160936521](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160936521.png)\n\n\n\n\n\n### python 编写代码模拟浏览器（客户端）请求百度服务器的流程\n\n\n\n流程：导入socket模块→创建TCP套接字→利用connect（）方法与百度网站的服务器创建TCP连接→客户端利用套接字的send（）方法向服务端发起请求协议→百度服务器响应客户端的请求协议，客户端利用套接字的recv（）方法接收服务器响应协议→利用字符串的切片将响应体从响应协议内分离出来→将响应体（有用文件）保存到文件内→关闭套接字\n\n\n\n快速代码体验：\n\n![image-20211011160947477](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160947477.png)\n\n\n\n注意事项：\n\n\n\n1：截取响应体的时候为什么要查找“\\r\\n\\r\\n”呢？因为响应协议中响应体和响应头中间相隔了“\\r\\n\\r\\n”，查找出“\\r\\n\\r\\n”位置截取字符串即可\n\n2：查找“\\r\\n\\r\\n”的时候，原始数据必须是字符串，而不是二进制数据，也就是代码中的 ws_data.decode().find(“\\r\\n\\r\\n”)，将ws_data二进制数据转为字符串\n\n3：代码模拟浏览器客户端向服务器发送请求协议时，请求行的 HTTP 一定要大写！！！，否则会出现400错误\n\n![image-20211011161003318](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161003318.png)\n\n\n\n\n\n### 格式化字符“\\r”与“\\n”和 \"\\r\\n\" 的作用\n\n\n\n“\\r”：不换行，将光标移动到本行行首\n\n“\\n”：换行，但是光标不移动到行首\n\n“ \\r\\n”：相当于回车，换行并且光标移动至行首\n\n\n\n\n\n\n\n## 访问网站服务器的固定html文件【重要】\n\n\n\n### 访问网站服务器上的固定文件\n\n\n\n访问方法：网站域名/文件名\n\n访问示例：www.baidu.com/a/b/ceshi.html\n\n\n\n注意事项：\n\n\n\n1：浏览器请求网站服务器（在浏览器上面仅输入网站域名），会自动打开服务器（服务器主机）根目录（Linux）下的 index.html 这个文件，www.baidu.com 与www.baidu.com/index.html 其实是一样的\n\n2：浏览器想要访问服务器上面的其他文件需要在域名后面跟上服务器的文件路径，比如说www.baidu.com/a/b/1.html，就是打开百度服务器中根目录下的a文件夹下b文件夹下的1.html文件\n\n3：因为网站服务器也是计算机，一般操作系统都是Linux，所以访问网站服务器上的固定文件，都是访问这台计算机上面目录下的文件\n\n\n\n快速代码体验\n\n![image-20211011161033863](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161033863.png)\n\n\n\n### 字符串的分割——split（）\n\n\n\n功能：根据某个分隔符将字符串分割成一个列表，假入有n个分割符就有n+1个列表元素\n\n快速代码体验\n\n![image-20211011161045025](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161045025.png)\n\n\n\n\n\n## 案例）编写代码模拟Web服务器\n\n\n\n网站服务器向浏览器返回固定数据！  黑马程序员 P91\n\n\n\n网站服务器向浏览器返回固定页面！ 黑马程序员 P92\n\n\n\n网站服务器向浏览器返回指定页面！ 黑马程序员 P93\n\n面向对象编程实现文件：\n\n![image-20211011161059194](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161059194.png)\n\n\n\n\n​\t\t\n​\t\t\n\n注意事项：在创建一个类的时候，在__init__ 方法下面，如果定义的变量在这个类的其他方法内要使用，就要将其变为这个类的实例化属性，即 self.xxxxx ，如果在其他方法内不使用，则不需要变为实例化属性\n\n\n\n快速代码体验\n\n![image-20211011161118750](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161118750.png)\n\n\n\n网站服务器向浏览器返回指定页面中存在的问题！ 黑马程序员 P94\n\n\n\n\n\n## 终端启动WEB服务器（python代码）【重点】\n\n\n\n### 在终端中运行 py 文件的两种方法\n\n\n\n第一种方法：. /py文件名 方法\n\n\n\n运行流程：\n\n1：利用 pycharm 打开 py 文件后在文件代码第一行加上 # ！ Python 解释器路径，关闭文件\n\n2：打开终端，利用 cd 指令进入需要运行 py 文件的相对文件路径，利用 chmod u+x 指令将py文件改为可运行\n\n3：在终端输入 ./py文件名 运行文件（必须是./py文件名格式，否则报错）\n\n\n\n\n第二种方法：\n\n1：打开终端，利用 cd 指令进入需要运行 py 文件的相对文件路径，不需要将文件改为可运行文件！\n\n2：在终端输入 python3 py文件名 即可运行（python3为python解释器，可以更改为其他版本）\n\n\n\n### sys模块的argv方法\n\n\n\n功能：获取在终端命令行输入的参数（注意是参数，不是指令），并且返回一个列表传递给运行的py程序\n\n代码格式：list1 = sys . argv\n\n\n\n注意事项：\n\n1：argv方法将命令行的参数保存至列表内后，传递给命令行中正在运行的那个程序\n\n2：argv方法没有括号！！\n\n3：命令行参数指的是参数，不是指令\n\n\n\n\n快速代码体验\n\npy代码\n\n![image-20211011161157451](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161157451.png)\n\n\n\n终端运行这个文件结果\n\n![image-20211011161209346](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161209346.png)\n\n\n\n### isdigit（）函数的作用\n\n\n\n功能：判断某个字符串中是否只含有数字，如果只含有数字返回True，含有其他的（字母、单词等）则返回False\n\n使用格式：字符串 . isdight( )\n\n扩展应用：在终端运行web服务器（py文件），用于判断终端命令行输入的端口号是否为纯数字字符串，是则启动服务器，不是则写好的web服务器不启动\n\n\n\n快速代码体验\n\n![image-20211011161224105](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161224105.png)\n\n\n\n### 在终端中运行特定端口号的 web 服务器（py程序）\n\n\n\n示例：\n\n\n\n功能：部署服务器的时候，服务器上面没有 pycharm，这时候我们就要用终端来运行写好的服务器文件了\n\n\n\n运行语法格式：python3 py文件 绑定的端口号\n\n注意事项：终端输入的端口号利用sys模块的argv方法传给py文件，服务器从而绑定端口号的时候绑定终端输入的端口号！\n\n快速代码体验\n\n![image-20211011161238744](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161238744.png)\n\n\n\n\n\n## 游戏服务器的部署\n\n\n\n### 解决利用py代码书写服务器，向服务器内发布html游戏，浏览器不能成功解析html代码的问题\n\n\n\n注意事项：\n\n1：服务器向浏览器发布html游戏就是向浏览器（客户端）发送游戏的html代码（响应体）\n\n2：浏览器不能成功解析html代码的问题就是，没有将游戏的html代码解析为html代码，而是解析为text文本\n\n\n\n问题截图：\n\n![image-20211011161305287](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161305287.png)\n\n\n\n解决办法：\n\n在服务器的响应头内加上这段代码即可让浏览器优先使用html解析服务器返回的数据，Content-Type：text/html \n\n\n\n### 类的注意事项\n\n\n\n在利用类的时候，类的某个方法中有一个局部变量，但是我们想要这个局部变量在整个类中使用（其他类方法中），那我们就可以将它定义为类的实例属性，即 self . xxx = xxx\n\n\n\n快速代码体验\n\n没有将变量修改为实例属性前\n\n\n\n![image-20211011161319599](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161319599.png)\n\n\n\n修改为实例属性后\n\n\n\n![image-20211011161333104](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161333104.png)\n\n\n\n\n\n\n\n## 字典的keys（）以及列表的enumerate（）方法\n\n\n\n### 字典的 keys（）函数\n\n\n\n功能：将字典中所有的key值保存到一个可迭代对象中（不是列表）\n\n语法：dict1.keys（）\n\n快速代码体验\n\n![image-20211011161350461](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161350461.png)\n\n\n\n### 列表、可迭代对象的 enumerate（）函数\n\n\n\n功能：将列表或者可迭代对象的元素列出来，并且将每个元素的索引和数据保存至元组内后再次保存至可迭代对象中\n\n语法：enumerate（list1，start = 0）：\n\n\n\n注意事项：\n\n1：start = 0 可以省略，默认下标为 0\n\n2：数据返回的下标值是整形（int）\n\n\n\n快速代码体验\n\n![image-20211011161404102](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161404102.png)\n\n\n\n\n未完待续....\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["通信协议篇"],"categories":["通信协议篇"]},{"title":"通信协议——IP地址与DNS","url":"/2021/10/11/通信协议——IP地址与DNS/","content":"\n\n\n本文主讲：在网络传输中IP地址与DNS的作用！\n\n\n\n<!--more-->\n\n\n\n\n\n## IP地址和域名\n\n\n\n### 域名\n\n\n\n概念：域名，简称 DN（domain name），域名可以理解为是一个网址，就是一个特殊的名字\n\n域名构成：字母、数字、中划线、其中域名长度不能超过255个字符\n\n特殊域名：localhost\n\n常见的顶级域名\n\n![image-20211011154654713](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154654713.png)\n\n\n\n为什么要有域名呢？\n\n\n\n答：在网络中每台计算机都有其唯一的 IP 地址，但是IP地址不方便记忆，因此出现了域名\n\n\n\n这是小袁的理解：在互联网中，一个网站可以运行，需要有自己的服务器提供支持，而服务器其实就是一台计算机，有自己的IP地址，正常来说，登录这个网站需要填写这个网站（服务器）的IP地址即可访问，但是ip地址很难记，所以就出现了域名来代替IP地址！\n\n\n\n![image-20211011154714372](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154714372.png)\n\n\n\n\n\n## DNS以及浏览器请求服务器的过程【重点】\n\n\n\n### DNS\n\n\n\n概念：DNS（Domain Name System）就是域名解析系统，它可以将网站的域名解析为对应的 IP 地址，从而进行浏览器与服务器的 TCP 连接，DNS是运行在互联网中的服务器，将域名解析为IP地址连接这台DNS服务器就可以完成解析\n\n课外话：全球一共有13台DNS服务器，其中9台全在美国！\n\n\n\n### 浏览器请求服务器连接（登录某个网站）流程图 及其注意事项\n\n\n\n浏览器输入网站域名→本地DNS服务器解析域名为IP→（如果本地没有解析成功）远程DNS服务器解析域名→与网站服务器建立TCP连接→浏览器向服务器发送请求协议→服务器回馈给浏览器响应协议（响应行、响应头、响应空行、响应体即HTML数据）→浏览器渲染HTML数据呈现网页\n\n![image-20211011154743683](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154743683.png)\n\n\n\n\n\n\n注意事项：本地DNS服务器是一个文件，下面是文件所在位置\n\n`Windows：C:\\Windows\\System32\\drivers\\etc\\hosts`\n`Ubuntu：/etc/hosts`\n\n\n\n\n\n未完待续....\n\n\n","tags":["通信协议篇"],"categories":["通信协议篇"]},{"title":"通信协议--TCP相关","url":"/2021/10/10/通信协议——TCP相关/","content":"\n\n\n\n\n本文主讲：网络通信协议中的TCP连接的一些知识【重点】\n\n\n\n<!--more-->\n\n\n## TCP简介【高频面试】\n\n\n\n目标：\n1：掌握什么是 TCP 数据传输方式\n2：理解 TCP 通信的模型\n3：说出 TCP 数据传输方式是可靠传输的原因（高概率面试题）\n4：说出 TCP 与 UDP 数据传输的区别（百分之百面试题）\n5：知道 TCP 传输方式的客户端以及用户端的数据传输流程\n\n\n\n### 一：什么是 TCP 数据传输类型？\n\n\n\n答：TCP 数据传输是传输控制协议，它是面向连接的、可靠的、基于字节流的传输层通信协议，TCP通信模型中，通信之前一定要先建立连接才能发送数据，类似于今天的打电话！\n\n\n\n总结一句话：TCP 就是面向有连接可靠的，基于字节流的传输层通信协议\n\n\n\n注意事项：TCP 数据传输方式是一对一进行数据传输的，这种传输方式不适用于广播信息传递！！\n\n\n\n\n\n### 二： TCP 数据传输方式的通信模型\n\n\n\n![image-20211011153453462](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153453462.png)\n\n\n\n### TCP 数据传输方式可靠的原因\n\n\n\n1：采用应答机制，TCP 发送的每个报文段必须要接收到接收数据方的应答才认为这个报文段发送成功\n\n\n\n2：超时重传机制，发送数据方给接收数据方发送数据后会启动计时器，如果超出规定时间后，没有接收到接收数据方的应答，那么传输数据方会重新发送这条数据\n\n\n\n3：错误校核机制，发送数据方发送数据时因为一些不可避免的因素造成数据包顺序错乱，TCP 会进行顺序校核，如果在发送数据的时候，出现了数据包发送重复的现象，TCP会进行去重数据包校核！（TCP底层封装好）\n\n\n\n4：流量控制和阻塞管理机制，流量控制用来避免主机发送数据过快而使接收方来不及完全收下数据的现象\n\n\n\n\n\n### TCP 与 UDP 数据传输方式的不同点\n\n\n\n1：TCP 面向连接 UDP 面向无连接，因为连接会占用系统资源，故 TCP 比 UDP 更占用系统资源\n\n\n\n\n\n2：TCP 相较于 UDP 传输是可靠的，因为TCP具有下面几点（UDP没有）：\n\n1：采用应答机制\n\n2：超时重传（重新传输丢失的数据包）\n\n3：错误校核（调整数据包的顺序，删除重复的数据包）\n\n4：流量控制管理\n\n\n\n### TCP 数据传输方式客户端以及服务端的流程\n\n\n\n数据传输客户端流程：socket（套接字） → connect（与服务端建立连接）→ send【recv】（发送接受数据） → close（关闭套接字）\n\n\n\n\n数据传输客户端流程：socket（套接字）→ bind（绑定端口）→ listen （监听客户端发来的连接请求）→ accept（接受连接）→ recv【send】（接收发送数据）→ close（关闭套接字）\n\n\n\n\n\n\n\n\n## TCP网络程序——客户端【重点】\n\n\n\n目标：利用 TCP 编写网络客户端，与服务端进行网络通信\n\n\n\n### TCP 编写的网络客户端与服务端（网络调试助手）进行通信\n\n\n\n代码流程： \n\n\n\n导入模块  import socket\n创建 TCP 的套接字  socket_info  = socket.socket(socket.AF_INET , socket.SOCK_STREAM)\n与服务端进行连接  socket_info.connect((address))\n收发数据 socket_info.send(编码后的数据)\n关闭套接字 socket_info.close( )\n\n\n\n\n\n\n注意事项：\n\n1：创建 TCP 套接字时，第二个参数要选择  socket . SOCK_STREAM 代表 TCP 的套接字\n\n2：与服务端创建连接用到的是套接字的 connect 方法，其中connect括号里面的是服务端的 IP 以及端口号\n\n3：TCP 收发数据用到的是 send（）方法与 recv（）方法，括号里面直接填写数据即可！\n\n4：客户端收到服务端（调试助手）发来的数据不再是元组类型，而是字符串类型！！\n\n\n\n\n\n快速代码体验（客户端向服务端发送数据）\n\n\n服务端（网络调试助手）截图\n\n![image-20211011153616079](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153616079.png)\n\n\n\nTCP 编写的客户端代码截图\n\n![image-20211011153705188](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153705188.png)\n\n\n\n服务端接收到数据截图\n\n![image-20211011153714304](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153714304.png)\n\n\n\n\nTCP 客户端（编写代码端）接收来自服务端（网络调试助手）的数据\n\n网络调试助手（服务端）发送数据截图\n\n![image-20211011153722875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153722875.png)\n\n\n\n\n\nTCP 客户端接收数据代码截图\n\n![image-20211011153730437](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153730437.png)\n\n\n\n\n\n\n\n## TCP网络通信——服务端【重中之重】\n\n\n\n目标：学会编写 TCP 服务端网络程序（LINUX主机内），从而与客户端（网络调试助手）进行网络通信\n\n\n\n\n\n### 编写 TCP 服务端网络程序，其中调试助手充当客户端向服务端进行通信\n\n\n\n功能：实现服务端（LINUX主机）与客户端（网络调试助手）的网络通信\n\n\n\n代码实现流程（服务端）：导入模块→创建TCP套接字→绑定服务端ip以及端口→监听客户端的连接（被动监听）→等待接受客户端连接→收发数据→关闭两个套接字\n\n\n\n注意事项：\n\n1：因为服务端是等待客户端的连接（被动连接），所以要向客户端提供 ip 与端口号，故服务端必须要利用 bind（）方法绑定 ip 与端口号\n\n2：监听客户端的连接是利用套接字的 listen（num）方法，其中括号里面的 num 代表允许连接的最大客户端数，开启监听连接后此套接字将不再能接收发送数据（被动模式）！且 num 对 windows 系统有效，对 linux 系统无效！\n\n3：接受客户端的连接是利用套接字的 accept（）方法，建立连接成功后，即可进行通信\n\n4：套接字的 accept（）方法是接受客户端的连接，如果没有客户端进行连接，程序会造成阻塞，直到有客户端的连接，客户端连接成功后将返回一个元组，第一个数据是新的套接字，第二个是客户端的ip以及端口号\n\n5：刚开始创建的套接字在 listen（num）方法下变为被动模式，不能接收与发送数据，这个套接字只负责与客户端的连接问题，因此在利用套接字的 accept（）方法接收一个客户端的连接后，会产生一个新的套接字用于和客户端进行通信！并且有一个额外的客户端与服务器连接，就会产生一个新的套接字\n\t\t\n快速代码体验（客户端网络调试助手截图）\n\n![image-20211011153803628](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153803628.png)\n\n\n\n服务端代码截图\n\n![image-20211011153810381](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153810381.png)\n\n\n\n\n\n\n## TCP网络通信——服务器增强【重点】\n\n\n\n目标：\n1：掌握编写的服务端如何接收客户端发来的多条消息\n2：掌握如何接受多个客户端的连接\n\t\n\n### 编写的服务端接收多条客户端发来的消息代码实现\n\n\n\n功能：实现编写的服务端可以接收多条客户端发来的数据\n\n理论实现：在服务端接收数据语法前面 recv 加上一个死循环即可接收多条客户端发来的消息\n\n\n\n注意事项：\n1：如果客户端与服务端断开连接，那么服务端接收客户端发来的数据为空！！\n2：在 python 中的 while 循环的判断条件只要是非空就为真，例如 while “xxx“： 这个循环判断为真，因为”xxx“不为空\n\n\n\n快速代码体验\n\n![image-20211011153833315](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153833315.png)\n\n\n\n### 服务器如何连接多个客户端\n\n\n\n功能：让服务器连接多个客户端\n\n代码思想：在套接字的 accept（）方法上面加上一个死循环，即可接受多个服务器的连接！\n\n注意事项：现在这个阶段，必须要等第一个连接的客户端断开连接，第二个客户端才可以正常连接，后面多线程可以解决这个问题\n\n快速代码体验\n\n![image-20211011153852033](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153852033.png)\n\n\n\n\n\n\n\n## （案例）TCP文件下载器【服务端、客户端】\n\n\n\n目标：\n1：掌握 with open（）方法打开一个文件与直接用 open（）方法打开文件有什么区别\n2：编写TCP服务端与客户端，从而可以实现客户端从服务端上下载文件\n\t\n\n### with open（）as xxx 打开文件与 直接用 open（）打开文件有什么区别\n\n\n\n答：with open（”文件名“，”文件打开方式“）as  file 打开一个文件，内置了 close（）方法，即不需要关闭文件了！\n\n\n\n注意事项：\n\nwith open（”文件名“，”文件打开方式“）as  file 相当于下面这两行代码 \n\n\n\nfile = open（”文件名“，”文件打开方式“） \n\nfile.close（）\n\n\n\n\n\n快速代码体验\n\n![image-20211011153915572](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153915572.png)\n\n\n\n### TCP 编写的文件下载器（客户端下载服务端上的文件）\n\n\n\n代码文件\n\n\n\n客户端代码文件\n\n![image-20211011153924525](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153924525.png)\n\n\n服务端代码文件\n\n![image-20211011153931430](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153931430.png)\n\n\n\n\n\n\n\n\n## TCP的三次握手【面试】\n\n\n\n目标：\n1：掌握 TCP 的三次握手是用于连接\n2：面试题：为什么要 TCP 的三次握手，两次不可以吗？四次，五次呢？\n\n\n\n### 什么是 TCP 的三次握手\n\n\n\n答：TCP 的三次握手是指，客户端与服务端建立的 TCP 连接时，客户端与服务端总共发送的三个数据包，在 socket 编程中，这一过程是由客户端发起的 connect 方法所触发的！\n\n\n\n注意事项：\n\n1：TCP 的客户端与服务端建立连接时，必须要经过 TCP 的三次握手才可以成功建立通信\n\n2：如果 tcp 的第三次握手丢失（即客户端没有应答服务端的包），那么服务端会一直向客户端发送第二个包（第二次握手），并且客户端也会向服务端重新发送 SYN 请求（第一次握手），这就叫 SYN 洪水攻击！这样会使服务器的资源大量浪费！\n\n\n\n图示（示意图：打电话）\n\n![image-20211011153959342](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011153959342.png)\n\n\n\n协议底层图\n\n![image-20211011154010951](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154010951.png)\n\n![image-20211011154020134](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154020134.png)\n\n\n\n\n\n### 面试题：为什么服务端客户端建立 TCP 连接三次握手，两次不可以吗？四次，五次呢？\n\n\n\n答：不可以，丢失第三次握手（第三个包）的话，服务端就不会接收到客户端的应答，服务端就会一直向客户端发送第二次握手（第二个包），又因为建立 TCP 连接不成功，客户端可能会向服务端重新发送第一次握手（第一个包，连接 SYN 请求），这样会大量浪费服务器的资源，占用服务器的内存，造成服务器的性能下降，这就叫 SYN 洪水攻击，而四次握手、五次握手也会造成资源的浪费，明明三次就可以完成的！\n\n\n\n\n\n## TCP的四次挥手【面试】\n\n\n\n目标：\n1：掌握什么是 TCP 的四次挥手\n2：疑难问题解决（解决地址重用问题）\n\n\n\n### TCP 的四次挥手\n\n\n\n概念：在 TCP 的客户端与服务端断开连接时，客户端与服务端总共发送四个包后从而确认断开连接，这就叫 TCP 的四次挥手，TCP的四次挥手用于断开TCP连接\n\n\n\n内部流程图\n\n![image-20211011154111861](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154111861.png)\n\n\n\n面试题：\n\n\n\n为什么主动发起断开连接的一方要等待 2MLS 时间才能断开连接，因为有一些原因造成第四个包丢失，主动发起断开连接的一方要等待另一方发送上一个包（TCP的应答机制和超时重传）的最大时间就是 2MLS\n\n\n\n### 当服务端主动断开连接时，再次运行这个服务端的话会报这样的错误 Address already in use ，这是怎么回事，该怎么解决？\n\n![image-20211011154130703](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154130703.png)\n\n\n\n答：Address already in use 翻译是该地址已经被使用，这是因为，主动发起断开tcp连接的一方会等待 2MLS时间才能真正断开连接，所以在 2MLS时间内重启这个服务端就会报这样的错误，下面是解决办法\n\n\n\n\n\n解决办法：设置负责客户端连接的套接字地址属性即可解决此问题\n\n代码：`套接字 . setsockopt（socket.SOL_SOCKET , socket . SO_REUSEADDR , True）`\n\n上面这段代码的意思是，设置套接字的地址可以重用即可解决此问题\n\n\n\n截图\n\n![image-20211011154149179](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011154149179.png)\n\n\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["通信协议篇"],"categories":["通信协议篇"]},{"title":"通信协议——UDP连接广播","url":"/2021/10/10/通信协议——UDP连接广播/","content":"\n\n\n\n\n本文主讲：详细讲解通信协议之一的UDP广播连接....\n\n\n\n<!--more-->\n\n\n\n\n\n## UDP广播\n\n\n\n\n### 广播的概念\n\n\n广播就是发送数据端发送一条数据，接收数据端都可以接收到这条消息，就叫广播\n\n\n\n\n\n### 什么是广播地址\n\n\n\n答：广播地址专门用于同时向网络中所有工作站进行发送数据的一个地址，在 udp/tcp 协议网络中，网络字段和主机字段全为1的 ip 地址称为 广播地址，即 255.255.255.255，因此向 255.255.255.255 ip地址发送数据，就是发送的广播数据\n\n\n\n### 使用 UDP 方式群发广播消息\n\n\n\n功能：对网络中（同一网段下）所有的工作站进行发送数据\n\n\n\n语法：\n\n\n\n1：创建的套接字 . （待发送的数据，（“255.255.255.255”，8080））  对网络中端口号为 8080 的所有工作站发送数据\n\n\n\n2：创建的套接字 . （待发送的数据，（“192.168.1.255”，8080））  对网络中端口号为 8080 并且在 192.168.1 这个网段下的所有工作站发送数据\n\n\n\n\n\n注意事项：\n\n\n\n1：利用套接字发送广播消息前要先设置套接字的广播权限，否则发送不成功，套接字的广播权限默认是关闭的，要设置一下打开，才能正常发送广播消息\n\n2：创建的套接字对象 . setsockopt（socket . SOL_SOCKET , socket . SO_BROADCAST , True）这句代码是将套接字的广播权限打开。\n\n\n\n快速代码体验（向所有工作站发送广播消息 即 ip 为255.255.255.255）\n\n![image-20211010114323156](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010114323156.png)\n\n\n\n（向所有工作站发送广播消息 即 ip 为192.168.1.255）\n\n![image-20211010114332560](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211010114332560.png)\n\n\n\n\n\n\n\n未完待续......\n\n","tags":["通信协议篇"],"categories":["通信协议篇"]},{"title":"通信协议——了解socket","url":"/2021/10/10/通信协议——了解socket/","content":"\n\n\n\n\n本文主讲：Python的虚拟环境、IP地址、端口、socket【套接字】、编码解码等相关知识....\n\n\n\n<!--more-->\n\n\n\n\n\n## python虚拟环境\n\n\n\n\n目标：\n1：知道在Linux中什么是虚拟环境？\n2：虚拟环境的作用是什么？\n3：掌握怎么配置虚拟环境\n4：掌握怎么进入、退出、删除虚拟环境\n5：掌握如何查看所有的虚拟环境\n6：掌握如何在 pycharm 配置虚拟环境\n\n\n\n一：Linux中什么是虚拟环境？\n\n虚拟环境就是在Linux（服务器）中开辟多个虚拟空间，每个虚拟空间内可存放独立的东西（软件、库），且每个虚拟环境之间互不影响！\n\n\n\n二：虚拟环境的作用（图示）\n\n![image-20211010113032624](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113032624.png)\n\n\n\n\n\n三：怎么在Linux（服务器）配置搭建虚拟环境\n\n\n\n第一步：在Linux终端安装虚拟环境指令\n\n```\nsudo pip3 install virtualenv\nsudo pip3 install virtualenvwrapper\n```\n\n\n\n第二步：创建虚拟环境\n\n\n\n语法：\n\n不指定python版本：mkvirtualenv  虚拟环境名称   例如 mkvirtualenv  py-vir （其中 py-vir是虚拟环境名称）\n\n指定python版本：mkvirtualenv -p python3版本路径 虚拟环境名称  例如 mkvirtualenv -p /home/lamb/python3 work1\n\n\n 注意事项：\n\n1：创建虚拟环境时，如果不指定python版本，默认创建 pytho2 版本的虚拟环境\n2：创建虚拟环境需要联网\n3：创建完虚拟环境后，会自动工作在这个虚拟环境下\n4：按住快捷键 Ctrl + h 可显示目录下的隐藏文件\n\t\t\n快速代码体验（不指定python版本）\n\n![image-20211010113100700](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113100700.png)\n\n\n\n指定python版本\n\n![image-20211010113111838](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113111838.png)\n\n\n\n\n\n四：怎么进入、退出、删除虚拟环境\n\n\n\n进入虚拟环境语法：workon 虚拟环境名称\n\n退出虚拟环境语法：deactivate \n\n删除虚拟环境语法：rmvirtualenv 虚拟环境名称\n\n\n\n\n\n五：如何查看Linux服务器内的所有虚拟环境\n\n答：利用  workon 即可查看所有虚拟环境\n\n快速代码体验：\n\n![image-20211010113127415](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113127415.png)\n\n\n\n\n\n六：怎么在 pycharm 使用（配置）已经创建好的虚拟环境呢？\n\n![image-20211010113134749](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113134749.png)\n\n\n\n\n\n\n## 网络通信协议\n\n\n\n一：什么是网络？\n\n答：网络就是一些相互连接、以资源共享为目的的计算机集合，使用网络可以把多方连接在一起，从而进行数据传递\n\n\n\n二：网络编程是什么？有什么用？\n\n答：网络编程可以在不同电脑上的软件进行数据传递，作用是传递数据\n\n\n\n\n\n\n\n\n## IP地址\n\n\n\n### 什么是IP地址？以及其作用？\n\n\n\n什么是IP地址：IP地址是指网络协议地址，在互联网上每一台电脑都有 IP 地址，即给每一台电脑进行编号，把个人电脑比作电话的话，IP地址就相当于电话号码\n\n\n\nIP地址作用是什么：用来给网络上的计算机进行标记，是网络为计算机分配的唯一标识（唯一性，不重复）\n\n\n\n\n\n注意事项：\n\n\n\n1：IP地址由两部分组成，xxx.xxx.xxx是网络号，后面那部分是主机号取值范围是0~255，例如192.168.1.42的192.168.1是网络号，42是主机号，如果公司内计算机比较多，主机号就为最后两段即 1.42，以此类推\n\n\n\n2：xxx.xxx.xxx.0 IP地址是不可用的（内部地址）\n\n\n\n3：xxx.xxx.xxx.255 IP地址也是不可用的（广播地址）\n\n\n\n4：理论上来说一个网段支持256个计算机的IP地址，但是除去上面两个IP地址，只能有254个计算机IP地址\n\n\n\n5：特殊的IP地址 127.0.0.1，即没有网络的时候计算机IP地址（本机地址）\n\n\n\n6：如果说两个IP地址是在同一个网段下，就说明这两个IP地址是同一个网络号！\n\n\n\n快速截图\n\n![image-20211010113209386](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113209386.png)\n\n\n\n\n\n### IPV4地址与IPV6地址的区别\n\n\n\nIPV4：xxx.xxx.xxx.xxx   点分十进制\nIPV6：xxx:xxx:xxx:xxx….  冒号分十六进制\n\n\n\n\n\n## 端口【重点】\n\n\n\n### 什么是端口？\n\n\n\n答：端口可以认为设备与外界通讯交流的出口，我认为是程序对外收发数据的出口，端口可分为物理端口（usb接口等）与虚拟端口\n\n\n\n图示1\n\n![image-20211010113232574](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113232574.png)\n\n\n\n图示2\n\n![image-20211010113244292](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113244292.png)\n\n\n\n### 虚拟端口分为哪几类？\n\n\n\n答：虚拟端口分为两类分别是知名端口以及动态端口\n\n\n\n注意事项：\n\n1：计算机上端口有65536个（2的16次方），为了管理方便将每个端口进行编号即为端口号，端口号范围0~65535\n2：端口号0~1023是知名端口，不允许个人使用，1024~65535是动态端口，允许个人使用\n\n\n\n### 常见知名端口作用\n\n\n\n图示\n\n![image-20211010113301260](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113301260.png)\n\n\n\n\n\n### 查看端口指令 —— netstat\n\n\n\n功能：查看计算机上已连接的端口\n语法：netstat\n\n\n\n指令选项：\n-an ：查看计算机上所有已连接端口的状态，可配合管道指令 | 与查找指令 grep 使用 \n\n例如 netstat -an | gerp ：22 作用是查找22端口的状态\n\n\n\n快速代码体验（无选项）\n\n![image-20211010113318397](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113318397.png)\n\n\n\n有-an选项\n\n![image-20211010113325911](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113325911.png)\n\n\n\n配合管道指令与查找指令使用\n\n![image-20211010113333733](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113333733.png)\n\n\n\n### 查看端口被哪个程序占用指令 —— lsof \n\n\n\n功能：查看某一个端口是否被占用，占用的程序是什么\n语法：sudo lsof -i 端口号\n\n注意事项：\n1：lsof指令必须配合 sudo指令 以及 -i 选项使用，否则指令不能正常执行\n2：端口号是数字加上冒号，例如22端口号为 ：22\n\n\n\n快速代码体验\n\n![image-20211010113348750](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113348750.png)\n\n\n\n\n\n\n\n## 网络数据传输方式【重点】\n\n\n\n导读：为什么要有数据传输方式\n\n![image-20211010113409955](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113409955.png)\n\n\n\n### 网络数据传输的两种方式\n\n\n\n面向无连接型（UDP）：两台计算机在传输数据的时候，不需要事先建立连接，发送数据方可以随时随地发送数据，收数据方也不知道自己什么时候会收到数据比如说学校在喇叭上通知事情\n\n\n\n面向有连接型（TCP）：两台计算机在传输数据的时候需要先建立连接线路，线路建立成功才可以进行发送数据，例如管道运输液体等（液体为数据）\n\n\n\n\n\n### 两种网络数据传输方式的特点\n\n\n\nUDP：面向无连接性不提供复杂的控制机制，在发送数据的时候如果出现丢包的情况，不负责重发数据，并且数据出现包顺序错杂的时候也不负责纠正过来，因此UDP传输数据简单高效，数据传输速度快\n\n\n\n应用范围：\n\n1：即时通信，网络直播、视频、音频直播\n2：包总量较少的通信（DNS）\n3：广播通信\n\n\n\n\nTCP：面向有连接型数据传输方式在传输数据之前要建立一条数据通信线路，线路建立成功才发送数据，因此TCP数据传输在丢包时可重发数据包，还可以控制数据包的顺序，是可靠的数据传输方式\n\n\n\n\n\n\n## socket简介【重点】\n\n\n\n### 什么是 socket 套接字\n\n\n\n答：socket 套接字是支持 TCP\\UDP 网络通信的基本通信单元，可以看做两台主机进行双向通信的端点，也可以认为是网络数据传输的快递员，socket最早起源于Unix\n\n\n\nsocket 套接字图示\n\n![image-20211010113442592](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113442592.png)\n\n\n\nsocket 套接字工作模型\n\n![image-20211010113450042](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113450042.png)\n\n\n\n\n\n### python/pycharm中怎么创建一个 socket 对象进行数据收发 ？\n\n\n\n答：导入 socket 模块，使用 socket 模块中的 socket 类即可创建一个 socket 对象从而进行数据收发\n\n\n\n语法：\n```python\n\t\timport socket  #  导入 socket 模块\n\t\tsocket_object = socket.socket（网络协议地址 ， 传输方式）  # 用 socket 类创建一个 socket_object 对象\n\t\t数据收发步骤省略……   # 收发数据代码省略\n\t\tsocket_object . close( )  #  关闭这个 socket_object 套接字对象\n```\n\n\n\n注意事项：\n\n1：使用 socket 类实例化对象要有两个参数 分别是 Addressfamily（网络协议地址） 与 Type（数据传输方式）\n\n2：Addressfamily参数代表地址簇，即通信的IP地址，Addressfamily参数有两个常用值即 socket.AF_INET与socket.AF_INET6,其中socket.AF_INET代表IPV4地址，socket.AF_INET6代表IPV6的地址\n\t\t\t\n3：Type参数代表数据传输方式，Type参数有两个值，socket.SOCK_STREAM代表以TCP（面向有连接型）数据传输方式进行传输，socket.SOCK_DGRAM参数代表以UDP（面向无连接型）方式进行传输数据\n\n\n\n快速代码体验（创建一个socket套接字（IPV4，UDP）进行数据收发）\n\n![image-20211010113511337](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113511337.png)\n\n\n\n\n\n\n## 利用socket套接字发送数据【重点】\n\n\n\n### 网络调试助手（Netassist）的作用 windows版本\n\n\n\n答：在Linux系统利用 socket 套接字的 sendto 方法向另外一台计算机发送数据的时候，接收数据的这台计算机需要安装网络调试助手才可以接收Linux系统发送的数据\n\n\n\n软件界面\n\n![image-20211010113524046](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113524046.png)\n\n\n\n### socket套接字的 sendto 方法向网络调试助手发送数据\n\n\n\n功能：传输数据\n\n语法：创建的套接字.sendto（“内容”.encode(“gbk” ) , （\"IPV4地址\"，端口号））\n\n\n\n注意事项：\n\n1：利用sendto方法发送数据的时候，发送的数据要是二进制形式\n\n2：sendto方法中发送的内容后面跟上 encode（）方法是将发送的数据转换为二进制编码发送\n\n3：sendto方法中的encode（“gbk”）方法括号内的“gbk”是因为向Windows计算机发送数据，所以要填写gbk编码，否则造成文字乱码\n\n4：sendto方法中的IP地址与端口号是保存在一个元组内的，其中 IP 地址是字符串类型，端口号是整形，元组内的数据类型统称为 address 数据类型\n\n\n\n快速代码体验\n\n\n\n代码截图\n\n![image-20211010113541303](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113541303.png)\n\n\n\nwindows计算机网络调试助手接收数据结果截图\n\n![image-20211010113550494](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113550494.png)\n\n\n\n\n\n\n## socket套接字接收数据【重点】\n\n\n\n### socket 套接字的 recvfrom 方法接收数据 \n\n\n\n功能：从套接字中接收其他主机发送的数据\n\n\n\n语法： 创建的套接字 . recvfrom(1024)\n\n\n\n注意事项：\n\n\n\n1： recvfrom（1024） 方法中的 1024 代表缓冲区，表示从套接字内接收多少字节的数据，表示最多接收1024个字节的数据\n\n\n\n2：利用 recvfrom 接收的数据是一个元组，元组内第一个元素为接收的数据，第二个元素也是一个元组，存储发送数据方的 IP 地址和端口号\n\n\n\n3：利用 recvfrom 方法接收的数据是二进制格式的需要用 decode 方法对接收的数据进行解码（解码为字符串）\n\n\n\n4：利用 revcfeom 方法接收数据会造成程序的阻塞（程序停止运行），直到接收到数据程序才继续运行，类似于input方法\n\n\n\n5：因为接收的是windows主机调试助手的数据，因此利用decode解码数据括号里面要加上“gbk”\n\n\n\n6：网络数据传输是以二进制形式进行的\n\n\n\n快速代码体验（未将数据解码）\n\nwindows端先接收到数据\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113620112.png)\n\n\n\n随后 ubuntu 接收到网络调试助手发送的数据（未解码二进制数据）\n\n![image-20211010113649632](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113649632.png)\n\n\n\n\n\n\n将数据解码\n\nwindows调试助手先收到ununtu系统发来的数据\n\n![image-20211010113702272](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113702272.png)\n\n\n\n调试助手向ubuntu系统发送数据\n\n![image-20211010113710193](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113710193.png)\n\n\n\n\n\n## Python3编码转换【重点】\n\n\n\n### python3的编码与解码\n\n\n\n注意：网络中数据的传输是以二进制的方式进行的\n\n\n\n编码：encode（“字符集”）方法，将字符串类型的数据编码为二进制（字节码）的数据\n\n解码：decode（“字符集”）方法，将二进制（字节码）数据解码为字符串类型数据\n\n\n\n注意：\n1：字符集有常用的两种分别是“gbk”（国标码）与“utf-8”（万国码） \n2：ubuntu系统默认编码与解码的字符集为“ utf-8”即 encode（）与 decode（）默认是以 “utf-8”进行编码和解码的\n3：如果编码是以字符集“utf-8”进行的，那么解码也要用字符集“utf-8”进行，否则会出现乱码，解码失败\n\n\n\n\n\n## 在解码失败的情况下的处理方法\n\n\n\n功能：对接收的数据利用decode（“字符集”）进行解码时出现解码错误，是选择忽略错误还是严格要求错误\n\n\n\n语法1（不忽略解码错误）：二进制数据 . decode（encoding = \"字符集\"，errors = “strict”）\n语法2（忽略解码错误）：二进制数据 . decode（encoding = “字符集” , errors = \"ignore\"）\n\n\n\n快速代码体验（不忽略错误）\n\n调试助手截图（windows）\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113745324.png)\n\n\n\nubuntu系统接收数据截图\n\n![image-20211010113801396](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113801396.png)\n\n\n\n\n\n\n对解码错误进行忽略\n\n调试助手（windows）截图\n\n![image-20211010113812060](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113812060.png)\n\n\n\n\n\nubuntu系统接收数据截图\n\n![image-20211010113819294](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113819294.png)\n\n\n\n\n\n## 发送数据端（ubuntu系统）的端口绑定【重点】\n\n\n\n目标：掌握创建的套接字对象的bind 方法对发送数据方主机的端口进行绑定\n\n\n\n应用背景\n\n在 ubuntu 系统中向调试助手发送数据的时候，每一次发送数据，发送数据方（ubuntu）的端口都在发生变化，如下图所示，为了避免这一情况的出现，即可利用 bind 方法对发送数据方的端口进行绑定，从而使发送数据的时候端口不在发生变化\n\n\n\n\n\n截图\n\n![image-20211010113835216](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113835216.png)\n\n\n\n一：发送数据端的端口进行绑定方法 —— bind（address）\n\n\n\n功能：将发送数据端主机的端口进行绑定，从而在多次发送数据的时候，端口不会发生变化\n语法：套接字对象 . bind（address）\n\n\n\n注意事项：\n\n\n\n1：bind（address）括号里面的 address 代表地址数据类型（元组），如（“192.168.1.43”，6666）就是对192.168.1.43这个主机 IP 进行端口绑定，绑定的端口是 6666\n2：绑定端口时，address地址数据类型里面填写的IP地址是当前主机的IP，可以省略\n\t\t\n\n快速代码体验\n\nubuntu系统主机代码演示\n\n![image-20211010113850587](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113850587.png)\n\n\n\n调试助手接收多条数据的截图（来自同一端口）\n\n![image-20211010113858527](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113858527.png)\n\n\n\n\n\n## 接收数据端的端口绑定【重点】\n\n\n\n目标：掌握利用 bind 方法对接收数据方的端口进行绑定\n\n\n\n注意：接收数据端是ubuntu系统，因为调试助手充当发送数据端的角色\n\n\n\n一：接收数据端主机的端口绑定函数—— bind（）\n\n功能：对接收数据端主机（ubuntu系统）的端口进行绑定\n语法：创建的套接字 . bind（address）\n\n\n\n注意事项：\n\n1：address是地址数据类型，是一个元组 ，例如（“192.168.1.43”，8080）就是一个address数据类型，其中第一个元素是主机的IPV4地址，第二个是待绑定的端口号。\n\n2：在利用 bind（）方法绑定接收数据方主机端口号时，IPV4地址要写接收数据端的主机IPV4地址！\n\n3：接收数据端的 address 数据类型里面的 ip 地址最好写成空地址“ ”，因为如果计算机有两个网卡，就有两个 ip 地址，如果绑定一个网卡 ip 的话，就会造成另一个网卡接收不到数据，因此写为空，避免造成这种情况\n\n\n\n\n快速代码体验\n\n接受数据端主机代码截图\n\n![image-20211010113926846](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113926846.png)\n\n\n\n发送数据端（网络调试助手）截图\n\n![image-20211010113935077](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113935077.png)\n\n\n\n接收数据端接收数据截图\n\n![image-20211010113942938](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010113942938.png)\n\n\n\n未完待续....\n\n\n​\t\t\t\n\n\n\n\n\n\n\n\n","tags":["通信协议篇"],"categories":["通信协议篇"]},{"title":"Python有趣案例【第三期】","url":"/2021/10/10/Python有趣案例【第三期】/","content":"\n\n\n本文主讲：通过Python的第三方库 yagmail 发送邮件....\n\n\n\n<!--more-->\n\n\n\n## python发送邮件第三方库——yagmail\n\n\n\n目标：\n\n\n\n1：学会安装python第三方库—— yagmail \n2：掌握 yagmail 第三方库发送邮件\n\n\n\n\n\n一：终端安装python第三方库—— yagmail\n\n语法：pip3 install yagmail 即可安装\n\n\n\n二：yagmail 第三方库发送邮件使用方法\n\n功能：可以在 python环境下进行发送邮件功能\n\n\n\n语法：\n```python\n\t\timport yagmail\n\t\tinfo = y。agmail.SMTP( user = \"发件人邮箱\" , password = \"授权码\" , host = \"邮件发送主机\") \n\t\t其中 info 是创建的发件人对象\n\t\tcontent = \"这是发送邮件内容\"\n\t\tinfo.send(\"收件人邮箱\",\"邮件标题\",\"发送内容\")\n\t\t\n```\n\n\n\n注意事项：qq邮箱发送邮件的主机为 smtp.qq.com\n\n\n\n快速代码体验(代码部分)\n\n![image-20211010111611419](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010111611419.png)\n\n\n\n邮件发送结果截图\n\n\n\n![image-20211010111623677](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010111623677.png)\n\n\n\n\n\n未完待续....\n\n\n","tags":["Python有趣案例"],"categories":["Python有趣案例"]},{"title":"Linux实操—终端运行py文件","url":"/2021/10/10/Linux实操—终端运行py文件/","content":"\n\n\n\n\n本文主讲：如何在Linux终端内运行PY文件\n\n\n\n<!--more-->\n\n\n\n\n\n## Linux终端运行py文件的步骤\n\n\n\n目标：掌握如何用两种方法在 Linux 终端运行 py文件\n\n\n\n方法一： Linux 终端运行 py 文件步骤（./形式）\n\n\n\n第一步：进入 py 文件所在目录 ，将需要运行的 py 文件权限改为可运行 代码为 chmod u+x  py文件名\n\n\n第二步：pycharm打开这个 py 文件，在第一行加入 #!python解释器路径 ，告诉终端用哪个解释器运行这个py文件\n\n第三步：直接在终端输入 ./py文件名 运行这个py文件（只能相对路径运行py文件，且相对路径运行这个文件不能省略 ./ ,否则报错！）\n\n\n\n快速代码体验\n\n\n\n第一步：将py文件权限修改为可运行\n\n![image-20211010110855177](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110855177.png)\n\n\n\n第二步：pycharm打开py文件 在第一行加上 #！解释器路径 告诉终端用哪个解释器运行这个文件\n\n注意：可用 which python3 指令查看 python3解释器在Linux中那个位置\n\n![image-20211010110906433](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110906433.png)\n\n\n\n\n\n第三步：在终端输入 ./ py文件名 即可运行这个py文件（只能是相对路径，且 . /还不能省略）\n\n![image-20211010110931185](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110931185.png)\n\n\n\n\n\n方法二：python指令运行 python文件步骤\n\n\n\n功能：利用指令在终端内运行py文件\n\n语法：python3 py文件   （其中 python3 是python解释器，也可以是其他版本的python解释器，如 python3.8等）\n\n\n\n快速代码体验\n\n第一步：直接利用指令 python3 py文件 运行这个文件，其中 python3 是解释器\n\n![image-20211010110946744](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110946744.png)\n\n\n\n\n未完待续.....\n","tags":["Linux实操"],"categories":["Linux实操"]},{"title":"Linux实操——Vim编辑器","url":"/2021/10/10/Linux实操——Vim编辑器/","content":"\n\n\n\n\n本文主讲：Linux系统中最常用的文本编辑器Vim的使用方法等....\n\n<!--more-->\n\n\n\n\n\n## VI编辑器\n\n\n\n目标：\n1：知道 vi 编辑器的三种基本工作模式\n2：掌握 vi 编辑器三种工作模式的按键\n3：掌握怎么转换 vi 编辑器的工作模式\n\n\n\n\n一：vi 编辑器的三种基本工作模式\n\n命令模式：打开文件默认进入命令模式，不管 vi 编辑器处于哪种工作模式，按下 Esc 键会立刻进入\n\n命令模式，命令模式可以对文件进行 移动光标、复制、删除操作\n\n\n\n\n\n命令模式下按键（移动光标）：\n\nH（high）：将光标移动至文本开头处\nL（low）：将光标移动至文本末尾处\nM（middle）：将光标移动至文本中间出\n^：将光标移动至光标所在行行首\n$：将光标移动至光标所在行行尾\n{ ：将光标向上移动一段\n} ：将光标向下移动一段\n\n\n\n![image-20211010110150682](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110150682.png)\n\n\n\n\n\n文本输入模式：在命令模式下，按下i、a、o 等键会进入文本输入模式，这个模式是用来编辑文件的文本输入模式下按键（文本插入）：\n\n\n\ni ：在命令模式下按下 i 键进入文本输入模式，输入的文本会出现在光标前一个字节处\n\n\n\nI：（大写的 i ）：在命令模式下按下 I 键进入文本输入模式，输入的文本会出现在光标所在行的最前面（行前）\n\n\n\na ：在命令模式下按下 a 键进入文本输入模式，输入的文本会出现在光标后一个字节处\n\n\n\nA：在命令模式下按下 A 键进入文本输入模式，输入的文本会出现在光标所在行的最后面\n\n\n\no：在命令模式下按下 o 键进入文本输入模式，输入的文本会出现在光标下一行\n\n\n\nO（大写的o）：在命令模式下按下 O 键进入文本输入模式，输入的文本会出现在光标上一行\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110150682.png)\n\n\n\n\n\n末行模式：在命令模式下（注意，必须是命令模式下）按下 ：键会进入末行模式，末行模式用来对文件进行保存、查找、替换的\n\n\n\n![image-20211010110222587](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110222587.png)\n\n\n\n\n\n\n\n二：怎么转换 vi 编辑器的工作模式\n\n\n\n如下图（打开文件默认进入 命令模式）\n\n![image-20211010110231302](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110231302.png)\n\n\n\n\n\n## Vim编辑器的操作\n\n\n\n目标：\n\n1：vim编辑器与vi编辑器区别\n2：能够使用 vim 编辑器 打开、创建一个文件\n3：在 vim 命令模式下使用指令 粘贴、复制、删除等操作\n4：在 vim 命令模式下使用指令 撤销、重复执行等操作\n5：在 vim 命令模式下使用指令 查找及替换字符操纵\n6：在 vim 编辑器末行模式下使用指令 查找替换 文本\n7：在 vim 编辑器末行模式下使用指令 保存文件\n\n\n\n\n\n\n\n一：vim编辑器与vi编辑器区别？\n\n\n\nvim编辑器是vi编辑器的升级版本，vim编辑器兼容vi编辑器的一切操作！！！\n\n\n\n\n\n二：利用vim编辑器 打开、创建、保存文件\n\n功能：打开（或者创建）一个文件，对文件进行编辑，最后保存文件内容\n\n语法：vi 要打开的文件名\n\n注意事项：如果 vi 指令后面的文件在系统中不存在则新建这个文件，存在则打开这个文件\n\n快速代码体验\n\n第一步：利用vi指令创建1.txt文件\n\n![image-20211010110301833](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110301833.png)\n\n\n\n第二步：对文件进行编辑、保存等操作\n\n![image-20211010110309363](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110309363.png)\n\n\n\n\n\n三：vim编辑器命令模式下删除、复制、粘贴等操作\n\n\n\n删除命令按键（命令模式下）：\n\n![image-20211010110317952](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110317952.png)\n\n\n\n\n\n复制、粘贴指令按键：\n\nyy：复制当前光标所在行内容\n\n2 yy ：复制当前所在行及下面的总共两行内容\n\np：在当前光标所在行下面一行粘贴复制的内容\n\n\n\n\n\n四：vim编辑器命令模式下撤销指令按键\n\n撤销命令按键：\n\n![image-20211010110400342](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110400342.png)\n\n\n\n\n\n重复上一次执行命令按键：\n\n![image-20211010110411801](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110411801.png)\n\n\n\n\n\n五：vim编辑器命令模式下查找、替换按键\n\n\n\n查找命令按键：在命令模式下 按下 / 键即可进行文本查找，语法为 / + 查找的文本 ，然后按下 n 键或者 N 键即可依次查看查找的内容\n\n\n\n替换命令按键：\n\n![image-20211010110427878](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110427878.png)\n\n\n\n六：在 vim 编辑器末行模式下使用指令 查找替换 文本\n\n![image-20211010110438789](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110438789.png)\n\n\n\n七：在 vim 编辑器末行模式下使用指令 保存文件\n\n![image-20211010110445330](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010110445330.png)\n\n\n\n\n未完待续.......\n\n​\t\t\t\n\n\n","tags":["Linux实操"],"categories":["Linux实操"]},{"title":"Linux实操——终端指令","url":"/2021/10/10/Linux实操——终端指令/","content":"\n\n\n\n\n本文主讲：常用的Linux终端指令，这些内容非常重要.....\n\n\n\n<!--more-->\n\n\n\n\n\n## Linux命令——显示文件和目录（路径）\n\n\n\n注意事项：在Linux终端中~代表家目录\n\n\n\n终端命令一：pwd指令\n\n功能：在终端输入指令pwd，显示当前工作的的路径（目录）\n快速代码体验\n\n\n\n![image-20211010102908855](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010102908855.png)\n\n\n\n\n\n\n\n\n终端命令二：tree指令【centos没有这个】\n\n功能：tree指令不加参数时，以树状图的方式显示当前工作文件夹下面的所有文件及文件夹内容\n快速代码体验\n\n![image-20211010102922782](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010102922782.png)\n\n\n\n\n\n终端命令三：ls指令\n\n功能：以列表的方式显示当前文件夹下面的所有可见文件及文件夹名称\n\n指令选项：ls - a （以列表的形式显示当前文件夹下所有的文件（可见和不可见）及文件夹名称）\n\n注意事项：在linxu中文件或者文件夹前面加点 . 代表这个文件为隐藏文件\n\n快速代码体验\n\n![image-20211010102945028](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010102945028.png)\n\n\n\n\n\n\n\n## Linux命令——显示详细信息\n\n\n\n一：终端中ls指令的 -l 选项功能\n\n功能：详细显示当前工作目录下的文件及目录（文件夹）信息\n快速代码体验\n\n![image-20211010102957109](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010102957109.png)\n\n\n\n\n\n\n二：终端ls指令的 -h 选项功能\n\n功能：选项 - h 配合选项 -l 以人性化的方式显示文件大小\n注意事项：终端指令的选项可以有多个也可以没有\n快速代码体验\n\n![image-20211010103005183](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103005183.png)\n\n\n\n\n\n硬链接数\n\n![image-20211010103013151](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103013151.png)\n\n\n\n\n\n\n\n## Linux命令——切换目录\n\n\n\n本课掌握：能够使用cd命令切换根目录、家目录、当前目录、上级目录等\n\n\n\n\n\n一：Linux指令——cd命令（切换目录）\n\n功能：在Linux中利用cd命令切换工作目录\n\n\n\n注意事项：\n\n1：在Linux中大小写敏感，即a文件夹与A文件夹是不同的\n2：cd指令后面如果什么都没写（没有选项和参数），默认回到家目录（主目录）\n3：cd指令后面可以写绝对路径也可以写相对路径\n4：相对路径是相对于某个路径的路径，绝对路径是从根目录开始写的路径\n\n\n\n\n\ncd指令的参数及其功能：\n\n1：指令 cd ~ 或者指令 cd 代表转换到家目录\n2：指令 cd .  代表当前目录\n3：指令 cd .. 代表切换到上级目录\n4：指令 cd - 代表切换到上次的目录，注意不是上级\n5：指令 cd ./a 代表切换到当前目录下的a目录，当然./也可以省略，代表进入当前目录下的a目录\n6：指令 cd ../b 代表切换到当前目录的上级的b目录\n\n\n\n快速代码体验\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103013151.png)\n\n\n\n\n\n\n\n## Linux命令——创建文件和文件夹\n\n\n\n\nLinux指令——mkdir（创建目录）\n\n功能：利用 mkdir 指令可以在Linux中创建指定文件夹\n指令选项：mkdir - p 的功能是递归创建文件夹\n快速代码体验\n\n![image-20211010103045233](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103045233.png)\n\n\n\n\n\nLinux指令——touch（创建文件）\n\n\n\n功能：利用 touch 指令可以在Linux中创建指定文件\n\n注意事项：\n\n1：可以利用 touch 指令创建一个或者多个文件，多个文件之间空格隔开\n\n2：touch指令后面可以是相对路径也可以是绝对路径用于创建文件\n\n\n\n快速代码体验\n\n![image-20211010103114072](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103114072.png)\n\n\n\n\n\nLinux指令——gedit（打开并编辑文件）\n\n功能：利用 gedit 指令打开指定文件并用于编辑\n\n\n\n注意事项：\n\n1：利用gedit指令可打开多个文件用于编辑\n\n2：gedit 指令后面的文件可以是相对路径也可以是绝对路径\n\n3：不是所有的Linux发行版本都支持gedit指令，比如CentOS就不支持\n\n快速代码体验\n\n![image-20211010103131153](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103131153.png)\n\n![image-20211010103138325](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103138325.png)\n\n\n\n\n\n\n## Linux命令——删除文件与文件夹\n\n\n\nLinux指令 —— rm （删除文件或目录）\n\n功能：在Ubuntu中利用 rm 指令可以删除指定文件或目录\n\n\n\n指令选项：\n\n文件删除选项\n1：rm 文件名   没有选项功能默认就是强制删除指定文件，没有任何提示，相当于 rm -f\n2：rm -i  文件名   功能是以人机交互的方式删除文件或目录，有提示信息3：rm -f  文件名   功能是强制删除指定的文件，没有任何的提示\n\n\n\n目录删除选项\n\n1：rm -r  目录名   意思是按照递归的方式删除指定目录，在利用rm指令删除目录的时候一定要书写选项 - r 否则会报错\n\n\n\n\n\n注意事项：\n\n1：rm 指令后面的文件可以是相对路径的也可以是绝对路径的\n\n2：在CentOS中 rm 指令是以人机交互的方式删除文件，相当于Ubuntu中的 rm -I\n\n\n\n快速代码体验（利用rm指令删除文件）\n\n\n\n![image-20211010103242969](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103242969.png)\n\n\n\n\n\n快速代码体验（利用rm删除指定目录）\n\n注意事项：在利用 rm 指令删除指定文件夹（目录）时，rm指令后一定要加上选项 -r 代表递归删除文件夹，不加 -r 会报错\n\n![image-20211010103251874](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103251874.png)\n\n\n\n\n\n\n\n## Linux命令——拷贝文件或目录\n\n\n\nLinux指令—— cp 拷贝文件与目录（文件夹）\n\n\n\n功能：利用 cp 指令可以实现对文件和文件夹的复制\n\n语法：cp 源文件路径  复制后的文件路径\n\n\n\n指令选项：\n\n\n\n文件拷贝选项\n\n1：cp -i  功能是人机交互式复制文件，如果目标路径有同名的文件则提示用户同名，是否覆盖\n2：cp -f 功能是强制复制，目标目录下存在同名文件，直接覆盖掉，不提示\n3：cp -v 功能是显示文件拷贝过程\n\n\n\n目录（文件夹）拷贝选项\n\n1：cp -r  功能是递归拷贝，在拷贝目录的时候必须加上 -r选项，否则会报错\n\t\t\t\n\n\n\n注意事项：\n\n1：如果目标文件夹内有同名的文件，则这个复制的文件将这个同名的文件覆盖掉\n2：在拷贝目录的时候，必须加上选项 -r 递归拷贝，否则会报错 \n\n\n快速代码体验（cp指令无选项复制文件）\n\n![image-20211010103332984](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103332984.png)\n\n\n\n\n\n（cp指令有选项复制）\n\n![image-20211010103342711](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103342711.png)\n\n\n\n\n\n快速代码体验（cp指令复制目录）\n\n![image-20211010103355140](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103355140.png)\n\n\n\n\n\n\n## Linux命令——移动（剪切）文件和目录\n\n\n\nLinux指令—— mv\n\n功能：快速实现文件及目录的移动、重命名\n语法：mv 源文件路径 目标文件路径\n\n\n\n选项：\n\n\n\n移动文件\n\n-i  ：交互式移动文件，如果目标目录存在同名文件，则给出提示是否覆盖掉同名文件 \n-f ：强制移动文件，无论目标目录是否有同名文件，都会进行强制移动，无任何提示\n-v：显示文件移动过程\n\n\n\n移动文件夹（目录）\n\n没有任何选项，无选项 -r\n\n\n\n\n\n注意事项：利用 mv 指令移动目录（文件夹）时，不需要加选项 -r 可直接移动也不会报错！！\n\n\n\n快速代码体验（无选项移动文件）\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103355140.png)\n\n\n\n（有选项移动文件）\n\n![image-20211010103432132](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103432132.png)\n\n\n\n\n\n（mv指令移动文件夹）\n注意事项：mv指令移动文件夹时不需要书写选项 -r 可直接移动，不报错\n\n![image-20211010103440133](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103440133.png)\n\n\n\n\n\n\n（利用 mv 指令重命名文件和目录）\n\n同理也可以重命名目录\n\n![image-20211010103449438](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103449438.png)\n\n\n\n\n\n\n\n\n## Linux命令——其他\n\n\n\n\n一：清屏指令——clear （快捷键 Ctrl + l）\n\n功能：清空终端所有的指令，其实是换了多次行，达到清屏的效果\n语法：clear 或者快捷键 Ctrl + l \n注意事项： l 为小写的  L键，不是大写的 i 键\n快速代码体验\n\n![image-20211010103507401](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103507401.png)\n\n\n\n\n\n\n二：自动补全按键—— Tab键\n\n功能：按下Tab键自动补全文件或者目录名称\n\n\n\n\n\n\n三：查看指令的路径指令——which\n\n功能：可以查看Linux终端指令在计算机根目录的具体位置\n快速代码体验\n\n\n\n![image-20211010103521948](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103521948.png)\n\n\n\n\n\n四：Linux终端小技巧\n\n技巧1：按住键盘的 ↑ ↓ 键可以快速在曾经输入的指令间切换\n技巧2：按住 Ctrl + Shift + “=”可快速增大终端界面字体大小\n技巧3：按住 Ctrl + “ - ”（等号旁边的按键）可快速缩小终端界面字体大小\n\n\n\n\n\n\n\n## Linux命令——日历、日期\n\n\n\n一：日历指令 —— cal\n\n功能：cal 无选项指令可以查看当前月份的日历\n\n\n\n指令选项：\n\n-3 ：功能是查看当前月份前一个月和后一个月这三个月份的日历\n-y：显示这一年的日历\n-j：把当前的时期按照一年中第多少天显示\n\t\n快速代码体验\n\n\n\n![image-20211010103540580](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103540580.png)\n\n\n\n\n\n\n日期指令 —— date \n\n功能：查看当前的日期，即年月日、时间\n语法：date\n\n指令参数\n\n![image-20211010103552250](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103552250.png)\n\n\n\n快速代码体验\n\n![image-20211010103600097](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103600097.png)\n\n\n\n\n\n## Linux命令——历史指令\n\n\n\n一：历史指令 —— history\n\n\n\n功能：利用 history 指令可查看在终端内曾经输入过的指令，并且进行编号\n\n指令参数：history 10 表示显示最近的十条历史指令\n\n调用历史指令：！历史指令编号  即可快速调用历史指令\n\n注意事项：历史指令保存在家目录中的 .bash_history 的隐藏文件中，可以用 gedit 进行查看\n\n\n\n快速代码体验\n\n![image-20211010103617328](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103617328.png)\n\n\n\n\n\n\n\n## Linux命令——查看与合并文件\n\n\n\n本课须知：利用 cat 指令 查看文件、连接多个文件查看内容\n\n\n\n8000.txt文件内容如下\n\n![image-20211010103631127](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103631127.png)\n\n4000.txt文件内容如下\n\n\n\n![image-20211010103642486](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103642486.png)\n\n\n\n\n\n\n\n查看文件、合并文件指令 —— cat \n\n\n\n功能：利用 cat 无选项指令可在终端查看文件内容，并且终端可以继续运行，这是 gedit 指令没办法比的\n\n指令选项：\n\n-n ：将文件内每一行（算上空白行）进行编号\n-b：将文件内的每一行数据（不算空白行）进行编号\n-s：如果两行数据之间有两行空白行，利用 -s 选项显示一行空白行\n\n\n\n\n\n注意事项：\n\n1：指令选项可以合并在一起写，比如说 -n -b 可以写成 -sb，效果是一样的\n\n2：cat 指令与 gedit 指令区别在 gedit打开文件出现窗口，且终端不能继续运行，cat 直接将文件内容打印在终端上，终端继续运行。\n\n\n\n快速代码体验\n\n![image-20211010103715953](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103715953.png)\n\n\n\n\n\n\n\ncat 指令连接多个文件查看内容\n\n功能：cat 指令后面可以连接多个文件一起查看内容，并且一起编号等\n快速代码体验\n\n![image-20211010103725517](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103725517.png)\n\n\n\n\n\n\n\n## Linux指令——分页查看文件内容\n\n\n\n目标：利用 more 指令分页查看文件内容\n\n\n\n\n\n分页查看文件内容指令 —— more\n\n功能：利用 cat 指令查看一个内容非常多的文件内容很不方便，这时候我们就要用到 more 指令分页查看文件内容了\n\n无选项语法：more 文件名\n\n指令参数：more   +num  文件名    表示从第num行开始分页显示文件内容（加号不能省略，必须有加号）\n\n\n\n指令选项：\n-p：先清空终端屏幕内容，在显示查看的文件内容\n-s：文件内容中有两行空白行按照一行空白行显示\n\n\n\n指令常用操作：\n\n回车键：按下回车键向下显示一行文件内容\n\n空格键：按下空格键向下显示一页（终端一屏）文件内容\n\nCtrl + b （b）：查看上一页内容\n\nCtrl + f （f）：查看下一页内容\n\nq键：退出\n\n​\t\t\t\t\n\n快速代码体验\n\n\n\n![image-20211010103755814](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103755814.png)\n\n\n\n\n\n\n## Linux常用命令——数据流、管道\n\n\n\n一：什么数据流？\n\n\n\n数据流分为输入流与输出流\n输入流：从键盘输入数据或者从文件读取数据到内存中\n输出流：将内存中的数据显示在屏幕（终端）上或者写入到一个文件中\n\n\n\n![image-20211010103810762](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103810762.png)\n\n\n\nLinux数据流的分类：标准输入流、标准输出流、标准错误输出流\n\n\n\n\n\n二：数据流重定向指令 ——  >\n\n\n\n使用背景：将输出在终端上的数据保存到文件内时，就用到了数据流重定向\n\n功能：数据流重定向是改变数据流的原输出方向（一般数据输出方向从屏幕显示改变为保存至文件内）\n\n指令：> 或者 >>（ >重定向的数据会覆盖文件内的数据，>>重定向的数据不会覆盖文件内容，追加在数据后面）\n\n数据流重定向图示\n\n![image-20211010103828252](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103828252.png)\n\n\n\n\n\n快速代码体验\n\n![image-20211010103835686](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103835686.png)\n\n\n\n\n\n管道指令—— | （多个Linux指令协同工作）\n\n\n\n功能：管道指令可以让多个Liux指令协同工作\n\n语法：指令1 | 指令2 | 指令3\n\n图解：指令1的输出信息相当于指令2的输入信息\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103850295.png)\n\n\n\n\n\n快速代码体验\n\n![image-20211010103915571](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103915571.png)\n\n\n\n\n\n\n\n\n\n## Linux指令——查看进程以及杀死进程\n\n\n\n\n\n一：Linux 指令如何查看当前指定项目的进程是否开启\n\n指令： ps -ef | grep 指定进程名\n\n![image-20211010103925314](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103925314.png)\n\n\n\n二：什么 Linux 指令可以杀死指定进程\n\n指令：kill -9 任务进程号\n\n![image-20211010103934270](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010103934270.png)\n\n\n\n\n\n## Linux指令 —— IP地址\n\n\n\n目标：\n\n1：掌握虚拟机网络设置两种模式的不同，NAT模式与桥接模式\n3：利用 ifconfig 指令查看主机的 IP 地址 \n4：利用 ping 指令查看两台计算机网络的连通性\n\n\n\n\n\n一：虚拟机的NAT模式与桥接模式在IP地址上有和不同\n\n答：NAT模式的IP地址与物理机的IP地址是一样的（共享IP），而桥接模式IP地址是与物理机不同的，因为它向物理机网段又重新要了一个IP地址\n\n\n\n\n\n桥接模式优缺点：\n\n优点：不需要任何设置虚拟机就可以和物理主机进行通信\n\n缺点：虚拟机需要占一个物理机真实网段的IP地址\n\n\n\n二：查看主机的IP地址指令 —— ifconfig\n\n功能：查看主机（虚拟机）的 IP 地址\n语法：ifconfig\n快速代码体验：\n\n![image-20211010104000076](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104000076.png)\n\n\n\n\n\n三：查看网络是否可达（可通信）指令—— ping\n\n\n\n功能：用于查看两个主机（同一个网段下）或者主机与网站之间是否可以进行通信（是否可达）的指令\n\n\n\n语法：\n主机与主机：ping 另一台主机的 ip 地址\n主机与网站：ping 网站名\n\n注意事项：两个IP地址是在同一个网段下，就是具有相同的网络号\n\n\n\n快速代码体验（主机与主机）\n\n![image-20211010104015954](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104015954.png)\n\n\n\n\n\n主机与网站的通信是否可达\n\n![image-20211010104027884](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104027884.png)\n\n\n\n\n\n\n知识提升：如何在Windows系统中查看IP地址\n\n答：进入终端输入指令 ipconfig 即可查看Window主机的IP地址\n\n快速代码体验\n\n![image-20211010104043272](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104043272.png)\n\n\n\n\n\n\n\n## Linux命令——建立链接文件\n\n\n\n本课须知：\n1：能够说出Linux文件的硬链接文件与软链接文件概念\n2：掌握 ln 命令创建硬链接与软链接\n3：掌握 ln -s 创建软链接\n\n\n\n\n一：文件软链接与硬链接概念\n\n\n\n文件软链接：给文件创建一个快捷方式，这个快捷方式指向文件名（文件内存地址名），从而打开文件，获取文件内容，软链接被删除对文件无影响，文件删除，则软链接失效，通过软链接可以更改源文件内容。\n\n\n\n文件硬链接：直接给源文件起了另外的（一个或多个）名字（文件内存地址多个名字），删除其中一个硬链接（名字）不会对文件造成影响，文件名字全部删除则文件删除，通过硬链接可以更改源文件内容\n\n\n\n图解\n\n![image-20211010104142436](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104142436.png)\n\n\n\n\n\n\n\n二：创建软链接指令 —— ln -s （文件快捷方式）\n\n\n\n功能：为文件创建快捷方式（软链接），软链接删除不会对源文件造成影响\n\n语法： ln -s  源文件 软链接文件\n\n快速代码体验\n\n注意事项：之所以软链接文件内容和源文件内容是一样的，是因为软链接（快捷方式）直接指向源文件\n\n\n\n![image-20211010104202776](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104202776.png)\n\n\n\n\n\n\n\n三 ：创建硬链接文件\n\n\n\n功能：为源文件起多个名字，点击其中一个名字就会打开这个文件，删除其中一个名字不会对文件产生影响，除非全部删除掉\n\n语法：ln 源文件名称 硬链接文件名称\n\n快速代码体验\n\n![image-20211010104230013](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104230013.png)\n\n\n\n\n## 文件软链接与文件硬链接区别\n\n\n\n一：文件软链接\n\n\n\n删除文件软链接对源文件的影响：不会产生影响\n\n![image-20211010104244612](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104244612.png)\n\n\n\n删除源文件对软链接文件（快捷方式）产生的影响：软链接文件失效\n\n![image-20211010104308997](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104308997.png)\n\n\n\n\n\n二：硬链接文件\n\n\n\n删除文件硬链接对源文件的影响：不产生影响\n\n![image-20211010104318242](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104318242.png)\n\n\n\n删除源文件对源文件的硬链接文件影响：不产生影响（因为只删除掉源文件其中一个名字，还有其他名字）\n\n![image-20211010104330892](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104330892.png)\n\n\n\n软链接与硬链接的区别：\n\n1：软链接可以对不存在的文件创建软链接文件，而硬链接不可以\n2：软链接可以对文件夹（目录）创建软链接文件，硬链接不可以\n\n\n\n\n\n\n## linux常用命令——文件搜索\n\n\n\n目标：\n1：掌握 grep 指令搜索文本文件内部的数据\n2：初步掌握grep指令的正则表达式\n3：掌握 find 指令在Ubuntu内搜索文件\n\n\n\n![image-20211010104355405](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104355405.png)\n\n\n\n一：文本文件内部数据查找指令 —— grep \n\n\n\n功能：grep 是强大的文本搜索指令，即 grep 指令可以对文本文件内特定数据进行查找，将查找的文本这一行的数据全都打印出来\n\n语法：grep  [-options]  “查找的文本”  文件名\n\n注意事项：利用 grep 指令搜索文本数据的时候，查找的文本最好用双引号或者单引号括起来\n\n\n\n指令选项：\n\n-i ：功能是不区分查找的文本大小写，大小写的文本内容全部都查找出来\n-n：功能是显示查找的文本数据在文件内的行号（第几行）\n-v：功能是取反，即打印文件中不包含这个文本数据（引号内的文本）的内容\n\n\n\n\n\ngrep指令的正则表达式图示\n\n![image-20211010104417091](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104417091.png)\n\n\n\n快速代码体验（grep指令无选项）\n\n![image-20211010104424560](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104424560.png)\n\n\n\n快速代码体验（grep有选项）\n\n![image-20211010104433434](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104433434.png)\n\n\n\n快速代码体验（grep指令正则表达式初体验）\n\n![image-20211010104441903](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104441903.png)\n\n\n\n\n\n\n\n二： 查找文件指令 —— find\n\n\n\n功能：在Linux操作系统的目录下查找符合条件的文件\n\n语法：\n\n1：find  文件目录 -name  文件名要求\n2： find  文件目录  -size  文件大小要求\n\t\t\n\n指令选项：\n\n-name：查找符合文件名的文件\n-size：查找符合文件大小的文件\n\n\n\n注意事项：文件大小 M 必须是大写\n\n\n\n快速代码体验（利用 -name 查找文件）\n\n![image-20211010104515493](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104515493.png)\n\n\n\n快速代码体验（-size 文件大小查找文件）\n\n![image-20211010104527177](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104527177.png)\n\n\n\n\n\n\n## Linux命令——归档、压缩文件\n\n\n\n目标：\n1：掌握归档和压缩的概念\n2：能够使用 tar 指令对文件进行归档压缩\n3：能够使用 tar 指令对文件进行解档、解压\n\t\n\n一：归档和压缩的概念\n\n\n\n压缩：压缩原理是将文件内相同的信息用一个字符代替，压缩对于文本类或数据类的文件有明显效果\n\n\n\n归档：归档是将一些文件存放在一起，形成一个包，便于保存和传输\n\n\n\n\n\n二：文件归档压缩、指令 —— tar\n\n\n\n功能：\n\n1：tar指令配上相应选项对文件归档且压缩一气呵成\n2：tar指令配上相应选项对文件解档且解压一气呵成\n\n\n\n\n\n语法（最常用）：\n\n\n\n文件归档压缩：tar [-options] 归档压缩文件名（后缀为.tar.gz） 需要归档的文件1  需要归档的文2\n文件解档解压：tar [-options] 归档文件 \n文件解档解压到指定目录： tar [-options] 归档文件名 -C 指定目录\n\n\n\n指令选项：\n\n-c ：生成归档文件，因此在归档的过程中 -c 选项必须有\n-v：显示文件归档解档过程，显示进度\n-f：指定档案文件名，因此选项 -f 在对文件归档与文件解档处理时必须有，告诉电脑处理哪个文件\n-x：对归档的文件进行解档\n-z：对归档文件进行压缩、对解档文件进行解压\n\n\n\n注意事项：\n\n1：对一些文件归档处理时，必须要有选项 -c -f    -c是生成归档文件，-f 是指定生成哪个归档文件名\n2：-f 选项一定要在选项最后，即在档案文件名前面的第一个选项，\n3：无论文件归档还是解档都要有 -f 选项\n4：Linux系统的归档文件是以 .tar 为后缀，归档压缩文件是以.tar.gz为后缀\n5：-z选项 可对归档文件进行压缩也可对解档文件进行解压\n\n\n\n\n\n\n快速代码体验（解档解压到当前目录下）\n\n\n\n![image-20211010104557635](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104557635.png)\n\n\n\n\n\n快速代码体验（解压解档到别的目录下）\n\n\n\n![image-20211010104610634](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104610634.png)\n\n\n\n\n\n\n## Linux常用命令——目录、文件压缩解压\n\n\n\n目录、文件压缩解压指令 —— zip/unzip\n\n功能：对目录或文件进行压缩解压\n\n\n\n语法：\n\n压缩（目录）：zip -r 压缩后文件名（后缀为.zip） 待压缩目录名\n\n压缩（文件）：zip 压缩文件名 待压缩文件名\n\n解压：unzip 待解压文件或目录名\n\n\n\n\n\n注意事项：.tar.gz压缩文件比.zip压缩文件更小，因此在Linux中.tar.gz压缩文件更常用\n\n\n\n快速代码体验（压缩解压目录）\n\n![image-20211010104635535](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104635535.png)\n\n\n\n\n\n\n\n## Linux命令——文件权限\n\n\n\n一：文件权限的含义\n\n\n\n详解：在Linux中文件权限由四种字符组成的9个字母构成，每三个字符一组，其中这四种字符有 r、w、x、- 这四种，r代表可读权限、w代表可写权限、x代表可执行权限（文件：直接运行 绿色 目录：可以打开）- 代表没有权限\n\n\n\n快速代码体验\n\n![image-20211010104652373](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104652373.png)\n\n\n\n\n\n二：字母 u、g、o 、a所代表的的含义\n\n\n\n字母u（user）：代表文件拥有者即文件用户权限\n\n字母g(group)：代表文件所属同组用户（与文件拥有者同组的用户）权限\n\n字母o(other)：代表其他用户权限\n\n字母a（all）：代表所有用户权限\n\n\n\n\n\n\n\n\n## Linux常用命令——权限修改\n\n\n\n目标：学会 chmod 指令的两种方法（字母法、数字法）修改文件权限\n\n\n\n\n\n一：chmod指令字母法修改文件权限\n\n功能：可以修改文件的权限\n\n文件权限用户：\n\nu：文件拥有者权限\n\ng：文件所属组的权限\n\no：其他用户权限\n\na：文件的所有用户权限\n\n\n\n\n\n文件权限设置：\n\n+：代表增加权限\n\n-：代表撤销权限\n\n=：代表设置权限\n\n\n\n\n\n文件权限：\n\nr：可读\n\nw：可写\n\nx：可执行（文件：可以运行 目录：可以打开）\n\n-：没有权限\n\n\n\nchmod指令语法：chmod 文件权限用户 文件权限设置 文件权限 待设置文件名\n\n语法示例： chmod u + x  1.txt （代表将1.txt文件的所属用户权限增加可执行权限）\n\n快速代码体验（增加权限）\n\n![image-20211010104730198](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104730198.png)\n\n\n\n快速代码体验（设置权限）\n\n![image-20211010104739332](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104739332.png)\n\n\n\n\n\n二：chmod数字法更改文件权限\n\n\n\n功能：chmod指令通过一系列数字即可改变文件权限\n\n数字所代表的文件权限：\n\n4：代表可读 r 权限\n\n2：代表可写 w 权限\n\n1：代表可执行 x 权限\n\n0：代表无权限 - 权限\n\n​\t\t\t\t\n\n指令语法：chmod  数字1数字2数字3  文件名 （其中数字1代表文件所属用户的权限数字累加和，一样道理数字2代表所属组用户，数字3代表其他用户权限数字累加和）\n\n快速代码体验（字母法与数字法对比）\n\n![image-20211010104800173](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104800173.png)\n\n\n\n\n\n## Linux常用命令——用户管理\n\n\n\n一：临时增加用户权限、切换超级管理员用户 —— sudo\n\nsudo用法：\n\n1：sudo 其他指令 （在其他指令前加上sudo即可临时提升我们的权限）\n\n2：sudo -s （即可默认切换超级管理员用户）\n\n\n\n\n\n\n快速代码体验\n\n注意事项：$符号代表普通用户，#符号代表超级管理员用户（root）\n\n![image-20211010104838338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104838338.png)\n\n\n\n\n\n二：切换用户指令—— su\n\n\n\n功能：切换用户从而获得更多权限\n语法：su 用户名\n\n\n\n注意事项：\n\n\n\n1：利用sudo -s 默认切换到 root 用户，需要输入普通用户的密码\n2：利用 su root 可切换到 root 用户，需要输入 root 用户密码\n\n\n\n快速代码体验\n\n![image-20211010104856352](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104856352.png)\n\n\n\n\n\n\n\n三：更改用户密码指令 —— passwd\n\n\n\n功能：利用 passwd 指令可更改用户（普通用户与root）的密码\n\n语法：\n\npasswd ：功能是更改当前用户密码\n\npasswd 普通用户名：这种用法是当你作为root用户时更改其他用户密码的时候\n\n\n\n\n\n\n快速代码体验\n\n![image-20211010104909879](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104909879.png)\n\n\n\n\n\n\n\n三：退出登录用户指令 —— exit \n\n\n\n功能：在Ubuntu终端中 exit 指令可退出登录用户，从而退出终端界面\n\n语法：exit\n\n\n\n注意事项：\n\n1：在Linux底层，对终端用户的保存方式为内存栈（井方式），即只能在一端存放或取走东西\n\n2：在终端运行中总共切换了几个用户就有几个用户保存进了内存栈，因此exit要执行几次才能退出终端\n\n\n\n快速代码体验\n\n![image-20211010104927083](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104927083.png)\n\n\n\n\n\n\n\n四：查看用户登录指令 —— who\n\n功能：查看Ubuntu系统终端中登录了哪几个用户\n\n语法：who\n\n指令选项：-q：功能是显示Ubuntu系统中登录了几个用户以及用户名\n\n\n\n快速代码体验\n\n![image-20211010104941424](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010104941424.png)\n\n\n\n\n\n\n\n\n## Linux命令 —— 关机、重启\n\n\n\n目标：\n1：掌握 shutdown 指令关闭计算机\n2：掌握 reboot 指令重新启动计算机\n\n\n\n\n一：关机指令 —— shutdown \n\n功能：按照一定条件关闭计算机\n\n语法：shutdown\n\n\n\n指令选项：\n\n-r ：配合相应参数可重新启动计算机，并通知其他在Ubuntu系统上登录的用户计算机即将重启\n\n-h：配合参数使用告诉计算机什么时候关机\n\n-c：取消关机\n\n\n\n\n指令参数：\n\n10：50       配合选项 -h 使用功能是告诉计算机在 10：50 进行关机，当然 -h 也可省略\n\n+10 ：配合选项 -h 使用功能是计算机在十分钟后关机，当然 -h 也可省略\n\nnow：配合选项 -h 使用 功能是现在、立刻马上进行关机，当然 -h 也可省略\n\n\n\n快速代码体验\n\n![image-20211010105015484](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105015484.png)\n\n\n\n\n\n\n二：重启指令 —— reboot\n\n功能：重启计算机（服务器）\n\n语法：reboot\n\n快速代码体验\n\n![image-20211010105024894](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105024894.png)\n\n\n\n\n\n\n\n\n## Linux命令——软件安装与卸载\n\n\n\n目标：\n\n1：了解Linux系统安装软件的三种方式\n2：掌握 sudo apt-get install 指令安装软件\n3：掌握 sudo apt-get remove 指令卸载软件\n\n\n\n\n\n\n\n一：Linux系统安装软件的三种方式\n\n\n\nMake install：安装源码包方式\n\ndeb包：相当于windows中的exe文件（但是与要下载很多依赖文件）、\n\napt-get install：简单粗暴安装（重点掌握）\n\n\n\n\n\n\n\n二：软件安装指令 —— apt-get install\n\n\n\n功能：简单粗暴安装软件，联网即可下载软件所需的所有包\n\n语法格式： sudo apt-get install  xxx\n\n\n\n注意事项：使用 apt-get 下载软件前要配置软件源（下载软件的网址）\n\n【重要】：怎么配置ubuntu中国软件源（软件下载速度快）与下载软件\n\n\n\n第一步：打开清华大学镜像软件站\n网址链接：https://mirrors.tuna.tsinghua.edu.cn/\n\n\n\n![image-20211010105135874](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105135874.png)\n\n\n\n第二步：滑到最下找到 ubuntu 点击问号进去\n\n![image-20211010105147104](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105147104.png)\n\n\n\n第三步：根据教程修改ubuntu软件镜像源\n\n![image-20211010105155010](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105155010.png)\n\n\n\n第四步：在ubuntu中配置成功后输入 sudo apt-get update 进行更新软件源\n\n![image-20211010105204699](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105204699.png)\n\n\n\n第五步：即可利用 sudo apt-get install 安装你想要的软件啦\n\n![image-20211010105213641](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105213641.png)\n\n\n\n\n\n三：软件卸载指令—— apt -get remove\n\n功能：卸载相应软件\n\n语法格式 sudo apt-get remove vim （卸载 vim 软件）\n\n快速代码体验\n\n![image-20211010105229913](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105229913.png)\n\n![image-20211010105240135](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105240135.png)\n\n\n\n\n\n## Linux命令——远程登录服务器 ssh\n\n\n\n目标：掌握 ssh 指令远程登录服务器\n\n\n\n\n\n一：服务器远程登录指令 —— ssh\n\n\n\n使用背景：我家在东北，然而我的服务器在海南，这时我们要远程操控服务器就要在自己的计算机利用ssh指令来远程登录服务器\n注意事项：在自己的计算机利用 ssh 指令登录服务器，需要在服务器上安装 ssh server 软件\n服务器安装 ssh server 软件指令：服务器终端输入 sudo apt-get install openssh-server 即可安装 ssh server 软件\n\n\n\n![image-20211010105259391](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105259391.png)\n\n\n\n\n\n远程登录服务器指令语法：在自己计算机中输入 ssh 服务器用户名@服务器IP地址（服务器IP地址一般都是IPV4的地址）即可远程登录服务器\n\n快速代码体验（windows计算机远程登录服务器）\n\n![image-20211010105309767](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105309767.png)\n\n\n\n\n\n\n\n\n## Linux命令—— scp远程拷贝（文件下载上传）\n\n\n\n目标：掌握 scp 指令进行文件的远程拷贝（上传与下载）\n\n\n\n一：远程文件拷贝（上传与下载）指令 —— scp\n\n\n\n使用背景\n\n1：将 windows 电脑中的文件上传至远程服务器\n2：将远程服务器上的文件下载到 windows 电脑上\n\n\n\n\n\n指令语法：\n\nwindows文件上传到服务器：scp 计算机中文件路径 服务器用户名@服务器IP地址：服务器保存这个文件的地址（例如 scp  E：\\yule\\2.jpg lamb@192.168.1.42：/home/lamb/ceshi/2.jpg）\n\n服务器文件下载到windows计算机：scp 服务器用户名@服务器IP地址：服务器文件目录 自己计算机保存这个文件的目录\n\n\n\n\n\n注意事项：\n\n1：使用scp远程拷贝文件需要在服务器上下载 ssh server 软件，可利用 sudo apt-get install openssh-server 下载\n\n2：无论是远程上传文件还是远程下载文件，注意 windows下的路径都不能带中文！\n\n3：远程拷贝文件夹需要在指令后面加上 -r 选项\n\n4：如果相对路径远程传输文件显示没有找到文件，一定要试试绝对路径传输文件！！！\n\n\n\n\n快速代码体验（远程上传文件）\n\n![image-20211010105347913](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105347913.png)\n\n\n\n\n\n快速代码体验（远程下载服务器文件）\n\n![image-20211010105358011](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010105358011.png)\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Linux实操"],"categories":["Linux实操"]},{"title":"Linux实操——基础知识","url":"/2021/10/10/Linux实操——基础知识/","content":"\n \n\n\n\n本文主讲：了解操作系统、Linux与Windows的区别等基础常识\n\n\n\n<!--more-->\n\n\n\n\n\n## 基本单词篇\n\n\n\n1：touch（触摸）\n2：edit（编辑）\n3：date（日期）\n4：calender（日历）\n5：Interactive（交互）\n6：binary（二进制）\n7：link（链接）\n8：soft（软）\n9：group（组）\n10：shutdown（关机、关掉）\n11：reboot（重启）\n12：percent（百分比）\n13：interval（间隔）\n14：host（主机）\n15：send（发送）\n16：port（端口）\n17：socket（插座）\n18：encode（编码）\n19：address（地址）\n20：decode（解码）\n21：ignore（忽略）\n22：strict（严格）\n23：bind（捆绑）\n24：broadcast（广播）\n25：connect（连接）\n26：client（客户端）\n27：headers（标头）\n28：content（内容）\n29：digit（数字）\n30：thread（线）\n31：target（目标）\n32：daemon（守护程序）\n33：lock（锁）\n34：mutex（互斥体）\n35：acquire（获取）\n36：release（释放）\n37：stack（栈）\n38：queue（队列）\n39：empty（空的）\n40：process（进程）\n41：multi（多）\n42：multiprocessing（多处理、多进程）\n43：alive（活着）\n44：tarmainate（终止）\n45：Empty（空的）\n46：pool（池）\n47：async（异步的）\n48：Manager（管理者）\n49：deque（双端队列）\n50：path（目录）\n51：rear（后）\n52：iterable（迭代器）\n53：Orderedlist（有序列表）\n54：greenlet（绿叶）\n55：switch（开关）\n56：gevent（发泄）→创建协程\n57：spawn（产卵）→为协程指派任务\n58：monkey（猴子）→猴子补丁模块\n59：patch（补丁）→破解所有用\n60：compile（编译）→创建正则类\n61：findall（找到所有）\n62：regex（正则表达式）\n63：buddy（伙伴）\n64：match（比赛）→re模块的一种方法\n65：create（新建）\n66：drop（删除）\n67：udpate（修改）\n68：delete（删除）\n69：insert（增加）\n70：select（选择）\n71：database（数据库）\n72：service（服务）\n73：decimal（小数）\n74：table（表）\n75：unsigned（无符号的）\n76：primary key（主键）\n77：auto_increment(自动增长)\n78：desc（描述）\n79：modify（修改）\n80：alter table（修改表）\n81：default（默认的）\n82：delete（删除）\n83：order by （排序）\n84：asc（升序）\n85：desc（降序）\n86：const（常量）\n87：final（也是定义常量）\n88：function（函数）\n89：round（圆形的）\n90：concat（连接）\n91：commit（犯罪）\n92：rollback（滚回）\n93：begin（开始）\n94：cursor（光标）\n95：fetch（拿来）\n96：execute（执行）\n97：htop（停止）\n98：quit（辞职）\n99：reload（重装）\n100：property（财产）\n\n\n\n\n\n\n## 了解操作系统\n\n\n\n一 ：什么是操作系统？\n\n答：简单来说，操作系统就是对上提供软件运行的支持，对下控制硬件设备的运行，没有安装操作系统的计算机称之为裸机。\n\n\n\n二：了解服务器和个人计算机的区别\n\n![image-20211010100051801](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100051801.png)\n\n\n\n\n\n三：不同领域的主流操作系统（用户从前到后）\n\n\n\n1 ：桌面操作系统：Windows、macOS、Linux\n2：服务器操作系统：Linux（免费，稳定，开源）、Windows Server（收费）\n3：嵌入式操作系统: Linux 、Wince\n4：移动端操作系统：Ios（unix）、Android（Linux）\n\n\n\n\n\n\n## Linux系统的发展史\n\n\n\n### 了解Linux系统的发展史\n\n![image-20211010100108511](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100108511.png)\n\n\n\n\n\n### Linux系统的内核和发行版本\n\n\n\n内核：内核是系统的心脏，它控制着系统的基本功能，决定了系统的性能和稳定性（Linux内核是由C语言编写的开源程序）\n\n\n\nLinux发行版本：Linux发行版本 = Linux内核 + 一套软件 + 软件使用手册 \n\n\n\nLinux常见的几种发行版本： CentOS、Redhat（红帽）、Ubuntu（乌班图）、Debian、ClearOS、Linux Mint、openSUSE、Arch\n\n\n\n\n\n### Linux系统的应用领域\n\n\n\n主流领域：服务器\n\n次要领域：嵌入式、个人桌面\n\n\n\n\n\n\n\n## Ubuntu界面介绍\n\n\n\n\n熟悉Linux发行版本Ubuntu的界面\n\n\n\n![image-20211010100132450](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100132450.png)\n\n\n\n\n\n## Linux的文件目录与Windows的差别\n\n\n\n一：Windows 文件存放位置表示方法\n\n![image-20211010100145377](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100145377.png)\n\n\n\n\n\n二：Linux的文件系统：Linux系统没有盘符概念，只有一个根目录 / (注意是反斜杠)\n\n![image-20211010100203356](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100203356.png)\n\n\n\n\n\n三：Linux家目录（点击Linux文件系统打开的目录）\n\n\n\n什么是家目录？ 家目录就是在根目录 / 里面的 home文件夹下 user内的文件目录，即 /home/user，其中user指的是用户名，我的是lamb\n\n\n\n图示\n\n![image-20211010100218555](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100218555.png)\n\n\n\n\n\n进入家目录流程\n\n\n\n![image-20211010100229665](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100229665.png)\n\n\n\n\n\n四：根目录下集几种常见的文件夹\n\n\n\nbin文件夹：用来存放一些二进制文件 \n\nhome文件夹：用户文件夹，用来进入家目录\n\netc文件夹：存放系统配置文件\n\nroot文件夹：超级管理员文件夹\n\n\n\n\n\n\n## Linux终端命令\n\n\n\n一：什么是终端？\n\n\n\n答：终端是软件控制台，在终端中输入指令可实现快速控制计算机\n\n\n\n二：Linux打开终端的三种方式\n\n\n\n1：收藏夹打开\n2：鼠标右键进入终端\n3：快捷键 Ctrl + Alt + t\n\n\n\n三：终端命令格式\n\n\n\n命令格式：command + [-options] +[parameter] 即 命令 + 选项 + 参数\n\n\n\n注意事项：\n\n\n\n1：选项和参数用中括号括起来了，代表书写终端命令时选项和参数可有可无\n\n2：怎么区分选项和参数呢？ 选项前面有横杠- 而参数前面没有横杠-\n\n\n\n快速代码体验\n\n![image-20211010100321272](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100321272.png)\n\n\n\n四：终端命令使用手册\n\n\n\n怎么进入终端命令使用手册？\n\n\n\n第一种方法：在终端里面的命令前面输入 man 即可进入命令帮助手册\n\n![image-20211010100336351](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100336351.png)\n\n\n\n第二种方法：在终端里面的命令后面输入--help 即可进入\n\n![image-20211010100344040](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100344040.png)\n\n\n\n\n\n第一种方法进入命令手册的一些操作图示（man codmand）\n\n\n\n![image-20211010100353198](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010100353198.png)\n\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n","tags":["Linux实操"],"categories":["Linux实操"]},{"title":"Python的有趣案例【第二期】","url":"/2021/10/10/Python的有趣案例【第二期】/","content":"\n\n\n\n\n\n\n本文主讲：如何通过Python实现系统性能定式监控....\n\n\n\n\n\n<!--more-->\n\n\n\n\n\n## 系统性能定时监控\n\n\n\n目标：\n1：掌握怎么利用指令安装python第三方库 pip\n2：掌握怎么利用 pip 指令安装 python第三方库\n3：掌握Linux中 --version指令的功能\n4：掌握 python 第三方 psutil库的功能\n5：掌握 python 第三方库 _datetime 库的功能\n6：注意：利用 open 打开文件写入数据时 不需要导入 os 模块！！！\n7：定时监控系统代码文件\n\n\n\n\n\n一：掌握怎么利用指令安装python第三方库 pip\n\n答：可利用指令 sudo apt-get install python3-pip进行安装\n\n\n\n\n\n二：掌握怎么利用 pip 安装 python 第三方库\n\n答：可利用指令 pip3 install 库名 进行安装\n\n\n\n\n\n三：Linux中 --version 指令作用\n\n答：查看软件以及包是否在Linux计算机中安装，并查看版本\n\n语法：软件名 --version\n\n快速代码体验\n\n![image-20211010094816279](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094816279.png)\n\n\n\n\n\n四：python第三方 psutil 库\n\n\n\n功能：对计算机的性能及内存进行监视（系统监控工具）\npsutil第三方库的方法：\n\n\n\n1：获取系统 cup 的信息\n\n`psutil.cup_times（）`：获取 cpu 的整体信息\n\n`psutil.cpu_count()`：获取 cup 内核数\n\n`psutil.cpu_percent()`：获取 cup 内核的使用率\n\n方法图示：\n\n![image-20211010094834959](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094834959.png)\n\n\n\n\n\n2：获取系统内存的信息\n\n`psutil.virtual_memory（）`：获取内存的整体信息（使用率，总内存、剩余内存）\n\n`psutil.virtual_memory（）.percent`：获取内存的使用率\n\n方法图示：\n\n![image-20211010094847594](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094847594.png)\n\n\n\n\n\n3：获取系统磁盘的信息\n\n`psutal.disk_partitions（）`：获取磁盘的分区信息\n\n`psutal.disk_usage（“/”）`：获取根目录的磁盘信息\n\n`psutal.disk_usage（“/”）.percent`：获取根目录磁盘的使用率\n\n方法图示：\n\n![image-20211010094902105](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094902105.png)\n\n\n\n\n\n4：获取系统网络的信息\n\n`psutil.net_io_counters（）`：获取网络总的I/O信息\n\n![image-20211010094912866](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094912866.png)\n\n\n\n\n\n5：获取开机时候的时间\n\n`psutil.boot_time（）`：获取系统开机时候的时间（开机距离1970年1月1日多少秒）\n\n\n\n\n\n\n\n五：第三方库 _datetime 功能\n\n\n\n功能：用于获取系统的日期和时间\n\n方法：`_datetime.datetime.now( )` 用来获取系统的当前时间\n\n快速代码体验\n\n![image-20211010094924685](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094924685.png)\n\n\n\n\n\n七：下面是定时监控系统代码截图\n\n![image-20211010094952945](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094952945.png)\n\n\n\n","tags":["Python有趣案例"],"categories":["Python有趣案例"]},{"title":"黑马程序员学Python--项目分析","url":"/2021/10/10/黑马程序员学Python——项目分析/","content":"\n\n\n\n\n本文主讲：在以后工作过程中一些注意事项.....\n\n\n\n<!--more-->\n\n\n\n\n\n## 工作中做项目注意事项\n\n\n\n注意事项：\n\n\n\n1：在面向对象编程项目中，一般一个角色（类）一个程序文件\n2：项目要有程序主文件，一般命名为main.py\n3：因为是面向对象编程，__main__主文件的代码一般就只有导入类等其他模块、利用类创建对象，调用类中的方法！！\n4：以上的项目文件要放在项目文件夹内（文件目录）\n\n\n\n实例分析：比如说有一个项目，要求有一个学员类对象，还有一个操作系统类对象，请分析这个实例要建立几个py文件\n\n答：三个py文件\n\n\n\n建立文件夹及文件流程\n\n第一步：建立项目文件夹（项目目录）\n\n![image-20211010094037185](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094037185.png)\n\n\n\n第二步：在目录文件内建立py文件\n\n![image-20211010094044309](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094044309.png)\n\n\n\n\n## eval函数\n\n\n\n你问我答：eval函数的功能是什么？\n\n\n\n答：将字符串类型的数据恢复成原来的数据类型\n\n\n\n快速代码体验\n\n![image-20211010094055786](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010094055786.png)\n\n\n\n黑马程序员教程完...","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——模块和包","url":"/2021/10/10/黑马程序员学Python——模块和包/","content":"\n\n\n\n\n\n\n本文主讲：在Python中如何导入包及其怎么制作包等等.....\n\n\n\n<!--more-->\n\n\n\n## 什么是模块？\n\n\n\n\n你问我答：什么是模块？\n\n答：在python中模块就是python文件，以 .py后缀结尾，导入模块其实就是导入这个py文件，在模块中（py文件）可定义函数、类以及变量等一切可执行的代码。\n\n\n\n例子：例如我们常用的random模块，其实就是开发人员写好了random的py文件，我们在装python的时候，将这些模块文件也安装了，所以我们可以调用这些模块（py文件）\n\n\n\n快速代码体验\n\n![image-20211010093023550](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093023550.png)\n\n\n\n\n\n## 导入模块的几种方法\n\n\n\n注意：利用import（导入模块的第一种方法）导入某个模块（py文件）就运行这个模块中的所有代码\n\n\n\n\n\n方法一：import 模块名\n\n功能：导入相应的模块（py文件）\n语法：\n```python\n\t\timport 模块名\n\t\t模块名 . 方法名（）\n```\n\n\n\n注意事项：\n\n1：这样导入的模块，在调用模块中的方法时，要在方法名前面加上模块名，例如random.randint (1,10)\n\n\n\n2：在python中有关于除法运算中返回的结果都是浮点数\n\n\n快速代码体验\n\n![image-20211010093044897](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093044897.png)\n\n\n\n\n\n方法二：from 模块名 import 方法名1，方法名2，方法名3………\n\n\n\n功能：导入相应模块的相应方法\n语法：\n\n```python\n\t\tfrom math import sqrt\n\t\tprint（sqrt（16））\n```\n\n\n\n注意事项：这种方法导入的模块，然后调用某个方法时，不需要在书写模块名\n\n\n\n快速代码体验\n\n![image-20211010093057209](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093057209.png)\n\n\n\n\n\n方法三：`from 模块名 import *`\n\n\n\n功能：导入这个模块中的所有方法\n语法：\n\n```python\n\t\tfrom 模块名 import *\n\t\tprint(sqrt(16))\n```\n\n\n\n注意事项：这样导入模块，在调用这个模块中的任何方法时都不需要再次书写模块名了\n\n\n\n快速代码体验\n\n![image-20211010093109143](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093109143.png)\n\n\n\n\n\n方法四：import 模块名 as 新的模块名（重写模块名）\n\n\n\n功能：导入一个模块并且将这个模块进行重命名\n语法：\n```python\n\t\timport 模块名 as 新的模块名\n\t\t新的模块名 . 方法名\n```\n\n\n\n快速代码体验\n\n![image-20211010093124454](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093124454.png)\n\n\n\n\n\n方法五：from 模块名 import 方法名 as 新的方法名（重写方法名）\n\n\n\n功能：导入某个模块中的某个方法，并且将这个方法进行重命名\n语法：\n```python\n\t\tfrom math import sqrt as newsqrt\n\t\tprint(newsqrt(16))\n```\n\n\n\n快速代码体验\n\n![image-20211010093136160](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093136160.png)\n\n\n\n\n\n\n\n\n## 制作模块\n\n\n\n注意：利用import（导入模块的第一种方法）导入某个模块（py文件）就运行这个模块中的所有代码\n\n\n\n一：制作模块（p340）\n\n\n\n功能：将一些工作中频繁使用的函数、类、变量等封装在一个py文件中，这样可以降低我们的工作量，简化代码，在python中，一个py文件就是一个模块，因此在制作模块的时候，模块（py文件）名称要符合标识符命名规则，并且模块名与方法名不要与python内置的函数、模块等重名，这是很重要的\n\n\n\n二：制作模块步骤\n\n\n\n第一步：定义模块，即新建一个py文件，名称符合标识符命名规则，在这个py文件中定义相应的函数、类、变量等\n\n![image-20211010093203282](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093203282.png)\n\n\n\n第二步：测试模块，即在模块（py文件）内运行定义的函数、类等，看是否可以正常运行\n\n![image-20211010093210353](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093210353.png)\n\n\n\n第三步：调用模块中的方法\n\n![image-20211010093217225](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093217225.png)\n\n\n\n\n\n\n## 制作模块及导入模块的注意事项\n\n\n\n注意事项：\n\n\n\n一：自己新制作的模块名称（py文件名）不要与python内置的模块重名，否则会导致内置的模块不可用\n\n![image-20211010093230742](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093230742.png)\n\n\n\n\n二：利用 from 模块名 import 方法名 导入一个方法的时候，如果这个模块里面有两个同名的方法名，调用的是后面的那个同名的方法\n\ntest模块中存在两个同名方法test1（）\n\n\n\n调用test模块中的同名方法，观看结果\n\n![image-20211010093243827](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093243827.png)\n\n\n\n\n\n三：利用 form 模块名 import 方法名 导入模块中一个方法的时候，如果在程序中有与模块中的方法名同名的函数，那么在调用这个方法的时候，调用的是后定义的函数或者后导入的那个方法。（谁在后面调用哪个函数或者模块方法）\n\n![image-20211010093254986](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093254986.png)\n\n\n\n对比代码\n\n![image-20211010093303443](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093303443.png)\n\n\n\n\n\n\n## 模块查找顺序\n\n\n\n当导入一个模块（py文件），python解释器查找这个模块位置的顺序如下\n\n\n\n第一：当前文件夹\n\n第二：如果不在当前目录，python则搜索在shell变量下PYTHONPATH下的每个目录\n\n第三：如果以上都找不到则找默认路径\n\n\n\n\n\n\n\n## __all__列表\n\n\n\n__all__列表\n\n\n\n功能：如果某个模块中存在__all__列表，那么在用 from 模块名 import * 导入模块的所有方法代码时，因为存在__all__列表，故只能导入__all__列表中同名的那些方法\n\n\n\n注意事项：__all__列表在导入模块方法为 from 模块名 import * 的时候才有效，其他两种方法不行\n\n\n\n语法：__all__ = [\"模块方法名1\"，“模块方法名2”，“模块方法名3”……….]\n\n\n\n快速代码体验\n\n\n\n模块代码\n\n![image-20211010093333826](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093333826.png)\n\n\n\n\n\n利用`from 模块名 import * `导入这个模块\n\n![image-20211010093341363](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093341363.png)\n\n\n\n\n\n## 了解包\n\n\n\n你问我答：什么是包？\n\n\n\n答：在python中，包就是一个文件夹，用来存放那些有联系的模块（py文件），在创建包（文件夹）的时候，会自动创建一个__init__ . py文件，作用是导入包相关\n\n\n\n\n\n## 制作包\n\n\n\npycharm制作包流程：在文件区右击 → 点击New → 选择Python Package → 为包取名 → 在包内创建有联系的模块（py文件）\n\n\n\n第一步：右击创建包\n\n![image-20211010093403031](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093403031.png)\n\n\n\n第二步：为包取名字\n\n![image-20211010093425368](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093425368.png)\n\n\n\n第三步：创建好的包自带__init__.py文件，用于导入包相关\n\n![image-20211010093432962](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093432962.png)\n\n\n\n第四步：在包内创建有联系的模块（py文件）\n\n![image-20211010093440971](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093440971.png)\n\n\n\n\n\n## 导入包的两种方法\n\n\n\n本节资料：\n\n包 newpackage 内模块1 my_module1.py 和模块2 my_module2.py 代码如下\n\n模块1 my_module1.py 代码\n\n![image-20211010093510132](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093510132.png)\n\n\n\n模块2 my_module2.py 代码\n\n![image-20211010093518247](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093518247.png)\n\n\n\n\n\n导入包的两种方法\n\n\n\n方法一：利用import进行包的导入\n\n\n\n功能：导入包内的模块，从而使用模块内的方法\n\n语法：\n\n```python\n\timport 包名 . 模块名\n\t包名 . 模块名 . 方法名\n```\n\n\n\n快速代码体验\n\n![image-20211010093536004](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093536004.png)\n\n\n\n\n\n方法二：利用 from 包名 import * 导入包内的模块\n\n\n\n功能：在包内的__init__.py文件内定义__all__列表，列表内存放需要导入的模块名\n\n\n\n语法：\n```python\n\t\tfrom 包名 import *\n\t\t模块名.方法名\n```\n\n\n\n注意事项：\n\n__init__.py文件内的__all__列表存放的数据（模块名）必须是包内有的模块名\n\t\t\n利用from 包名 import * 导入包的模块，必须在包内的__init__.py文件内设置__all__列表，控制允许导入的模块。（这点很重要）\n\n\n\n快速代码体验\n\n\n\n\n__init__.py文件内__all__列表存放的数据\n\n![image-20211010093550144](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093550144.png)\n\n\n\n用 from 包名 import * 导入newpackage包中特定的的模块\n\n![image-20211010093618276](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010093618276.png)\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——异常","url":"/2021/10/09/黑马程序员学Python——异常/","content":"\n\n\n\n\n\n\n本文主讲：在Python语句中出现的异常怎么解决.....\n\n\n\n<!--more-->\n\n\n\n\n\n## 了解异常\n\n\n\n什么是异常？\n\n答：程序在执行的时候，检查到了错误，即报错，解释器无法继续执行了，这就叫做“异常”\n\n\n\n异常语法的作用？\n\n答：当不确定某段代码是否存在异常时，就可使用异常语法，即尝试这段代码是否存在异常，如果存在异常则执行这段代码的替补代码，不存在异常则执行此代码\n\n\n\n\n\n\n\n## 异常语句写法\n\n\n\n异常语法\n\n\n\n异常语法功能：尝试某段代码是否异常，如果异常则执行这段代码的替补代码，不异常则执行这段代码\n\n语法：\n\n```python\n\t\ttry：\n\t\t\t尝试代码\n\t\texcept：\n\t\t\t替补代码\n```\n\n\n\n注意事项：try和except代码后面不要忘记加引号：\n\n\n\n异常语句优点：当某段代码异常时可以保证程序继续执行下去，而不是停止执行代码。\n\n\n\n快速代码体验（尝试以只读“r”模式打开文件，如果文件不存在则以只写模式\"w\"打开文件）\n\n\n\n![image-20211010091815107](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091815107.png)\n\n\n\n\n\n\n\n\n## 捕获异常\n\n\n\n捕获指定异常\n\n\n\n捕获指定异常成功条件：尝试代码异常类型和except后的指定异常类型一致，代表捕获异常成功，即执行except下面的代码，反之失败。\n\n\n\n语法：\n```python\n\t\ttry：\n\t\t\t尝试代码\n\t\texcept  指定异常类型：\n\t\t\t捕获异常成功执行的代码\n```\n\n\n注意事项：\n\n1：如果尝试代码的异常类型和except后面的异常类型不一致，则捕捉异常失败，即except下面的代码不执行\n2：异常语法try：下面的尝试代码必须只有一行，代表检测一行代码是否异常\n\n快速代码体验（捕获异常成功）\n\n![image-20211010091840474](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091840474.png)\n\n\n\n捕获异常失败代码\n\n\n\n![image-20211010091850621](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091850621.png)\n\n\n\n\n\n\n\n## 捕获多个异常\n\n\n\n捕获多个异常\n\n\n\n功能：不确定尝试代码的异常类型时，可使用捕获多个异常，增加捕获异常成功的概率\n\n\n\n语法：\n\n\n\n```python\n\t\ttry：\n\t\t\t尝试代码\n\t\texcept （异常类型1，异常类型2…….）：\n\t\t\t捕获异常成功执行的代码\n```\n\n\n\n注意事项：捕获异常成功条件为尝试代码的异常类型与except后面括号中其中一个异常类型相同即为捕获成功\n\n快速代码体验\n\n![image-20211010091911694](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091911694.png)\n\n\n\n\n\n\n\n## 捕获异常描述信息\n\n\n\n捕获异常描述信息\n\n![image-20211010091921294](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091921294.png)\n\n\n\n功能：捕获到尝试代码异常类型后，想要详细的查看尝试代码的异常之处可以捕获异常描述信息\n\n代码：\n\n```python\n\t\ttry ：\n\t\t\t尝试代码\n\t\texcept （异常类型1，异常类型2）as  result：\n\t\t\t捕获异常成功后执行的代码\n```\n\n\n\n注意事项：\n\n1：其中result是一个变量，用于存贮捕获到的异常描述信息，可以打印查看\n\n2：except下面缩进的代码是捕获异常成功后执行的代码\n\n\n\n快速代码体验\n\n![image-20211010091936063](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091936063.png)\n\n\n\n\n\n\n\n## 捕获所有异常\n\n\n\n### 了解Exception\n\n\n\n答：Exception是所有程序异常类的父类，即包含了所有程序异常类型，也就是说在异常语法中，except后面放上Exception就代表了无论尝试代码异常类型是什么，捕获异常都会成功哒。\n\n\n\n### 掌握捕获所有异常\n\n\n\n功能：在不知道尝试代码异常类型的时候，利用捕获所有异常，这样不管尝试代码异常类型是什么，都会捕获异常成功了！\n\n\n\n语法：\n```python\n\t\ttry：\n\t\t\t尝试代码\n\t\texcept Exception as result：\n\t\t\t捕获异常成功执行的代码\n```\n\n\n\n快速代码体验\n\n![image-20211010091953027](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010091953027.png)\n\n\n\n\n\n\n\n## 异常的else\n\n\n\n功能：当尝试代码没有异常的时候，执行else下方缩进的代码\n\n\n\n语法：\n\n\n\n```python\n\t\ttry：\n\t\t\t尝试代码\n\t\texcept Exception  as result：\n\t\t\t捕获异常成功后执行的代码\n\t\telse：\n\t\t\t尝试代码没有异常执行的代码\n```\n\n\n\n注意事项：else的缩进与try以及except是一样的\n\n\n\n快速代码体验\n\n![image-20211010092008544](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092008544.png)\n\n\n\n\n\n## 异常的finally\n\n\n\n功能：无论尝试代码有没有异常都要执行finally下方缩进的代码，比如说关闭文件\n\n\n\n语法：\n```python\n\t\ttry：\n\t\t\t尝试代码\n\t\texcept 异常类型 ：\n\t\t\t捕获异常成功执行的代码\n\t\tfinally：\n\t\t\t无论尝试代码有没有异常都要执行的代码\n```\n\n\n\n快速代码体验（文件打开关闭相关）\n\n![image-20211010092021471](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092021471.png)\n\n\n\n\n\n## 终端打开py文件\n\n你问我答：怎么在电脑终端打开py文件呢？\n\n\n\n答：请看下面步骤\n\n\n\n第一步：找到py文件的根目录\n\n![image-20211010092037035](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092037035.png)\n\n\n\n\n\n第二步：双击目录文件名\n\n![image-20211010092048021](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092048021.png)\n\n\n\n\n\n第三步：删除原有文字，输入cmd进入终端并且进入这个根目录\n\n![image-20211010092058365](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092058365.png)\n\n\n\n第四步：进入终端，输入根目录里的py文件名，在终端内打开这个py文件\n\n![image-20211010092125705](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092125705.png)\n\n\n\n\n\n## 异常的传递\n\n\n\n\n\n异常的传递（异常语法的嵌套）\n\n\n\n一：根据需求利用异常的传递完成代码\n\n\n\n需求：尝试以只读模式打开一个文件，如果出现异常，打印这个文件异常描述信息，如果可以打开这个文件，尝试读取这个文件中的内容。\n\n读取需求：尝试循环读取文件中的数据，循环一次读取一行，读取完成后间隔3秒将读取内容打印出来，如果读取出错告诉开发者读取出现异常！\n\n\n\n快速代码实现\n\n\n\n![image-20211010092155972](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211010092155972.png)\n\n\n\n\n\n## 自定义异常类\n\n\n\n\n下面请看教程黑马程序员（p330—p331）\n\n\n\n\n未完待续......\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——类和对象","url":"/2021/10/09/黑马程序员学Python——类和对象/","content":"\n\n\n\n\n本文主讲：Python面向对象编程中的创建类及其实例化对象等方法.....\n\n\n\n<!--more-->\n\n\n\n\n\n## 什么是面向对象？\n\n\n\n举一个例子，洗衣服有两种方法：第一种是手洗，第二种是洗衣机洗衣服，手洗特别麻烦，步骤特别多，而洗衣机洗衣服只需要一个洗衣机（事物），步骤少，特别简单。\n\n\n\n面向对象：简单来说面向对象就是创造事物（洗衣机），使用这个事物做事情（洗衣服）的过程\n\n\n\n面向对象优点：操作简单，简化代码，步骤少\n\n\n\n\n\n## 理解类和对象\n\n\n\n前面说了面向对象其实就是制作事物（洗衣机），使用这个事物做事情（洗衣服）的过程，流程图如下\n\n\n\n答：面向对象大致流程为  图纸→制作事物（洗衣机）→使用事物（洗衣服）\n\n\n\n在面向对象编程中有两个重要组成部分，那就是类和对象\n\n\n\n一：那什么是类和对象呢？他们之间有什么关系吗？\n\n\n\n类其实就是制作事物的图纸，对象就是制造的事物（洗衣机），因此类和对象的关系就是，类可以创建（实例化）对象\n\n\n\n快速代码体验\n\n\n\n![image-20211009163025917](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163025917.png)\n\n\n\n因此最后总结为面向对象编程流程：类→创建对象→对象做事情\n\n\n\n\n\n## 类和对象详解\n\n\n\n什么是类？\n\n答：类就是一些具有相同特征（属性）以及行为（方法）的事物统称，不是真实存在的。\n\n\n\n什么是对象？\n\n答：对象是根据类制造出来的事物，是真实存在的。注意现有类再有对象\n\n\n\n注意事项\n\n在以后的需求中，有几个不同种类对象就有几个类\n\n\n\n\n\n\n\n\n## 面向对象编程\n\n\n\n面向对象编程的流程：根据类（图纸）→创建对象（洗衣机）→利用对象做事情（洗衣服）\n\n\n\n注意事项：\n\n1：类名第一个字母要大写，符合大驼峰命名规则\n\n2：一个类中要有属性和方法（函数）\n\n3：类和对象是面向对象编程中重要的两部分。对象是根据类创建出来的，先有类再有对象\n\n4：一个类可以创建多个对象\n\n5：下面一整段代码就是面向对象编程的流程\n\n6：self指的是什么呢？self指的是利用类（图纸）创建对象的名字，下面代码中self就是m1对象名\n\n\n\n\n\n快速代码体验\n\n![image-20211009163108613](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163108613.png)\n\n\n\n理解self\n\n![image-20211009163116394](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163116394.png)\n\n\n\n\n\n## 魔法方法\n\n\n\n一：什么是魔法方法呢？\n\n\n\n答：魔法方法指代具有特殊功能的函数，一般这么写，_ _函数名_ _()\n\n\n\n二：魔法方法_ _init_ _( ) 初始化函数\n\n\n\n功能：在面向对象编程中给对象赋予一些与生俱来的属性（初始属性），即在类（图纸）中就设定好的属性\n\n\n\n语法：`def _ _init_ _(self)`\n\n\n\n注意事项：\n\n1：在利用类创建对象时，类中的_ _init_ _(self)方法是自动调用的，不需要手动调用\n\n2：self其实就是利用类创建的那个对象的名字，下面这段代码，self就代表car1这个对象名\n\n\n\n快速代码体验\n\n![image-20211009163203609](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163203609.png)\n\n\n\n\n\n三：魔法方法 _ _str_ _(self) 修改对象打印值函数\n\n\n\n功能：在类中没有定义_ _str_ _(self)方法打印类创建的对象时，打印的是这个对象的地址，如果定义了_ _str_ _(self)，打印对象时则打印这个方法的返回值，一般返回值是这个类或者对象的说明文档\n\n\n\n语法：\n```python\ndef _ _str_ _(self)：\n\t\t\treturn 返回值\n```\n\n\n\n快速代码体验\n\n\n\n![image-20211009163218373](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163218373.png)\n\n\n\n\n\n3.1 在类中没有定义_ _str_ _(self)方法时\n\n\n\n![image-20211009163228027](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163228027.png)\n\n\n\n3.2 类中定义了_ _str_ _(self)方法\n\n![image-20211009163238745](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163238745.png)\n\n\n\n\n\n四：魔法方法_ _del_ _(self)\n\n\n\n功能：当利用del删除利用类创建的对象时，python解释器会自动调用魔法方法_ _del_ _(self)，即打印方法下方的代码\n\n\n\n语法：\n```python\ndef _ _del_ _(self)：\n\t\t\t代码1\n```\n\n\n\n注意事项：当整个程序运行结束后，计算机会自动删除对象，释放内存。因此在不主动删除对象时，程序运行结束后，魔法方法_ _del_ _(self)也会自动调用\n\n\n\n快速代码体验\n\n![image-20211009163303966](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163303966.png)\n\n\n\n\n\n\n## 类属性的默认值\n\n\n\n### 怎么给类的属性添加默认值？注意事项是什么？\n\n\n\n答：直接在魔法方法_ _init_ _(self)下面初始化属性的位置给类的属性赋予默认值\n\n\n\n注意事项：如果类中有默认值属性，那么在创建对象时，不需要再传递默认值属性的值\n\n![image-20211009163321862](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163321862.png)\n\n\n\n\n\n## 新式类与旧式类\n\n\n\n什么是新式类与旧式类，他们两个之间代码有什么区别吗？\n\n\n\n答：新式类是在python解释器3.0以上类的书写方法，旧式类是python解释器2.0书写类的方法\n\n\n\n\n\n新式类代码(  括号里面的object默认是所有类的父类，叫基类或者顶类，其余的类都叫派生类 )：\n```python\n\t\tclass  类名（object）：\n\t\t\t代码1……..\n```\n\n\n\n旧式类代码：\n\n```python\n\t\tclass 类名：\n\t\t\t代码1….\n```\n\n\n\n## 面向对象进阶——继承\n\n\n\n一：体验继承\n\n\n\n继承：继承就是多个类之间的所属关系，子类默认继承父类的所有属性和方法\n\n\n\n注意事项：\n\n1：子类的括号里面填写的是要继承父类的名称\n\n2：利用子类创建对象时，括号里面不能写继承的父类\n\n\n\n快速代码体验：\n\n\n\n一：父类属性有默认值时（self.num = 1）\n\n![image-20211009163344803](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163344803.png)\n\n\n\n\n\n二：父类属性没有默认值时（self.num = num）\n\n![image-20211009163352153](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163352153.png)\n\n\n\n\n## 单继承\n\n\n\n单继承故事推进：比如说有一个老师傅会用古法秘方摊煎饼，因为年纪大了，要找到自己的唯一接班人，将自己的秘方传授给徒弟，因此这种一个徒弟被一个老师教的场景就可用单继承，也就是说，一个子类继承一个父类，换言之，独生子女继承父亲的财产。\n\n\n\n单继承快速代码体验：\n\n![image-20211009163401966](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163401966.png)\n\n\n\n## 多继承\n\n\n\n多继承故事推进：一个学徒想学习摊煎饼果子技术，因此先找了张师傅学习了摊煎饼果子技术，随后又找到赵师傅学习摊煎饼果子技术。这种一个子类继承多个父类的模式就叫做多继承。\n\n\n\n多继承：一个子类继承多个父类的属性和方法\n\n语法： `class 子类名（父类1，父类2）`\n\n注意事项：如果一个子类继承两个父类，这两个父类中有同名的属性和方法，则子类在创建对象调用父类的同名属性和方法时，默认调用第一个父类的同名属性和方法。\n\n\n\n快速代码体验\n\n![image-20211009163415404](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163415404.png)\n\n\n\n\n\n\n## 子类重写父类的同名属性和方法\n\n\n\n故事推进：一个学徒学习了一位老师傅摊煎饼果子的技术，这位学徒在这位老师傅的煎饼果子技术下研究出了全新的技术，这就是子类重写父类的同名属性和方法，换言之，一个子类继承了父类的属性和方法后，子类又重新定义了与父类同名的属性和方法。那么子类在创建对象时，调用属性和方法默认调用的是子类重写的属性和方法。\n\n\n\n子类重写父类的同名属性和方法（子类继承父类的属性和方法后，子类重写与父类同名的属性和方法）\n\n\n\n注意事项：用子类创建对象，并且调用子类中与父类同名的属性和方法，默认调用子类重写的同名属性和方法\n\n\n\n快速代码体验\n\n![image-20211009163434751](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163434751.png)\n\n\n\n\n\n## 子类调用父类中同名的属性与方法（下面super（）与这个功能一样）\n\n\n\n\n\n你问我答：子类继承了父类的同名属性和方法后，重写了父类的属性和方法，在利用子类创建对象调用属性和方法时，默认调用的是子类重写父类重名的属性和方法，那我们怎么调用父类中与子类重名的属性和方法呢？（p300集）\n\n\n\n答：在子类中对父类中同名的属性和方法进行封装（函数封装）  注意事项：在类中只要定义或者调用了函数，括号里面都要加上self，用于接收对象。\n\n\n\n实例：子类重写了父类同名的属性和方法后，子类在创建对象时默认调用的属性和方法默认是重写的属性和方法，我们想办法在子类创建对象时也可以调用父类的属性和方法\n\n\n\n重要代码截图：\n\n![image-20211009163446653](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163446653.png)\n\n\n\n\n\n## __mro__顺序\n\n\n\n功能：__mro__顺序用于快速查看某个类的父类有哪些，以及这些父类的层级关系\n\n语法：`子类 . __mro__`\n\n注意事项：所有父类都会默认继承基类（object）\n\n快速代码体验\n\n![image-20211009163457500](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163457500.png)\n\n\n\n\n\n## 类和对象的__dict__属性\n\n\n\n你问我答：类和对象的__dict__属性有什么功能？\n\n\n\n答：__dict__属性是类和类创建的对象（实例）所共有的属性，当类调用__dict__属性时，返回的结果是类中所有类属性和类方法（注意是类属性，不是实例属性）对应的字典，当类创建的对象调用__dict__属性时，返回的结果是实例属性和实例属性的值对应的字典\n\n\n\n快速代码体验\n\n\n\n![image-20211009163557829](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163557829.png)\n\n\n\n\n\n## 类的继承羔羊小结\n\n\n\n小结一：利用类创建对象，并且调用某个方法时，会在这个类里面寻找这个方法，如果这个类里面没有这个方法，就会按照__mro__顺序依次在父类中寻找这个方法，如果寻找到基类object依然没有找到这个方法，则程序报错，找到这个方法就调用这个方法。\n\n\n\n小结二：下面这段关于调用方法的程序为什么会报错？\n\n![image-20211009163612514](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163612514.png)\n\n\n\n报错分析：\n\n![image-20211009163619205](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163619205.png)\n\n\n\n纠正代码：\n\n![image-20211009163625867](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163625867.png)\n\n\n\n\n\n## 多层继承\n\n\n\n什么是多层继承？\n\n\n\n答：继承关系大于等于两种的叫多层继承！！\n\n\n\n多层继承代码演示\n\n![image-20211009163636877](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163636877.png)\n\n\n\n\n\n## super（）调用父类方法\n\n\n\n一：super（）的作用\n\n功能：利用super（）调用当前类的父类中的方法\n\n语法：\n\n1：super（）. 父类中函数名\n2：super（当前类名 ，self ）. 父类中函数名\n\n\n注意事项：两种super（）语法功能一样，因此工作时推荐使用第一种，简化代码\n\n快速代码体验\n\n\n\n1：super（当前类名，self）. 函数名\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163655650.png)\n\n\n\n2：super（）. 函数名\n\n![image-20211009163712985](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163712985.png)\n\n\n\n\n\n## 私有权限\n\n\n\n一：什么是私有权限？\n\n\n\n答：私有权限就是在继承的时候，不把设置为私有权限的属性和方法继承给子类，因为继承默认是继承父类的所有属性和方法\n\n\n\n二：定义私有属性和私有方法\n\n\n\n功能：将类中的属性和方法设置为私有，这样在继承的时候就不会将设置为私有属性和方法继承给子类了\n代码实现：在设置为私有属性和方法的前面加上两条_ _，这样就将属性和方法设置为私有的了\n\n快读代码体验：\n\n\n\n![image-20211009163737699](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163737699.png)\n\n\n\n\n\n## 子类获取和修改父类中的私有属性值！！\n\n\n\n一：怎么在子类中获取和修改父类的私有属性值？\n\n\n\n答：在父类中定义函数  get__私有属性名（） 用来子类获取私有属性值，在父类中定义函数  set__私有属性名（）用来子类修改私有属性名\n\n\n\n注意事项：一般这种情况应用于子类继承父类然后访问或者修改父类中的私有属性值，因为默认父类不把私有属性继承给子类\n\n\n\n快速代码体验（截图原因，没有展示子类继承父类后查看和修改父类的私有属性值）\n\n![image-20211009163754826](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163754826.png)\n\n\n\n\n\n\n## 面向对象编程三大特征（面试常考题目）\n\n\n\n特征一：封装\n\n1：将属性和方法写到类里面就是封装\n2：可以将类里面的属性和方法添加私有权限\n\n\n\n\n\n特征二：继承\n\n1：子类默认继承父类的所有属性和方法\n2：子类可以重写与父类同名的属性与方法，即子类可以拥有自己的属性和方法\n\n\n\n\n特征三：多态\n\n1：传入不同的对象，产生的结果不同\n\n\n\n\n\n\n\n## 了解多态\n\n\n\n什么是多态？\n\n\n\n多态定义：多态是一种使用对象的方式，定义多个子类后，继承相同父类并重写父类方法，调用不同子类创建的对象的相同父类方法，可以产生不同的结果。\n\n\n\n多态优点：调用灵活，有了多态更容易写出通用的代码\n\n\n\n注意事项：python多态并不必须依赖于继承关系，但是最好有继承关系\n\n\n\n多态步骤：\n\n1：定义父类，并书写公共方法\n2：定义多个不同子类继承相同父类，并重写父类公共方法，不同子类创建多个对象\n3：传入不同对象，调用相同的父类方法其结果不同（其实就是，不同子类创建不同对象，然后调用相同父类方法，结果不同）\n\t\t\n\n快速代码体验\n\n\n\n![image-20211009163827104](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163827104.png)\n\n\n\n\n\n\n\n## 类属性\n\n\n\n\n一：什么是类属性\n\n答：类属性就是类所有的属性，他被类所创建的所有对象拥有\n\n\n\n二：怎么设置类属性？\n\n答：在类里面直接书写代码 属性名 = 属性值 这就定义了类属性\n\n\n\n三：怎么访问类属性？\n\n答：直接利用类访问，或者利用类创建的实例也可以访问\n\n\n\n快速代码体验\n\n\n\n![image-20211009163843306](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163843306.png)\n\n\n\n\n\n\n\n## 怎么修改类属性\n\n\n\n一：怎么修改类属性？\n\n答：前面说过访问类属性有两种方法，一种是直接通过类名访问，另一种是通过类创建的对象访问，但是修改类属性方法只有一种方法，那就是通过类名来修改\n\n\n\n![image-20211009163855782](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163855782.png)\n\n\n\n二：利用类所创建的对象修改类属性为什么不可以？\n\n答：因为利用类创建的对象修改类属性不是真正的修改了类属性，而是生成这个对象的实例属性，并没有修改类属性\n\n![image-20211009163903894](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163903894.png)\n\n\n\n## 类方法\n\n\n\n一：什么是类方法？\n\n\n\n类方法特点：需要用装饰器@classmethod来标记类里面的函数，告诉外界这是类方法，被装饰器@classmethod标记的类方法第一个参数就是cls，代表当前类\n\n\n\n类方法语法：\n```python\n\t\t\t@classmethod\n\t\t\tdef  name（cls）：\n\t\t\t\t代码…..\n```\n\n\n\n二：类方法使用场景\n\n\n\n答：类方法一般和类属性配合使用，当要操作（访问、修改等）私有类属性和类属性的时候，定义类方法\n\n\n\n快速代码体验\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163918928.png)\n\n\n\n\n\n\n\n\n## 静态方法\n\n\n\n一：什么是静态方法？\n\n\n\n答：通过装饰器@staticmethod标识的函数就是静态方法，通过装饰器@staticmethod标识的函数是没有self以及cls形参的，其中self代表传入类创建的对象，cls代表传入当前类。\n\n\n\n静态方法也可以通过类访问，也可以通过对象来访问！！！\n\n\n\n二：静态方法使用场景\n\n\n\n答：当类中的方法（函数）不需要传递对象（self）以及类（cls）参数时，就可以定义静态方法\n\n\n\n\n\n三：静态方法优点\n\n答：取消不需要的参数传递（对象self以及类cls），可以节省内存，减少不必要的内存占用\n\n\n\n![image-20211009163949301](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009163949301.png)\n\n\n\n未完待续....\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——文件操作","url":"/2021/10/09/黑马程序员学Python——文件操作/","content":"\n\n\n\n\n本文主讲：文件与文件夹操作等...\n\n<!--more-->\n\n\n\n\n\n## 了解文件操作\n\n\n\n\n什么是文件操作呢？\n\n答：文件操作就是将数据存储起来，等到再次利用这些数据的时候，直接使用即可，不需要再次制作一份数据，省时省力。\n\n\n\n\n\n## 文件的基本操作\n\n\n\n文件操作步骤：\n\n1：打开文件\n2：读写文件内容操作\n3：关闭文件\n\n\n\n注意事项：文件操作步骤可以省略第二步，即文件只打开不作操作关闭\n\n\n\n一：打开文件（open（）函数）\n\n\n\n功能：在计算机中打开一个文件\n\n\n\n语法：`文件变量名 = open（“文件名”，“访问模式”）`以后代码中，文件变量名就代表这个文件了\n\n\n\n注意事项：\n\n1：文件名可以是相对路径也可以是绝对路径\n2：文件访问模式包括只读“r”，只写“w”，追加“a”等\n\n\n\n\n\n\n二：文件的基本操作（读取数据、写入数据、没有追加数据）\n\n功能：对文件进行读写等操作\n\n语法：`文件变量名 . write（“内容”）`     `文件变量名 . read（num）`等\n\n注意事项：文件变量名是利用open函数打开或创建的文件\n\n\n\n\n\n三：关闭文件（close（））\n功能：关闭打开的文件，释放计算机的内存空间\n语法：`文件变量名 . close（）`\n\n\n\n快速代码体验：\n\n![image-20211009155952519](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009155952519.png)\n\n\n\n\n注意事项：打开的文件有两种路径，一种是绝对路径，一种是相对路径\n\n\n\n\n\n## 文件基本访问模式（r、w、a）\n\n\n\n### 文件访问模式——“r”（只读）\n\n\n\n功能：读取目标文件中的内容\n\n语法：`文件名 = open（“目标文件名”，“r”）`\n\n\n\n注意事项：\n\n1：如果利用open打开的目标文件不存在且访问模式为“r”只读，则程序报错\n2：访问模式为只读时，执行write（）命令，程序会报错，因为只读不支持数据的写入操作\n\n\n\n快速代码体验：\n\n一：访问模式为只读，目标文件不存在时\n\n\n\n![image-20211009160046145](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160046145.png)\n\n\n\n二：访问模式为只读，对目标文件进行写入数据操作时\n\n![image-20211009160055210](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160055210.png)\n\n\n\n\n\n### 文件访问模式——“w”（只写）\n\n\n\n功能：将数据写入到目标文件中，并且覆盖掉目标文件中的原时数据\n\n语法：`文件变量名 = open（“目标文件名”，“w”）`\n\n注意事项：\n\n1：当利用open打开的目标文件不存在时，且文件访问模式为“w”（只写）时程序不报错，并新建这个目标文件\n2：当文件访问模式为“w”（只写）时，执行write（）命令，会覆盖目标文件中原始的数据\n\n\n\n快速代码体验：\n\n\n\n![image-20211009160108678](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160108678.png)\n\n\n\n\n\n### 文件访问模式——“a”（追加）\n\n\n\n功能：将数据追加到目标文件中，注意是追加，不会覆盖掉目标文件中的原始数据\n\n语法：`文件变量名 = open（“目标文件名”，“a”）`\n\n\n\n注意事项：\n\n1：当打开的目标文件不存在时，程序不会报错，会新建一个同名的文件\n2：当访问模式为“a”（追加）时，执行write（）命令，将数据写入目标文件中，且不会覆盖掉文件内的原始数据\n\n\n快速代码体验\n\n![image-20211009160120872](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160120872.png)\n\n\n\n### 文件访问模式是否可以省略的问题？\n\n\n\n答：文件访问模式是可以省略的，省略文件访问模式，文件的默认访问模式为“r”（只读）\n\n\n\n\n\n### 文件访问模式\n\n\n\n![image-20211009160134648](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160134648.png)\n\n\n\n\n\n注意事项：\n\n\n\n1：访问模式带b的代表以二进制模式打开一个文件（二进制模式支持文件内的任何数据类型，如文字，数字等）\n2：访问模式带+的代表这个文件支持读取和写入操作，注意同时支持读取和写入\n3：访问模式带b+代表以二进制模式打开这个文件，且支持读取与写入\n4：访问模式带r和w的文件光标会放在文件开头处，而带a（追加）的文件光标放在文件末尾\n5：访问模式r+与w+有什么区别呢？却别就是，r+打开的目标文件不存在会报错，w+则不会\n6：文件在写入数据的时候要求数据类型是字符串类型\n\n\n\n\n\n\n## 文件操作——读取文件\n\n\n\n\n\n![image-20211009160155115](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160155115.png)\n\n\n\n一：read（num）函数\n\n\n\n功能：读取目标文件中的数据，并且支持存储到变量中打印出来\n\n\n\n语法：`目标文件变量名 . read（num）`其中num代表读取文件中数据的字节数，可省略，省略即读取整个目标文件数据\n\n注意事项：假如一个文件内有20个字节的数据，第一次利用read（10）读取10个字节的数据后，文件的指针光标就会跑到10个字节的位置，再次调用read（10）就会读取文件内后10个字节的数据\n\n快速代码体验：\n\n\n\n![image-20211009160207632](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160207632.png)\n\n\n\n二：readlines（）函数\n\n\n\n功能：将目标文件中所有的数据按照行的样式打印出来并将数据存储到列表中，每一行数据就是一个列表元素\n\n语法：目标文件名 . readlines（）\n\n实例：利用readlines（）读取c--.txt这个文件内的数据\n\n![image-20211009160218323](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160218323.png)\n\n\n\n三：readline（）函数\n\n\n\n功能：每调用一次readline（）函数，读取目标文件的一行内容，调用两次则读取文件中两行内容\n\n语法：`文件变量名 . readline（）`\n\n快速代码体验：\n\n![image-20211009160228793](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160228793.png)\n\n\n\n\n注意：上面的代码忘记关闭文件操作了，这样有可能会造成计算机内存不足\n\n\n\n\n\n## 文件扩展访问模式（r+,w+,a+）\n\n\n\n### 一：访问模式 r+（读取与写入）\n\n\n\n功能：支持目标文件的读取与写入操作\n\n语法：`文件变量名 . open（“目标文件”，“r+”）`\n\n注意事项：\n\n\n\n1：当访问的目标文件不存在时，程序会报错，因为 r+遵循访问模式为 r （只读）的要求\n2：执行read（）文件操作时，会读取文件的数据，因为 r+ 的指针光标在文件开头处\n\n\n\n快速代码体验\n\n![image-20211009160250595](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160250595.png)\n\n\n\n\n\n### 访问模式 w+（读取与写入）\n\n\n\n功能：支持目标文件的读取与写入操作\n\n语法：`文件变量名 . open（“目标文件”，“w+”）`\n\n\n\n注意事项：\n\n1：当访问的目标文件不存在时，程序不会报错，会新建这个文件，因为 w+遵循访问模式为 w（只写）的要求\n\n2：执行read（）文件操作时，不会读取文件的数据，因为访问模式为w+或者w（只读）时，会清空目标文件的数据，因此读取不到数据，w+访问模式指针光标也在文件开头处\n\n\n\n快速代码体验\n\n![image-20211009160310988](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160310988.png)\n\n\n\n\n\n### 访问模式 a+（追加与写入）\n\n\n\n功能：支持目标文件的追加与读取操作\n\n语法：`文件变量名 . open（“目标文件”，“a+”）`\n\n注意事项：\n\n1：当访问的目标文件不存在时，程序不会报错，会新建这个文件，因为a+遵循访问模式为 a （追加）的要求\n\n2：执行read（）文件操作时，不会读取文件的数据，因为a+ 的指针光标在文件末尾处\n\n\n\n快速代码体验：\n\n\n\n![image-20211009160336824](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160336824.png)\n\n\n\n特别注意：以上有的代码在执行完文件操作时，没有将文件进行关闭，这样是万万不可以的。\n\n\n\n\n\n### 掌握文件访问模式rb以及ab的意思\n\n\n\n文件访问模式rb是支持以二进制的格式读取数据，wb是支持以二进制格式写入数据，计算机中的所有数据都是以二进制形式存放的，因此以二进制格式处理数据就是可以处理计算机的任何数据，如图片、音乐、影片等\n\n\n\n\n\n## seek（）函数\n\n\n\n### 一：理解seek（）函数\n\n\n\nseek（）函数功能：修改文件内的指针光标位置，从而改变数据的读取或者写入的位置\n\n语法：`文件对象名 . seek（指针偏移量，指针起始位置）`\n\n注意事项：\n\n1：指针偏移量不能小于0，可以为0\n\n2：指针起始位置参数有三个，分别是0、1、2 （0代表光标在文件开头，1代表在当前位置，2代表在文件末尾）\n\n\n\n​\t\t\t\n\n### 理解文件访问模式r+与a+的区别\n\n\n\n区别：\n\n1：当打开的目标文件不存在时，r+会程序报错，a+不会报错，会新建这个文件\n\n2：当执行read（）命令时r+的指针光标在文件开头处，a+的指针光标在文件末尾处\n\n​\t\n\n### 快速代码体验\n\n\n\n利用seek（）函数让文件访问模式为r+时，读取不到文件数据的情况\n\n![image-20211009160410922](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160410922.png)\n\n\n\n利用seek（）函数让文件访问模式为a+时，读取整个文件内的数据\n\n![image-20211009160418735](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160418735.png)\n\n\n\n## 文件的备份数据（重要）\n\n\n\n一：文件数据备份的步骤：\n\n1：接收用户需要备份的文件名\n\n1.1：利用input（）接收用户需要备份的文件夹名字\n1.2：文件名字要符合要求，带后缀且不能只有后缀例如 .txt\n\t\t\t\t\n\n​\t\t\n\n2：规划备份文件名\n\n2.1：利用rfind（）函数查找后缀的小数点 . 从而将原始文件名进行拆分，拆成后缀名以及文件名\n2.2：将拆分的两部分加入其他数据组合成新的备份文件名例如p++[备份].txt\n\t\t\t\t\n\n\n\n3：将源文件的数据写入到规划好的备份文件名内\n\n3.1：打开原始文件以及要备份的文件\n\n3.2：读取原文件夹内数据并写入到备份的文件夹内(利用rb文件访问模式读取数据，利用wb写入数据)\n\n3.3：关闭文件\n\n\n\n\n\n注意事项：\n\n1：规划文件备份名字的时候，要用到rfind（）函数查询小数点 . 将文件名的名字和后缀进行分离\n\n2：为什么要用rfind（）函数查找小数点 . 呢？，因为遇到这样的文件夹名字lala.txt.mp3  .mp3才是后缀名，所以要从右侧开始查找小数点\n\n3：读取文件数据和写入文件数据的时候要用rb以及wb这样计算机的任何数据都可以进行读取和写入操作了\n\t\t\t\n代码文件：\n\n\n\n![image-20211009160458432](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160458432.png)\n\n\n\n\n\n\n## 文件操作2（重命名、删除）\n\n\n\n注意事项：下面文件的操作，都要借助os模块完成，因此要先导入os模块\n\n\n\n在Python中，对文件以及文件夹进行操作（删除、重命名等）要借助os模块\n\n\n\n### 文件重命名操作 os.rename( )函数\n\n\n\n功能：对文件进行重命名\n\n语法：`os . rename(目标文件名，新文件名) `\n\n快速代码体验\n\n\n\n对文件进行重命名\n\n![image-20211009160524376](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160524376.png)\n\n\n\n\n\n### 文件删除操作\n\n\n\n功能：删除文件\n\n语法：`os . remove(目标文件名)`\n\n注意事项：remove（）函数只能删除文件，不能删除文件夹\n\n快速代码体验\n\n![image-20211009160534597](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160534597.png)\n\n\n\n### 获取当前文件的路径  getcwd（）函数\n\n\n\n功能：获取当前文件的路径\n\n语法：`os . getcwd（）`\n\n注意事项：getcwd（）只是用来获取当前文件路径的，不能获取其他文件路径\n\n快速代码体验\n\n![image-20211009160544749](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160544749.png)\n\n\n\n\n\n## 文件夹操作\n\n\n\n注意事项：下面文件夹的操作，都要借助os模块完成，因此要先导入os模块\n\n\n\n### 文件夹的创建函数  mkdir（）\n\n\n\n功能：创建文件夹\n\n语法：`os . mkdir(文件名)`\n\n快速代码体验\n\n![image-20211009160601095](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160601095.png)\n\n\n\n\n\n### 文件夹的删除 rmdir（）函数\n\n\n\n功能：删除目标文件夹\n\n语法：`os . rmdir（目标文件名）`\n\n快速代码体验\n\n![image-20211009160611500](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160611500.png)\n\n\n\n\n\n### 文件夹重命名 rename（）函数\n\n\n\n功能：对目标文件夹进行重命名\n\n语法：`os . rename(\"目标文件夹名字\"，“新文件夹名字”)`\n\n快速代码体验\n\n![image-20211009160621339](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160621339.png)\n\n\n\n\n\n### 更改默认路径 chdir（）函数（很重要）教程p261\n\n\n\n功能：修改默认路径，从而可以修改计算机中其他文件夹内的文件以及文件夹\n\n语法：`os . chdir（“目标文件夹的路径”）`\n\n\n\n注意事项：\n\n1：文件处理默认是在相对路径中，利用chdir（）可更改为其他路径\n\n2：通过chdir（）函数可以修改默认路径，从而可以修改计算机中其他文件或者文件夹\n\n\n\n快速代码体验：\n\n![image-20211009160636966](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160636966.png)\n\n\n\n\n\n### 获取文件夹内所有文件夹以及文件，并存储到一个列表中  listdir（）函数\n\n\n\n功能：获取一个文件夹内的所有文件夹以及文件，存储到一个列表中，一个文件或文件夹是一个列表元素\n\n语法：`列表变量名 = os . listdir（“目标文件名”）` ，其中目标文件名可以省略，及获取当前文件夹内所有文件\n\n\n\n快速代码体验：\n\n![image-20211009160650334](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160650334.png)\n\n\n\n\n\n### 判断一个路径是否存在！！！\n\n\n\n方法：\n```python\n\timport os\n\tos.path.exists（文件或者文件夹路径）\n```\n\n\n\n\n\n\n## 文件夹操作实例\n\n\n\n实例一：对表情包缩略图这个文件夹内的所有文件进行重命名，要求在文件名前面加上python\n\n\n\n表情包缩略图文件夹路径如下\n\n![image-20211009160704984](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160704984.png)\n\n\n\n快速代码体验\n\n![image-20211009160714167](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009160714167.png)\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——函数","url":"/2021/10/09/黑马程序员学Python——函数/","content":"\n\n\n\n\n本文主讲：函数的定义与调用、lambda表达式等.....\n\n\n\n\n\n<!--more-->\n\n\n\n## 了解函数\n\n\n\n\n函数是什么：函数就是将一段可以独立执行的代码整合到一个整体，并命名，在需要这段代码的位置直接调用这个整体的名称即。\n\n函数作用：所以函数在开发过程中，可以更高效的实现代码重用\n\n\n\n![image-20211009152945554](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009152945554.png)\n\n\n\n\n## 函数使用步骤\n\n\n\n读前须知：函数在定义的时候，函数体下面的代码不执行，调用的时候才执行\n\n\n\n第一步：定义函数\n```python\ndef 函数名（参数）：\n\t代码1\n\t代码2\n\t……….\n```\n\n\n\n第二步：调用函数\n\n函数名（参数）\n\n\n\n\n\n注意事项：\n\n1：函数必须先定义在调用\n2：函数名内的参数可有可无，论情况而定\n3：调用函数时，解释器回到定义函数体下方的缩进代码执行，执行完毕后回到调用函数代码处\n4：定义函数时，函数体下方缩进的代码不会被执行\n\n\n\n## 函数的参数\n\n\n\n读前须知：函数在定义的时候，函数体下面的代码不执行，调用的时候才执行\n\n\n\n函数的参数\n\n功能：让函数变得更加灵活，用户可以给出指定数据让函数进行数据处理\n\n\n\n语法：\n\n```python\ndef  函数名（形参）：\n\t\t代码1\n\t\t代码2\n\t\t…….\n```\n\n函数名（实参）\n\n\n\n实例：利用函数实现两个数据的相加，这两个数据是用户随意给出的\n\n快速代码体验\n\n\n\n![image-20211009153051083](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153051083.png)\n\n\n\n\n\n## 函数的返回值\n\n\n\n读前须知：函数在定义的时候，函数体下面的代码不执行，调用的时候才执行\n\n\n\n函数返回值\n\n功能：在函数中，如果需要函数返回结果数据就需要用到函数返回值了，返回值的值就是调用函数时函数的值\n注意事项：函数的返回值就像是在调用函数时将返回值赋值给调用函数\n\n\n\n语法：\n```python\ndef  buy（）：\n\t\treturn “烟”\n\t    print（buy（））\n```\n\n\n\nreturn返回值功能：\n\n1，返回函数的结果数据\n2，return具有退出函数功能，即调用函数时，在函数体内return下方的所有代码不执行\n\t\t\t\t\n实例：用户输入两个数据值，分别为6和8，利用函数求和并且返回和的值\n\n快速代码体验\n\n\n\n![image-20211009153116770](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153116770.png)\n\n\n\n## 函数的说明文档\n\n\n\n函数的说明文档\n\n功能：快速查看定义的函数功能以及其程序员给出的解释\n\n语法1(说明文档的书写)：\n```python\n\t def  函数名（参数）：\n\t\t“”“函数说明文档”“”\n\t\t代码1\n\t\t代码2\n\t\t…….\n```\n\n语法2（函数说明文档的查看）：利用` help（查看的函数名）` \n\n\n\n注意事项：\n\n1，函数的说明文档只能书写在定义函数的第一行，采用多行注释的格式\n2，利用 help（查看的函数名）查看函数的说明文档时，查看的函数名书写不要带括号\n\n\n\n快速代码体验\n\n\n\n![image-20211009153202547](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153202547.png)\n\n\n\n函数说明文档的高级写法（多行注释中间敲回车）：\n\n快速代码体验\n\n\n\n![image-20211009153215807](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153215807.png)\n\n\n\n\n\n## 函数的嵌套\n\n\n\n读前须知：函数在定义的时候，函数体下面的代码不执行，调用的时候才执行\n\n\n\n什么是函数的嵌套？\n\n答：函数的嵌套就是在定义函数下方缩进的代码中调用另外一个函数\n\n\n\n函数嵌套功能：简化代码\n\n\n\n快速代码体验\n\n\n\n![image-20211009153237980](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153237980.png)\n\n\n\n\n\n函数嵌套例题\n\n\n\n例题1：利用函数的嵌套打印多条横杠 ---------------- 用户要求打印几条，就要打印几条\n\n\n\n步骤：\n第一步，先定义一个函数打印一条横杠\n第二步，在定义另外一个函数，要求有形参（形参是用户要求打印的条数）\n第三步：利用形参以及循环调用函数打印多条横杠\n\n\n\n快速代码演示\n\n\n\n![image-20211009153254974](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153254974.png)\n\n\n\n例题2：利用函数的嵌套求解三个数据和的平均值\n\n\n\n结题步骤：\n\n1，先定义一个函数用来求解三个数据的和\n2，在定义一个函数，函数内部嵌套上面定义的函数，用来求解三个数据的平均数\n3，最后调用后面的函数来打印三个数据的平均值\n\t\t\n快速代码体验\n\n\n\n![image-20211009153307265](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153307265.png)\n\n\n\n\n\n## 函数进阶：变量作用域\n\n\n\n读前须知：函数在定义的时候，函数体下面的代码不执行，调用函数的时候才执行\n\n\n\n什么是局部变量以及全局变量呢？\n\n\n\n答：局部变量就是定义在函数体内部的变量，函数调用完成后则销毁这个变量，当外界访问此变量时会报错（作用范围是局部）\n\n全局变量就是定义在函数体外部的变量，在任何位置都可以进行访问 （作用范围全局）\n\n\n\n快速代码体验（局部变量）\n\n\n\n![image-20211009153331268](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153331268.png)\n\n\n\n快速代码体验（全局变量）\n\n![image-20211009153341992](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153341992.png)\n\n\n\n怎么在函数内部修改全局变量呢？\n\n\n\n答：利用 global 在函数内部声明变量为全局变量后，在进行更改即可\n\n\n\n快速代码体验：\n\n\n\n![image-20211009153351596](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153351596.png)\n\n\n\n\n\n## 函数返回值（多个返回值）\n\n\n\n读前须知：定义函数的时候，函数体下方的代码不执行，调用该函数的时候，函数体下方的代码才执行\n\n\n\n函数返回多个返回值的错误代码演示以及正确代码演示\n\n\n\n错误代码演示\n\n\n\n![image-20211009153402255](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153402255.png)\n\n\n\n正确代码演示\n\n![image-20211009153411600](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153411600.png)\n\n\n\n函数多个返回值注意事项：\n\n1：函数多个返回值是在return后面写多个数据，而不是在函数内部写多个return\n\n\n2：return后面书写的多个数据，默认返回格式为元组，当然也可以是列表、字典，需用户手动更改格式\n\n\n\n\n\n\n## 函数的参数（四种形式）\n\n\n\n\n\n函数参数第一种形式：位置参数\n\n位置参数详解：定义函数的形参以及调用函数的实参他们的意思以及位置是一一对应的\n\n注意事项：形参与实参相互之间传递数据时，形参以及实参的位置和顺序及数量要一致\n\n快速代码体验（name对应TOM，age对应20，gender对应男）\n\n![image-20211009153428240](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153428240.png)\n\n\n\n\n\n函数参数第二种形式：关键字参数\n\n关键词参数详解：调用函数的实参利用赋值的形式将实参值传递给形参（关键字参数不在乎位置）\n\n注意事项：如果在函数调用的时候，有位置参数，那么位置参数的位置一定要在关键字参数前面\n\n快速代码体验\n\n![image-20211009153438023](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153438023.png)\n\n\n\n\n\n函数参数第三种形式：缺省参数（默认值参数）\n\n注意事项：\n\n\n\n1，如果在定义函数时给形参赋值了默认值，但在调用函数的时候，又给形参赋了另外值，则这个形参值为另外值\n\n\n\n2，所有位置参数都要在缺省参数前面（包括函数定义以及调用）\n\n快速代码体验\n\n\n\n![image-20211009153450140](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153450140.png)\n\n\n\n\n\n\n\n函数参数第四种形式：不定长参数（包裹位置参数，包裹关键字参数）\n\n\n\n应用场景：调用函数时不确定传递参数的个数时候用到的方法（参数个数可以是0也可以是其他数）\n\n\n\n包裹位置参数语法：\n```python\n\t\t\t\tdef  函数名（*args）：\n\t\t\t\t\tprint（args）\n\t\t\t\t函数名（数据1，数据2，数据3，………）\n\t\t\t\t函数名（）\n```\n\n\n\n快速代码体验（包裹位置参数）\n\n\n\n![image-20211009153503371](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153503371.png)\n\n\n\n\n\n\n包裹关键字参数语法：\n```python\n\t\t\t\t\tdef 函数名（**kwargs）：\n\t\t\t\t\t\tprint（kwargs）\n\t\t\t\t\t函数名（name = “TOM”，age = 20，……..）\n\t\t\t\t\t函数名（）\n```\n\n\n\n快速代码体验（包裹关键字参数）\n\n\n\n![image-20211009153512794](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153512794.png)\n\n\n\n\n注意事项：\n\n1：无论是包裹位置参数还是包裹关键字参数，都是一个组包的过程\n2：包裹位置参数在调用函数打印数据的时候，参数数据是存放在元组中的\n3：包裹关键字参数在调用函数打印数据的时候，参数数据是存放在字典中的\n\n\n\n\n\n## 拆包（元组与字典）\n\n\n\n### 元组的拆包\n\n\n\n功能：将元组进行拆分，分解成独立的数据（元组内有几个数据，就用几个变量来接收，这就是拆包）\n\n语法：\n\n```python\n\t\tdef package（）：\n\t\t\treturn 1，2\n\t\tnum1，num2 = package（）\n\t\tprint（num1）\n\t\tprint（num2）\n```\n\n\n\n快速体验元组的拆包\n\n\n\n![image-20211009153534176](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153534176.png)\n\n\n\n\n\n### 字典的拆包\n\n\n\n字典拆包详解：字典拆包就是将字典内所有键赋值给变量（提取字典中所有的键，有几个键，就要用几个变量接收）\n\n注意事项：字典中有几个键，就用几个变量来接收键\n\n语法：\n\n```python\n\t\tdict1 = {“name”：“TOM”，“age”：21}\n\t\tkey1 ，key2 = dict1\n```\n\n\n\n快速上机体验\n\n![image-20211009153550964](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153550964.png)\n\n\n\n\n\n## 交换两个变量的值\n\n\n\n方法一：定义中间变量法\n快速代码体验\n\n![image-20211009153603174](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153603174.png)\n\n\n\n\n\n方法二：互转法（更简单，代码量更少，工作时推荐这种方法）\n语法：a , b = b , a\n\n![image-20211009153610278](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153610278.png)\n\n\n\n\n\n\n\n## 引用（id）\n\n\n\n了解应用（id）\n\n在python中，值（数据）是靠引用来传递的\n\n理解引用：计算机内存是用来存放数据的，引用就像是内存的地址门牌号，引用是一个十进制的值（引用粗暴理解就是变量名）\n\n语法：利用 id（变量名）来求引用，引用是一个十进制数\n\n图解：\n\n![image-20211009153704353](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153704353.png)\n\n\n\n注意事项：\n\n1，如果两个不可变类型变量的引用（id）是一样的，那么说明这两个变量的值是相同的\n\n2，int是不可变类型！！\n\n\n\n不可变类型（int）引用代码体验\n\n\n\n![image-20211009153722163](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153722163.png)\n\n\n\n可变数据类型（list）引用代码体验\n\n\n\n![image-20211009153729548](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153729548.png)\n\n\n\n\n\n\n## 可变数据类型与不可变数据类型\n\n\n\n\n\n可变数据类型如下：\n\n1，列表\n2，字典\n3，集合\n\n\n\n\n\n不可变数据类型如下：\n\n1，整形（int）\n2，浮点型（float）\n3，字符串\n4，元组\n\n\n\n\n\n\n\n可变类型和不可变类型本质就是变量存储的数据发生改变时，内存是否开辟出新的内存空间存储改变后的数据，如果开辟了则是不可变数据类型，没有开辟就是可变数据类型\n\n\n\n\n\n图解（不可变数据类型）：\n\n\n\n![image-20211009153751316](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153751316.png)\n\n\n\n图解（可变数据类型）：\n\n\n\n![image-20211009153800035](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153800035.png)\n\n\n\n\n\n## 递归（重要！！）\n\n\n\n### 什么是递归？（教程223p）\n\n\n\n答：递归特点\n\n1，递归就是，定义函数的时候，函数体内部再调用函数自身（函数内部自己调用自己）\n2，递归必须要有出口\n3，注意函数返回值的位置是在调用函数时（就相当于把返回值赋值给调用函数语句）\n\t\t\t\n### 递归应用场景\n\n\n\n1，遍历一个文件夹下所有文件时，会利用递归\n2，人工智能算法离不开递归，比如说快速排序\n\n​\t\t\t\t\n\n### 利用递归实现数据1到6的相加之和\n\n![image-20211009153911209](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153911209.png)\n\n\n\n### 利用递归函数实现1到100累加的和\n\n![image-20211009153918309](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153918309.png)\n\n\n\n递归流程\n\n\n\n![image-20211009153926273](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153926273.png)\n\n\n\n\n\n递归没有设置出口的情况：\n\n\n\n最大递归深度不同计算机数值不同，一般为（990——1000）\n\n![image-20211009153935578](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009153935578.png)\n\n\n\n\n\n## lambda表达式（重要）\n\n\n\nlambda表达式（匿名函数）\n\n\n\n功能：简化函数代码\n\n应用场景：定义函数时，函数只有一个返回值且函数体内部只有一行代码，就可用lambda表达式简化代码\n\n\n\n语法：\n第一种形式：变量名 =  lambda 参数的形参 ：返回值  \n第二种形式：（ lambda 参数的形参 ：返回值） （参数的实参）\n第二种形式可直接用print（（ lambda 参数的形参 ：返回值） （参数的实参））打印\n\n\n\n注意事项：\n\n1，同等情况下，书写函数代码比书写lambda表达式占用内存高\n2，lambda表达式又叫匿名函数，因此打印返回值时，变量名要加括号例如print（fun（））否则打印lambda地址\n3，lambda表达式的参数可以是多个，也可以没有\n4，lambda表达式只能有一个返回值\n\n\n\n快速代码体验（计算两个数据的和）第一种语法：\n\n![image-20211009154001553](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154001553.png)\n\n\n\n\n\n第二种语法：\n\n![image-20211009154008142](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154008142.png)\n\n\n\n\n\n\n## lambda表达式参数（重要）\n\n\n\n第一种：无参数\n语法：`变量名 = lambda ： 返回值`\n快速代码体验\n\n![image-20211009154054361](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154054361.png)\n\n\n\n\n\n第二种：一个参数\n语法：`变量名 = lambda 参数的形参  ：返回值`\n快速代码体验\n\n![image-20211009154104878](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154104878.png)\n\n\n\n\n\n第三种：缺省参数\n语法：`变量名 = lambda b, c, d = 100 : b + c + d`\n注意事项：缺省参数 d = 100 无论是在定义lambda表达式，还是调用都要放在参数的最后面赋默认值\n快速代码体验\n\n![image-20211009154113674](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154113674.png)\n\n\n\n第四种：不定长参数——包裹位置参\n\n应用场景：在不确定参数的个数时使用\n\n语法：`变量名 = lambda *args ：args`\n\n注意事项：包裹位置参数返回值的数据类型为元组\n\n快速代码体验\n\n![image-20211009154126590](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154126590.png)\n\n\n\n不定长参数——包裹关键字参数\n\n语法：`量名 = lambda **kwargs ：kwargs`\n\n注意事项：包裹关键字参数返回值的数据类型为字典\n\n快速代码体验\n\n![image-20211009154135127](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154135127.png)\n\n\n\n\n\n## lambda表达式应用（重要）\n\n\n\n应用一：带判断的lambda表达式\n\n功能：判断lambda的参数是否满足某些条件，从而返回一个值\n\n语法：`量名 = lambda 形参1，形参2 ：形参1 if 形参1 > 形参2 else 形参2`\n\n其中  形参1 if 形参1 > 形参2 else 形参2 是三目运算符，意思为如果形参1大于形参2则返回值为形参1，反之返回形参2\n\n实例：判断两个数据a，b的大小，a大于b返回值为a，a小于b返回值为b\n\n![image-20211009154151562](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154151562.png)\n\n\n\n\n\n\n\n应用二：列表内嵌套字典，要求在列表内按照字典的某个key对应的value进行排序\n\n\n\n注意事项：\n\n\n\n1：列表排序用sort方法，当列表内嵌套字典时sort有两个值，一个是key的值，一个是reverse的值\n\n2：列表嵌套字典时sort的key值表示按照字典哪个key对应的value进行排列\n\n\n\n快速代码体验\n\n![image-20211009154203771](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154203771.png)\n\n\n\n\n\n## 高阶函数\n\n\n\n### 高阶函数的定义\n\n高阶函数就是把一个函数的函数名（通常是abs函数与round函数）作为另外一个函数的实参传入，这就叫做高阶函数\n\n\n\n\n\n### abs（）函数与 round（）函数\n\n\n\nabs（）函数详解\n\n功能：绝对值函数，就是将abs（数字数据）括号里面的数字数据进行绝对值化\n\n语法：`abs（数字数据）`\n\n快速代码体验\n\n![image-20211009154341168](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154341168.png)\n\n\n\n\n\nround（）函数详解\n\n功能：四舍五入函数，就是将folat数据进行四舍五入\n\n语法：`round（需要四舍五入的数据）`\n\n快速代码体验\n\n![image-20211009154354792](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154354792.png)\n\n\n\n### 高阶函数体验\n\n\n\n高阶函数：将一个函数的函数名作为另外一个函数的实参传入\n\n功能：让代码更加简洁，函数更加灵活\n\n快速代码体验（将abs（）函数的abs函数名传入到fn（）函数中)\n\n![image-20211009154405120](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154405120.png)\n\n\n\n\n\n## 高阶函数\n\n\n\n一：map（func，lst）函数\n\n\n\n功能：map（func，lst）函数是将传入的功能函数func作用在lst列表的每一个元素中，并返回python2/列表，python/迭代器（func和lst只是序列名，func代表函数名，lst代表列表名）\n\n\n\n语法：`p（功能函数，序列）其中func代表为传入的函数名，lst代表列表序列`\n\n注意事项：map函数的返回值在python3是迭代器，因此查看结果要将迭代器转换为列表\n\n实例：利用map（）函数将列表list1 = [1，2，4，8]中的每一个数据加平方\n\n![image-20211009154418839](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154418839.png)\n\n\n\n\n\n二：reduce（func，lst）函数\n\n功能：将函数名为func的函数作用在lst整个列表序列中，实现列表中所有数据的累计计算处理（通常是所有数据的相加、相乘等）\n\n语法：`functools . reduce（功能函数，序列）`，其中调用reduce函数要先导入functools模块\n\n注意事项：\n\n1：传入reduce函数的func函数必须要有两个形参，因为func功能是将序列中的所有数据做累积运算\n2：使用reduce函数前要先导入functools模块\n\n\n\n实例：将列表list1 = [1，5，6，8]中的所有数据进行相加或相乘\n\n\n\n![image-20211009154433998](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154433998.png)\n\n\n\n\n\n\n\n三：filter（func，lst）过滤函数\n\n功能：将func函数的功能作用在lst这个序列的所有元素中，func函数通常是过滤功能。\n\n语法：`filter（功能函数，序列）`\n\n注意事项：\n\n1：调用filter函数返回值在python3中是一个迭代器，因此查看序列过滤后的结果要将迭代器转换为列表等其他序列\n2：功能函数func通常是过滤功能，因此func函数的返回值是序列中满足条件的数据\n\n\n实例：过滤列表序列list1 = [1，2，3，4，5，6，7，8，9]的数据，过滤条件为可以被2整除的数据\n\n![image-20211009154450068](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009154450068.png)\n\n\n\n总结注意事项：\n\n\n\nmap函数与reduce函数区别：\n\n\n\n1：调用map函数返回值是迭代器，而reduce是一个数值\n2：map函数可直接调用，reduce调用前需要导入functools模块\n3：map函数的功能函数只有一个参数，而reduce的功能函数有两个参数\n4：map函数每次对序列中一个数据进行处理，而reduce是两个数据，因此reduce有两个参数\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——推导式","url":"/2021/10/09/黑马程序员学Python——推导式/","content":"\n\n\n\n\n本文主讲：在Python内推导式相关的内容【重要】，简化代码...\n\n\n\n<!--more-->\n\n\n\n\n\n## 了解推导式\n\n\n\n一：什么是推导式？\n答：推导式是用来简化代码用的\n\n\n\n\n\n二：推导式适用范围\n答：推导式只适用于列表、字典以及集合，也就是说只有列表推导式、字典推导式、集合推导式\n\n\n\n\n\n\n\n\n## 列表推导式\n\n\n\n列表推导式（根据for循环化简而来）\n\n功能：利用表达式生成一个有规律的列表，列表推导式又叫列表生成式，简化代码量\n\n语法：`列表名 = [i  for  i  in  range（start，end，step）]`其中 for 前面的 i 为返回值\n\n对比一：利用while循环生成有规律的列表；\n\n![image-20211009150946893](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150946893.png)\n\n\n\n对比二：利用for循环生成一个有规律的列表\n\n\n\n![image-20211009150953552](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150953552.png)\n\n\n\n列表推导式生成有规律列表代码：\n\n![image-20211009151001346](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151001346.png)\n\n\n\n\n\n## 带 if 的列表推导式\n\n\n\n带条件的列表推导式\n\n功能：生成一个有规律的列表，并且符合固定条件\n\n语法：`列表名 = [ i 的返回值 for i in range（start，end，step）if 判断条件 ]`\n\n语法解析：for循环遍历range可迭代对象后，判断条件是否成立，条件成立返回i的值，不成立则不返回\n\n快速代码体验\n\n\n\n![image-20211009151023619](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151023619.png)\n\n\n\n\n\n## 多个for实现列表推导式\n\n\n\n多个for循环的列表推导式（等同于for循环的嵌套）\n\n功能：打印多个数据组成的数据序列中（可以是列表、元组、集合），相当于for循环的嵌套\n\n语法：`列表名 = [ (i的返回值，j的返回值)   for  i  in range（代码1） for j in range（代码2）]`\n\n语法解析：两个for循环，其实就是for循环的嵌套，并且返回两个值\n\n快速代码体验\n\n\n\n![image-20211009151037794](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151037794.png)\n\n\n\n\n\n\n## 字典推导式\n\n\n\n字典推导式\n\n作用：快速将两个列表进行合并为字典或者提取字典中的目标数据\n\n语法一：`字典名 = {  i 的返回值：value值  for i in range（start，end，step）}`\n\n实例一：利用字典推导式完成需求，字典的key为1—5的数字，字典的value为key的2次方\n\n实例代码\n\n\n\n![image-20211009151051731](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151051731.png)\n\n\n\n\n\n\n\n语法二（两个列表的合并）：`字典名 = { 列表1[ i ] ：列表2[ i ]  for  i  in range（len（列表名））}`\n\n实例二：将两个列表合并在一起 list1 = [\"name\",\"age\",\"gender\"]   list2 = [\"TOM\",21,\"男\"]\n\n注意事项：两个列表长度一致，len（）取哪个长度都可以，长度不一致，要用len（）取长度小的，否则会报错\n\n实例代码\n\n\n\n![image-20211009151102779](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151102779.png)\n\n\n\n\n\n功能三：提取字典中的目标数据（工作中需求多，很重要）\n\n语法：`字典名 = {key：value  for  key，value  in  字典序列 . items（） if  判断条件}`\n\n实例：有一个字典 counts = {“游泳”：11，“篮球”：“6”，“排球”：15}，提取这个字典中兴趣爱好人数大于10的键值对并保存到另外一个字典中。\n\n快速代码体验：\n\n\n\n![image-20211009151114387](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151114387.png)\n\n\n\n\n\n\n## 集合推导式\n\n\n\n集合推导式\n\n功能：通过列表生成具有一定规则的集合\n\n语法：`集合名 = {i处理后的返回值 for i in 列表序列}`\n\n实例：有一个列表 list1 = [1，1，2]，通过列表生成一个列表元素2次方的集合\n\n代码演示\n\n\n\n![image-20211009151128702](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009151128702.png)\n\n\n\n未完待续......","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——公共操作","url":"/2021/10/09/黑马程序员学Python——公共操作/","content":"\n\n\n\n\n\n\n本文主讲：在Python中一些常用的公共操作，例如判断长度的方法len（）等...\n\n\n\n<!--more-->\n\n\n\n## 公共操作——运算符\n\n\n\n一：加号运算符 +（合并运算符）\n\n功能：实现字符串、列表、元组的合并，注意不支持字典的合并\n\n语法：`字符串等序列  +  字符串等序列`\n\n适用范围：适用于字符串、列表、元组、不适用于字典\n\n快速代码体验\n\n\n\n![image-20211009145956204](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145956204.png)\n\n\n\n\n\n二：乘号运算符` *`（复制运算符）\n\n功能：实现字符串、列表、元组的复制，注意不支持字典的复制\n\n语法：`复制次数 `*` 复制的数据序列`\n\n适用范围：适用于字符串、列表、元组、不适用于字典\n\n快速代码体验\n\n\n\n![image-20211009150010853](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150010853.png)\n\n\n\n\n\n三：判断是否存在运算符 in 与 not in\n\n功能：判断数据是否存在于字符串、列表、元组、字典中\n\n语法：`数据  in  数据序列`\n\n适用范围：适用于字符串、列表、元组、字典\n\n快速代码体验\n\n\n\n![image-20211009150027061](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150027061.png)\n\n\n\n总结表格\n\n\n\n![image-20211009150036142](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150036142.png)\n\n\n\n\n\n\n## 公共操作——len（）\n\n\n\nlen（）方法\n\n功能：获取字符串、列表、元组、集合、字典中数据的个数（长度）\n\n语法：`len（数据序列）`\n\n适用范围：字符串、列表、元组、字典、集合\n\n快速代码体验\n\n\n\n![image-20211009150048377](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150048377.png)\n\n\n\n## 公共操作——del（）\n\n\n\ndel（）语法\n\n功能：删除字符串、列表、元组、字典、集合或者里面的数据\n\n语法：`del（数据或者数据序列）`\n\n适用范围：字符串、列表、元组、字典、集合\n\n快速代码体验\n\n\n\n![image-20211009150100593](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150100593.png)\n\n\n\n\n\n## 公共操作——min与max\n\n\n\nmin（）与 max（）方法\n\n功能：查找容器中最小的值以及最大的值并返回，容器可以是字符串、列表、元组、集合\n\n语法：`min（数据序列）`或者 ` max（数据序列）` \n\n快速代码体验\n\n![image-20211009150111657](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150111657.png)\n\n\n\n\n\n## 公共操作——range（）\n\n\n\nrange（start，end，step）方法\n\n功能：生成从start到end的有顺序的数字（生成的数字不包括end自身），供for遍历使用\n\n语法：`range（start，end，step）`\n\n快速代码体验\n\n![image-20211009150124390](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150124390.png)\n\n![image-20211009150131693](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150131693.png)\n\n\n\n\n## 公共操作——enumerate（）\n\n\n\nenumerate（）方法\n\n功能：将一个可迭代对象中的数据以及数据对应的下标打印出来，并且保存在一个元组内，元组内第一个数据为数据下标，第二个为数据值，在将所有的元组保存至一个可迭代对象中！\n\n\n\n语法：`enumerate（可迭代数据序列，start = 0）`start的值可以省略，默认下标从0开始\n\n\n\n快速代码体验\n\n\n\n![image-20211009150145015](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150145015.png)\n\n\n\n\n\n## 容器类型转换\n\n\n\n容器类型三种转换方法\n\n第一种：tuple（）\n\n功能：将非元组数据序列转换为元组序列\n\n语法：`tuple（数据序列）`\n\n快速代码体验\n\n\n\n![image-20211009150157413](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150157413.png)\n\n\n\n\n\n第二种：list（）\n\n功能：将非列表数据序列转换为列表序列\n\n语法：`list（数据序列）`\n\n快速代码体验\n\n\n\n![image-20211009150208521](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150208521.png)\n\n\n\n第三种：set（）\n\n功能：将非集合数据序列转换为集合序列\n\n语法：`set（数据序列）`\n\n快速代码体验\n\n![image-20211009150216799](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009150216799.png)\n\n\n\n未完待续.....\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——集合","url":"/2021/10/09/黑马程序员学Python——集合/","content":"\n\n\n\n\n本文主讲：集合的一些相关知识，创建集合等....\n\n\n\n<!--more-->\n\n\n\n\n\n## 集合的创建\n\n\n\n一：创建集合的两种方法\n\n1：利用花括号 {  } 创建集合与创建字典一样\n2：利用函数 set（ ）创建集合\n\n\n\n![image-20211009145300237](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145300237.png)\n\n\n\n注意事项：\n\n1，创建空集合只能使用 set（ ）函数 ，因为 { } 这个是创建空字典用的！\n2，集合特点是去重复，相同的数据放在集合中只保留其中一个数据\n3，集合数据没有顺序，因此不支持下标\n4，集合是可变数据类型\n\n![image-20211009145317206](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145317206.png)\n\n\n\n\n\n## 集合操作——增加数据\n\n\n\n方法一：add（ ）函数，用来增加单个数据，不能增加数据序列\n\n功能：在集合中增加单个数据，增加的位置随机，不能增加数据序列，否则报错\n\n语法：`集合序列 . add（数据）`\n\n注意事项：当增加的数据在集合中存在时，则不增加程序也不报错\n\n快速代码体验\n\n\n\n![image-20211009145325186](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145325186.png)\n\n\n\n\n\n方法二：update（ ）函数\n功能：在集合中增加数据序列，注意是数据序列，不是单个数据，否则报错\n语法：`集合序列 . update( 数据序列 )`\n快速代码体验\n\n\n\n![image-20211009145331851](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145331851.png)\n\n\n\n\n## 集合操作——删除数据\n\n\n\n删除方法一：remove（ ）函数\n\n功能：删除集合中指定的数据，如果数据在集合中则删除，如果不在则报错\n\n语法：`集合序列 . remove（ 删除的数据 ）`\n\n快速代码体验\n\n\n\n![image-20211009145405909](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145405909.png)\n\n\n\n\n\n\n\n删除方法二：discard（ ）函数\n\n功能：删除集合中指定的数据，如果数据在集合中则删除，如果不在数据也不报错\n\n语法：`集合序列 . discard（ 删除的数据 ）`\n\n快速代码体验\n\n\n\n![image-20211009145417700](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145417700.png)\n\n\n\n\n\n删除方法三：pop（ ）函数\n\n功能：随机删除集合中某一个数据，并且返回这个数据值\n\n语法：`集合序列 . pop（  ）`\n\n快速代码体验\n\n\n\n![image-20211009145426946](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145426946.png)\n\n\n\n\n\n## 集合操作——判断\n\n\n\n判断方法：in 与 not  in\n\n功能：判断数据是否存在于集合中，存在返回Ture，不存在返回False\n\n快速代码体验\n\n![image-20211009145437272](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009145437272.png)\n\n\n\n\n\n未完待续.....\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——字典","url":"/2021/10/09/黑马程序员学Python——字典/","content":"\n\n\n\n\n本文主讲：字典的创建用法等....\n\n\n\n<!--more-->\n\n\n\n\n\n## 理解字典的作用？\n\n\n\n问题一：字典是用来做什么的？\n\n\n\n答：字典是用来存放数据顺序发生改变的数据，字典存放数据是以键值对形式存放的，而键值对与顺序无关，即字典不支持下标，无论后期数据顺序发生什么变化，只需按照对应的键就可以查到相应的值\n\n\n\n![image-20211009144437936](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144437936.png)\n\n\n\n## 怎么创建字典？\n\n\n\n### 创建字典的注意事项\n\n\n\n1：要用很大括号{ }将数据包裹起来\n2：数据以键值对形式出现\n3：每个键值对之间要用逗号隔开\n\n\n\n### 创建有数据字典方法\n\n\n\n![image-20211009144518945](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144518945.png)\n\n\n\n\n\n\n\n### 空字典的创建！\n\n![image-20211009144528387](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144528387.png)\n\n\n\n\n\n## 字典操作—新增键值对\n\n\n\n新增键值对操作方法\n\n语法：`字典序列名 [新增的键] = 新增的值`\n\n注意事项：如果新增的键在字典中存在，那么则修改键对应的值\n\n快速代码体验：（由代码可以看出字典数据也是可以更改的）\n\n\n\n![image-20211009144541937](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144541937.png)\n\n\n\n\n## 字典操作—删除键值对\n\n\n\n删除方法一：del（ ）函数\n\n语法`：del（要删除的字典的键）`\n\n功能：删除字典中不想要的键值对\n\n快速代码体验：\n\n\n\n![image-20211009144638933](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144638933.png)\n\n\n\n删除方法二：clear（ ）函数\n\n语法：字典序列名 . clear（ ）\n\n功能：清空字典中所有的键值对\n\n\n\n![image-20211009144648368](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144648368.png)\n\n\n\n\n\n## 字典操作——查找\n\n\n\n查找方法一：get（ ）函数\n\n语法：`字典序列名 . get（字典的键 ，默认值）`如果字典中没有括号中的键，则打印默认值。默认值也可以不写返回None\n\n功能：查找get（ ）括号中键对应的值。\n\n快速代码体验：\n\n\n\n![image-20211009144702615](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144702615.png)\n\n\n\n\n\n查找方法二：keys（ ）函数\n\n语法：`字典序列名 . keys（ ）`  查找所有的键存放在一个可迭代对象中可迭代就是可以被for遍历的对象\n\n功能：查找字典中所有的键并且存放在一个可迭代对象中\n\n快速代码体验：\n\n\n\n![image-20211009144711767](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144711767.png)\n\n\n\n\n\n查找方法三：values（ ）函数\n\n语法：`字典序列名 . values（ ）`  查找所有的值存放在一个可迭代对象中可迭代就是可以被for遍历的对象\n\n功能：查找字典中所有的值并且存放在一个可迭代对象中\n\n快速代码体验：\n\n![image-20211009144722021](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144722021.png)\n\n\n\n查找方法四：items（ ）函数\n\n语法：`字典序列名 . items（ ）`  查找所有的键对值存放在一个可迭代对象中可迭代就是可以被for遍历的对象\n\n功能：查找字典中所有的键值对（每个键值对存放在元组中）所有元组存放在一个可迭代对象中\n\n快速代码体验：\n\n![image-20211009144732130](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144732130.png)\n\n\n\n\n\n\n## 字典操作——遍历\n\n\n\n遍历一：字典中所有key（键）的遍历\n\n语法：`for 临时变量 in 字典序列名 . keys（ ）`，标黄的部分为查找字典中所有的key，存放在可迭代对象中（可被遍历的）\n\n功能：遍历字典中的所有key\n\n快速代码演示：\n\n\n\n![image-20211009144744298](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211009144744298.png)\n\n\n\n遍历二：字典中所有value（值）的遍历\n\n语法：`for 临时变量 in 字典序列名 . values（ ）`，标黄的部分为查找字典中所有的value，存放在可迭代对象中（可被遍历的）\n\n功能：遍历字典中的所有value（值）\n\n快速代码演示：\n\n\n\n![image-20211009144814258](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144814258.png)\n\n\n\n遍历三：字典中所有键值对的遍历\n\n语法：`for 临时变量 in 字典序列名 . items（ ）`，标黄的部分为查找字典中所有的键值对，存放在可迭代对象中（可被遍历的）\n\n功能：遍历字典中的所有键值对（遍历的键值对以元组形式存放）\n\n快速代码演示：\n\n![image-20211009144823639](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144823639.png)\n\n\n\n\n\n\n\n遍历四：字典中所有键值对的遍历（拆包遍历）\n\n语法：`for 临时变量1，临时变量2  in 字典序列名 . items（ ）`\n\n功能：遍历字典中的所有键值对，并且将键值对进行拆包\n\n快速代码演示：\n\n\n\n![image-20211009144835289](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009144835289.png)\n\n\n\n\n\n未完待续......\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——元组","url":"/2021/10/09/黑马程序员学Python——元组/","content":"\n\n\n\n\n本文主讲：Python内元组的相关知识\n\n\n\n<!--more-->\n\n\n\n\n\n## 什么是元组？\n\n\n\n\n\n什么是元组？\n\n元组可以存放多个数据，注意是存放多个不可以修改的数据，比如说存放用户的身份证号信息等不可修改类信息。\n\n\n\n\n\n## 定义元组注意事项\n\n\n\n\n\n多数据元组的定义：和列表定义方式类似\n\n定义语法：age_tuple = (10, 24, 36, 44, 12, 35)\n\n快速代码体验：\n\n\n\n![image-20211009112611432](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112611432.png)\n\n\n\n\n\n单数据元组的定义：括号里面数据后面一定不要忘记加逗号！！！！\n\n定义语法：age_ tuple = ( 10 , ) 一定不要忘记加逗号，如果不加逗号，age_tuple数据类型会变成括号内数据的类型\n\n快速代码体验：\n\n\n\n![image-20211009112623742](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112623742.png)\n\n\n\n\n\n## 元组常见操作—查找\n\n\n\n\n\n因为元组内存放的数据不支持修改，因此只支持查找操作\n\n\n\n查找方法一：index（ ）函数\n\n功能：在元组中查找固定的数据，如果数据在元祖中则返回数据在元组中的下标，不在则报错\n\n语法：`元组序列 . index（查找的数据，开始查找下标，结束查找下标）`开始结束下标可以不写，默认在整个元组查找\n\n快速代码演示：\n\n\n\n![image-20211009112638906](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112638906.png)\n\n\n\n\n\n查找方法二：count（ ）函数\n\n功能：在元组中查找固定的数据的个数，\n\n语法：`元组序列 . count（查找的数据，开始查找下标，结束查找下标）`开始结束下标可以不写，默认在整个元组查找\n\n快速代码演示：\n\n\n\n![image-20211009112712191](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112712191.png)\n\n\n\n方法三：len（ ）函数\n\n功能：获取元组的长度\n\n语法：`len（元组序列）`\n\n快速代码演示：\n\n![image-20211009112720642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112720642.png)\n\n\n\n\n\n## 元组操作—数据的修改\n\n\n\n注意：也许有小伙伴们要问啦，不说元组内的数据是不可以修改的嘛，为什么还有元组数据的修改啊\n\n\n\n解惑：这个问题很好，元组内的数据是不可以直接修改的，直接修改会报错，但是如果元组内嵌套了列表，那就不一样了，就可以进行元组数据的修改啦\n\n\n\n代码示例1：直接修改元组（没有内嵌列表）情况\n\n\n\n![image-20211009112732205](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112732205.png)\n\n\n\n代码示例2：元组内嵌套列表修改元组数据情况\n\n\n\n![image-20211009112739932](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009112739932.png)\n\n\n\n未完待续.....\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——列表","url":"/2021/10/09/黑马程序员学Python——列表/","content":"\n\n\n本文主讲：Python内列表的相关操作等....\n\n\n\n\n\n<!--more-->\n\n\n\n\n\n## 列表是做什么的？\n\n\n\n\n答：列表是用来存放非常多的数据用的，且一个列表内，数据类型可以不相同，但是工作经验：一个列表内最好存放相同类型的多种数据！！！\n\n\n\n## 列表查找操作相关\n\n\n\n方法一：index（ ）函数\n\n功能：查找相应的列表数据是否在列表中，数据在列表中返回数据在列表中的下标，不在报错\n\n语法：`列表序列 . index（ 要查找的列表数据 ，开始查找区间 ，结束查找区间）`，区间可不写\n\n\n\n代码快速体验：\n\n![image-20211009110726019](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110726019.png)\n\n\n\n\n\n方法二：count（ ）函数\n\n功能：查找相应的列表数据在列表中存在的个数\n\n语法：`列表序列 . count（ 要查找个数的列表数据 ）`\n\n代码快速体验：\n\n\n\n![image-20211009110830576](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110830576.png)\n\n\n\n\n\n方法三：len（ ）函数\n\n功能：判断列表、字符串、元组、字典等数据类型的长度\n\n语法：`len（列表序列名）`\n\n代码快速体验：\n\n\n\n![image-20211009110837857](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110837857.png)\n\n\n\n\n\n## 列表判断是否存在操作\n\n\n\n关键词：in   与   not  in\n\n功能：判断列表数据元素是否存在于列表之中，除此以外还可以应用于字符串、字典、元组等数据类型\n\n语法：`列表元素  in  列表`              `列表元素   not  in  列表`\n\n用途：可用于用户注册用户名时，判断用户名是否存在\n\n\n\n快速代码体验：\n\n\n\n![image-20211009110858402](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110858402.png)\n\n\n\n\n\n\n## 列表操作—增加列表数据\n\n\n\n方法一：append（ ）函数方法\n\n语法：`列表序列 . append（ 增加的数据 ）`增加的数据类型可以是字符串、整数、也可以是一个序列，比如说列表、元组等\n\n功能：将数据通过append（ ）增加到原列表的结尾，注意是增加到原列表中，说明列表是可变数据类型，字符串是不可变类型\n\n快速代码体验：\n\n\n\n![image-20211009110914120](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110914120.png)\n\n\n\n\n\n方法二：extend（ ）函数方法\n\n语法：`列表序列 . extend（ 增加的数据 ）`增加的数据类型可以是字符串、整数、也可以是一个序列，比如说列表、元组等\n\n功能：通过extend（ ）函数将数据、序列增加到列表当中，如果要增加序列，则把序列中的数据拆开然后再依次增加到列表结尾\n\n快速代码体验：\n\n\n\n![image-20211009110934365](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110934365.png)\n\n\n\n方法三：insert（ ）函数方法\n\n\n\n语法：`列表 序列. insert（ 插入位置下标，增加的数据 ）`增加的数据类型可以是字符串、整数、也可以是一个序列，比如说列表、元组等\n\n\n\n功能：通过 insert（ ）函数将数据、序列插入到列表指定位置\n\n\n\n快速代码体验\n\n\n\n![image-20211009110945395](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110945395.png)\n\n\n\n\n\n## 列表操作—删除列表数据\n\n\n\n方法一：del 函数方法\n\n语法：`del （删除的数据）`删除的数据可以是整个列表\n\n功能：删除列表中固定的数据\n\n快速代码体验：\n\n\n\n![image-20211009111007910](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111007910.png)\n\n\n\n\n\n方法二：pop（ ） 函数方法\n\n语法：`列表序列 . pop(要删除列表数据的下标 )`，下标也可以不写，默认删除列表中最后一个列表元素。\n\n功能：删除列表中指定下标列表元素或者删除列表中最后的列表元素，当然删除哪个元素都会返回一个被删除值的数据\n\n快速代码体验：\n\n\n\n![image-20211009111019161](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111019161.png)\n\n\n\n\n\n方法三：remove（ ） 函数方法\n\n语法：`列表序列 . remove(要删除列表数据值 )`\n\n功能：通过 remove（ ）删除列表中的数据\n\n快速代码体验：\n\n\n\n![image-20211009111031875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111031875.png)\n\n\n\n\n\n\n\n方法四：clear（ ） 函数方法\n\n语法：`列表数据 .clear(  )`\n\n功能：通过clear（ ）清空列表中所有的数据\n\n快速代码体验：\n\n![image-20211009111050375](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111050375.png)\n\n\n\n\n\n## 列表操作—修改列表元素【排序】\n\n\n\n修改方法一：倒序    reverse（ ）函数\n\n功能：利用 reverse（ ）将列表中的所有数据进行倒置\n\n语法：`列表序列 . reveres( )`\n\n快速代码演示：\n\n\n\n![image-20211009111111831](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111111831.png)\n\n\n\n\n\n修改方法二：排序函数：升序或者降序    sort（ ）函数\n\n功能：利用 sort（ ）函数将列表中的所有数据进行排序，为升序（默认）或者降序\n\n语法：`列表序列 . sort( )`括号里面不写值默认为升序，`列表序列.sort( reverse = Ture )`这样写是将列表序列进行倒序排列，相反\n\nreverse = False 升序排列\n\n\n\n快速代码演示：\n\n\n\n![image-20211009111129525](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111129525.png)\n\n\n\n\n\n## 列表操作—复制列表数据\n\n\n\n函数名称：copy（ ）\n\n功能：通过copy（ ）复制列表数据，保留原数据防止丢失，修改复制的列表数据\n\n语法：`列表序列 . copy（ ）`\n\n快速代码体验：\n\n\n\n![image-20211009111228397](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111228397.png)\n\n\n\n\n\n## 列表的嵌套\n\n\n\n嵌套方式：name_ list =  [ [\"张三\"，“李四”]，[“tom”，“amy”] ]\n\n应用场景：比如说一个班级分组，就可以利用列表的嵌套存储数据！\n\n快速代码体验：\n\n\n\n![image-20211009111238112](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111238112.png)\n\n\n\n\n\n## 列表练习题\n\n题目要求：有8位老师，三个办公室，要求将这8位老师随机分配到三个办公室中，最后打印分配结果！\n代码演示：\n\n\n\n![image-20211009111248135](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009111248135.png)\n\n\n\n\n\n未完待续.....\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——字符串相关","url":"/2021/10/09/黑马程序员学Python——字符串相关/","content":"\n\n\n\n\n\n\n本文主讲：Python内字符串的基本操作等\n\n\n\n<!--more-->\n\n\n\n## 书写字符串的注意事项\n\n\n\n你问我答：字符串类型可以是单引号里面的内容，也可以是双引号里面的内容，那么可以是三引号里面的内容吗？其中三引号书写字符串与单引号及双引号有什么不同吗？\n\n\n\n答：三引号可以书写字符串！例如 “”“ 我爱你 ”“” 中的我爱你就是一个字符串，但是三引号里面的字符串支持换行，并且换行打印出来。而单引号和双引号里面的不支持换行！（代码如下）\n\n\n\n![image-20211009105325999](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105325999.png)\n\n\n\n## 字符串的下标（索引）\n\n\n\n你问我答：什么是字符串的下标（索引）呢？他有什么用呢？\n\n答：程序运行的时候，数据是存储在内存中的，比如说一个字符串 str1 = “hello”存放在内存中，每一个数据单词在自己的存放地址内都有一个编号，这个编号是从零开始依次顺序排序，比如说 h 的编号（下标）为 0 ，e 的编号（下标）为 1，方便使用字符串内的某一个数据单词。\n\n\n\n![image-20211009105340629](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105340629.png)\n\n\n\n![image-20211009105349753](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105349753.png)\n\n\n\n## 字符串的切片\n\n\n\n你问我答：有一个字符串 str1 = “我爱你XXX”那么我们想要打印这个字符串的一部分数据，比如打印“我爱你”这段数据怎么办呢？\n\n\n\n答：利用切片，切片的作用就是获取字符串、列表、元组一部分数据，其语法为 ： 序列名[ 开始数据下标 ：结束数据下标+1 ：步长]，不要忘记结束数据下标要加一\n\n\n\n![image-20211009105403867](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105403867.png)\n\n\n\n注意：切片和range（）这两个语法都是左闭右开类型的！！不包括右面的数据！\n\n\n\n切记：切片 str1[ -3 ：-1 ：-1]这段切片是不成立的，-3到-1选取是从左到右选取的，而步长为 -1 代表从右到左选取，这互相矛盾，因此选取不了\n\n\n\n![image-20211009105417479](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105417479.png)\n\n\n\n\n## 字符串操作方法—查找\n\n\n\n字符串常用操作方位分为三部分，分别为：查找、判断、修改三大类\n\n\n\n查找方法一：子串的查找，即利用 `find（ ）`查找子串是否在父串中，如果在返回子串在父串中的初始位置下标，如果不在则返回 -1\n\n\nfind（）使用语法：  `字符串序列名称. find（子串 ，查找区间开始位置下标 ， 查找区间结束位置下标）`\n\n快速代码体验：\n\n\n\n![image-20211009105442534](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105442534.png)\n\n\n\n\n\n查找方法二：利用`rfind（）`函数进行子串的查找，注意是从右侧开始进行查找，如果查询到则返回字符串下标，不存在则返回 -1\n\n快速代码体验\n\n\n\n![image-20211009105459541](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105459541.png)\n\n\n\n\n\n查找方法三：利用` index（）`函数查找子串是否在父串中，如果在返回子串在父串中初始位置下标，如果不在程序显示异常！\nindex（）查找子串语法：`字符串序列名 . index（子串 ，查找区间初始位置下标，查找区间结束位置下标）`\n\n\n代码快速演示\n\n\n\n![image-20211009105519874](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105519874.png)\n\n\n\n\n\n查找方法四：`count（）`【计数函数】，count（）可以查找子串在父串中出现的次数，出现几次返回数字几，没有出现返回0\n\ncount（）语法： `字符串序列名 . count（子串，查找区间开始位置，查找区间结束位置）`\n\n快速代码演示：\n\n\n\n![image-20211009105540665](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105540665.png)\n\n\n\n\n\n\n## 字符串操作方法—修改、切割【重点】\n\n\n\n修改方法（替换）：子串的替换，利用 replace（）函数进行子串间的替换\n\n子串替换语法：` 字符串序列名 . replace(旧子串名，新子串名，替换次数)` 替换次数可不写默认为全部替换\n\n快速代码演示：注意：使用replace（）修改字符串数据后，有返回值，且原字符串是不被更改的，因为字符串属于不可修改类型数据！！\n\n\n\n![image-20211009105556965](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105556965.png)\n\n\n\n\n\n切割方法：split（），利用split（）方法可以将一个字符串从固定位置分隔成一个列表，有 n 个分割符就有 n + 1 个列表元素！\n\n分割函数语法： `字符串序列 . split(分割符名称 ，分割符出现次数 )`分割完成后，会丢失分割符号\n\n代码快速演示：\n\n\n\n![image-20211009105622033](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105622033.png)\n\n\n\n\n\n合并方法：利用 join（）方法将一个列表中的所有列表元素合并成一个字符串！！\n\njoin（）函数语法 ：` 连接字符 . (列表变量名)`\n\n代码快速体验：\n\n\n\n![image-20211009105638885](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105638885.png)\n\n\n\n\n\n\n## 字符串操作方法—大小写转换\n\n\n\n方法一：capitalize（）\n\n功能：将整个字符串的首字母进行大写\n\n语法：`字符串序列名 . capitalize( )`\n\n快速代码演示：\n\n\n\n![image-20211009105702178](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105702178.png)\n\n\n\n\n\n方法二：title（）\n\n功能：将字符串内每个单词首字母进行大写\n\n语法：`字符串序列名 . title（ ）`\n\n快速代码演示：\n\n\n\n![image-20211009105715334](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105715334.png)\n\n\n\n方法三：upper（）\n\n\n\n功能：将字符串内所有单词进行大写\n\n语法：`字符串序列名 . upper（ ）`\n\n快速代码演示：\n\n\n\n![image-20211009105725164](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105725164.png)\n\n\n\n方法四：lower（）\n\n功能：将字符串内每个单词都进行小写\n\n语法：`字符串序列名 . lower（ ）`\n\n快速代码演示：\n\n\n\n![image-20211009105741095](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105741095.png)\n\n\n\n\n\n## 字符串操作—删除空白符\n\n\n\n方法一：strip（ ）\n\n功能：删除字符串两侧空白字符\n语法：`字符串序列 . strip（ ）`\n\n快速代码体验\n\n\n\n![image-20211009105832206](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105832206.png)\n\n\n\n\n\n方法二：rstrip（ ）\n\n功能：删除字符串右侧空白字符\n\n语法：`字符串序列 . rstrip（ ）`\n\n快速代码体验\n\n\n\n![image-20211009105844266](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105844266.png)\n\n\n\n方法三：lstrip（ ）\n\n功能：删除字符串左侧空白字符\n\n语法：`字符串序列 . lstrip（ ）`\n\n快速代码体验\n\n\n\n![image-20211009105856640](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105856640.png)\n\n\n\n\n\n## 字符串操作—判断\n\n\n\n判断方法一： startswith（ ）函数\n\n功能：判断一个字符串是否以规定的子串为开头，如果是返回Ture，不是返回False \n\n语法：`字符串序列 . startswith（ 子串名，判断区间开始下标，判断区间结束下标）`\n\n其中下标可以省略，默认为整个字符串\n\n快速代码体验：\n\n\n\n![image-20211009105925201](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105925201.png)\n\n\n\n\n\n判断方法二： endswith（ ）函数\n功能：判断一个字符串是否以规定的子串为结尾，如果是返回Ture，不是返回False \n语法：`字符串序列 .endswith（ 子串名，判断区间开始下标，判断区间结束下标）`\n\n其中下标可以省略，默认为整个字符串\n\n快速代码体验：\n\n\n\n![image-20211009105941925](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105941925.png)\n\n\n\n\n\n判断方法三： isalpha（ ）函数\n功能：判断字符串内的字符数据是否全部为字母字符数据（空白字符不是字母字符）是返回Ture，不是返回False\n语法：`字符串序列 . isalpha（ ）`\n\n快速代码体验：\n\n\n\n![image-20211009105954915](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009105954915.png)\n\n\n\n\n\n判断方法四： isdigit（ ）函数\n功能：判断字符串内的字符数据是否全部为数字字符数据（空白字符不是数字字符）是返回Ture，不是返回False\n语法：`字符串序列 . isdigit（ ）`\n快速代码体验：\n\n\n\n![image-20211009110007328](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110007328.png)\n\n\n\n判断方法五： isalnum（ ）函数\n\n功能：判断字符串内的字符数据是否全部为数字字符数据或者字母数据或数字与字母的组合（空白字符不是数字字符）是返回Ture，不是返回False\n\n语法：`字符串序列 . isalnum（ ）`\n\n快速代码体验：\n\n\n\n![image-20211009110018302](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110018302.png)\n\n\n\n\n\n判断方法六： isspace（ ）函数\n功能：判断字符串内数据类型是否全部为空白字符，是返回Ture，不是返回False\n语法：`字符串序列 . isspace（ ）`\n\n快速代码体验：\n\n\n\n![image-20211009110027143](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009110027143.png)\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——循环语句篇","url":"/2021/10/09/黑马程序员学Python——循环语句篇/","content":"\n\n\n\n\n本文主讲：Python内循环语句的语法及其使用方法等...\n\n\n\n<!--more-->\n\n\n\n## 循环的作用\n\n\n\n\n你问我答：循环语句有什么作用呢？\n\n答：让代码高效的重复执行\n\n\n\n## 循环计数器注意事项\n\n\n\n你问我答：while 循环语句是的计数器数值有哪些要求呢？\n\n\n\n答： \n第一，循环计数器初始值应该为 0 ，因为计算机的世界第一个数字是从 0 开始的，因此为 0。\n第二，一般循环条件不设置为小于等于，而设置为小于！（代码演示如下）\n\n\n\n![image-20211009104102211](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104102211.png)\n\n\n\n## while练习题\n\n\n\n第一题：怎么利用循环计算 1 到 100 的累加之和呢？\n\n答：看代码演示\n\n\n\n![image-20211009104115143](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104115143.png)\n\n\n\n第二题：怎么计算 1 到 100 所有偶数的累加之和呢？\n\n答（方法一推荐这种方法）：代码演示如下\n\n\n\n![image-20211009104125544](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104125544.png)\n\n\n\n方法二：利用循环计数器，每次循环增加 2（因为是偶数）\n\n\n\n![image-20211009104136271](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104136271.png)\n\n\n\n终止代码运行按钮\n\n\n\n![image-20211009104144345](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104144345.png)\n\n\n\n\n## 了解break与continue作用（跳出while循环）\n\n\n\nbreak 与 continue 是用于跳出while循环的两种不同形式，其功能也不相同！！\n\n\n\n![image-20211009104156073](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104156073.png)\n\n\n\n### 了解 break 的功能\n\n\n\n![image-20211009104204428](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104204428.png)\n\n\n\n\n\n### 了解 continue 的功能 循环时间参数就是循环计数器\n\n\n\n注意注意！！！在使用 continue 跳出while循环，一定要在 continue 前面修改循环计数器，如果不进行修改一定会陷入到死循环之中！！\n\n\n\n![image-20211009104217542](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104217542.png)\n\n\n\n## while循环嵌套\n\n\n\n例子分析：因为惹媳妇生气了，所以说要做一套程序，这套程序包括三遍“媳妇我错了”和一遍“我去把今天的碗刷了”，并且这套程序连续做三天，媳妇才不生气了！！\n\n\n\n![image-20211009104228761](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104228761.png)\n\n\n\n循环嵌套执行流程图：\n\n\n\n![image-20211009104237181](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104237181.png)\n\n\n\n\n\n## 利用循环嵌套打印九九乘法表\n\n\n\n九九乘法表第一种形式（倒三角）：\n\n\n\n![image-20211009104246262](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104246262.png)\n\n\n\n九九乘法表第二种形式（正三角）：\n\n\n\n![image-20211009104253592](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104253592.png)\n\n\n\n\n\n## for循环注意事项\n\n\n\n你问我答：for循环俗称遍历语法，那么for循环可以遍历字符串么？\n\n\n\n答：可以遍历（代码如下）\n\n\n\n![image-20211009104308908](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104308908.png)\n\n\n\n注意事项：for 循环中的跳出循环 break 与 while 中的 break，是相同用法的，但是注意，for 循环中 continue 与 while 中的 continue 用法不一样，在 for 循环中利用 continue 跳出本次循环，是不需要在 continue 前面修改计数器的！！！（代码对比如下）\n\n\n\n![image-20211009104321160](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104321160.png)\n\n\n\n\n\n## while循环与else的配合使用\n\n\n\nWhile 与 else 配合使用的语法如下：\n\n\n\n![image-20211009104331636](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104331636.png)\n\n\n\n注意：else 不仅可以和 if（分支语句）配合使用，而且还可以与 while 或者 for （循环语句）配合使用那么 else 与循环语句配合使用有什么效果呢？\n\n\n\n答：else 与循环语句配合使用，其作用是当循环正常结束（一定要是正常结束）后，即执行 else 缩进的代码！！！【循环不正常结束是指利用break跳出循环、continue跳出本次循环算正常结束！！！】\n\n\n\n![image-20211009104341549](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104341549.png)\n\n\n\nwhile与else配合使用实例演示：\n\n \n\n说今天又惹媳妇生气了，媳妇要求我说五遍“媳妇我错了”，如果这五遍“媳妇我错了”正常说完，媳妇就原谅我了，如果没有正常说完，媳妇就不会原谅我们！！（代码演示如下）\n\n\n\n![image-20211009104354514](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104354514.png)\n\n\n\n\n\n## for循环与else配合使用\n\n\n\nfor循环与else配合使用，和while循环与else配合使用一样，当for循环正常结束的时候，else缩进的代码执行，当循环不正常结束时（break）else缩进的代码将不被执行！！！\n\n\n\n![image-20211009104404982](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009104404982.png)\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——if语句","url":"/2021/10/09/黑马程序员学Python——if语句/","content":"\n\n\n\n\n\n\n本文主讲：if语句的语法及其实例等.....\n\n\n\n<!--more-->\n\n\n\n## if语句实例（上网吧！）\n\n\n\n实例需求：让用户输入自己的年龄，判断用户的年龄，如果年龄大于等于 18岁 可以上网，小于18岁不可以上网！\n\n\n\n答：代码如下，下面代码用了 f 表达式要理解\n\n\n\n![image-20211009103247129](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103247129.png)\n\n\n\n## 多重判断（if-elif）语句\n\n\n\n理解 if—elif 语句\n\n\n\n![image-20211009103302052](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103302052.png)\n\n\n\n多重判断语句实例——获取用户输出年龄，以判断用户是否可以留下来打工！！\n\n\n\n![image-20211009103311757](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103311757.png)\n\n\n\n## if的综合例题（猜拳游戏）\n\n\n\n猜拳游戏步骤：\n\n第一步，让玩家手动输入手势其中 1 代表石头、2 代表剪刀、3 代表布，电脑随机生成一个手势。\n第二步，判断玩家的比赛情况，一共有三种情况，获胜、平局、失败\n下图是玩家获胜的情况：\n\n![image-20211009103329412](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103329412.png)\n\n\n\n下面是游戏执行代码：\n\n\n\n![image-20211009103338688](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103338688.png)\n\n\n\n## python生成随机数！！\n\n\n\n你问我答：怎么生成一个随机数字呢？\n\n答：  \n第一步：导入 random 模块\n第二步：利用 random 中的 randint（开始数字，结束数字）方法随机生成一个数字**包括结尾数字**\n\n\n\n![image-20211009103352753](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103352753.png)\n\n\n\n代码解释如下：\n\n\n\n![image-20211009103414789](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103414789.png)\n\n\n\n\n\n## 三目运算符！\n\n\n\n你问我答：什么是三目运算符？它的表达式是什么样的呢？\n\n\n\n答：三目运算符是用来简化 if — else 语句的，表达式是这样的：条件成立执行的代码 if 条件 else 条件不成立执行的代码\n\n\n\n![image-20211009103429768](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103429768.png)\n\n\n\n代码解释如下：\n\n\n\n![image-20211009103439547](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009103439547.png)\n\n\n\n\n\n\n未完待续.....\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"黑马程序员学Python——基本知识","url":"/2021/10/09/黑马程序员学Python——基本知识/","content":"\n\n\n\n\n本文主讲：计算机与CPU知识、Python编辑器Pycharm的基本配置、Python变量命名、数据类型与转义字符、运算符相关等...\n\n\n\n\n\n<!--more-->\n\n\n\n## 程序单词篇\n\n\n\n1：code（代码）                                                   \n2：Default（默认）\n3：Editor（编辑）\n4：font（做）\n5：close（关）\n6：indent（缩进）\n7：data（数据）\n8：exit（出口）\n9：tuple（元组）\n10：dict（字典）\n11：eval（评估）\n12：seat（座位）\n13：player（玩家）\n14：computer（电脑玩家）\n15：random（随机）\n16：result（结果）\n17：break（打破）\n18：continue（继续）\n19：find（查找）\n20：index（指数）\n21：count（计数）\n22：replace（替换）\n23：lower（降低）\n24：split（分裂）\n25：upper（上）\n26：strip（跳闸）\n27：center（中间）\n28：start（开始）\n29：append（附加）\n30：extend（延伸）\n31：insert（插）\n32：reverse（逆转）\n33：tuple（元组）\n34：dict（字典）\n35：item（项目）\n36：set（组）\n37：add（加）\n38：update（更新）\n39：discard（丢弃）\n40：step（步）\n41：enumerate（列出）\n42：options（选项）\n43：container（容器）\n44：nested（嵌套）\n45：global（全球，全局）\n46：info（信息）\n47：modify（修改）\n48：display（显示）\n49：functools（函数工具箱）\n50：reduce（减少）\n51：filter（过滤）\n52：content（内容）\n53：Binary（二进制）\n54：seek（寻求）\n55：suffix（后缀）\n56：except（除了）\n57：finally（最后）\n58：module（模块）\n59：package（包）\n\n\n\n## 计算机cpu与内存的作用\n\n\n\ncup为中央处理器，是处理指令用的，cpu处理指令时，第一步先将数据在硬盘中提取到内存中，在内存中将数据进行处理后在存放在硬盘中，即内存临时存储的数据是cpu要处理的数据！\n\n\n\n内存是临时存储数据用的，永久存储数据是硬盘\n\n\n\n\n\n## 下载pycharm与使用\n\n\n\n下载网址 https://download.jetbrains.8686c.com/python/pycharm-professional-2020.1.exe\n\n\n\npycharm基本使用\n第一步：（创建一个python项目）\n\n\n\n![image-20211009101756353](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101756353.png)\n\n\n\n第二步：（应用界面）\n\n\n\n![image-20211009101806751](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101806751.png)\n\n\n\n第三步：（创建代码文件）——在文件根目录出右击鼠标\n\n\n\n![image-20211009101816831](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101816831.png)\n\n\n\n\n\n## pycharm打开文件方式\n\n\n\npycharm打开代码文件的方式有三种，分别是This Window 与New Window 以及Attach这三种分别是什么意思呢？\n\n\n\n答：This Window是覆盖已经打开的项目、New Window是重新打开目标代码文件夹（打开两次pycharm）、Attach是在一个pycharm界面中打开两个代码文件夹\n\n\n\n![image-20211009101833922](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101833922.png)\n\n\n\n\nAttach（连接）打开示范\n\n\n\n![image-20211009101847593](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101847593.png)\n\n\n\n\n\n## 代码注释方法\n\n\n\n![image-20211009101919226](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101919226.png)\n\n\n\n\n\n## 变量的作用\n\n\n\n你问我答：什么是变量呢？变量的作用是什么呢？\n\n\n\n答：变量就是在存储数据的时候，将数据存放的地址起一个名字，而这个名字就是变量的名字，变量作用是方便计算机找到数据存放的位置并且调用\n\n\n\n![image-20211009101931451](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101931451.png)\n\n\n\n\n\n## 变量命名规则\n\n\n\n![image-20211009101943000](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101943000.png)\n\n\n\n\n## Pycharm Debug工具\n\n\n\n你问我答：pycharm怎么利用Debug调试代码中的bug呢？\n\n\n\n答：第一步打断点！第二步鼠标右键单击调出Debug工具（解释代码如下）\n\n\n\n![image-20211009101956338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009101956338.png)\n\n\n\nDebug工作台\n\n\n\n![image-20211009102006513](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102006513.png)\n\n\n\n\n\n## 数据类型\n\n\n\n你问我答：python中有哪些数据类型呢？\n\n\n\n答：数值类型（int、float）布尔类型（True、False）其他类型（set集合、list列表、str字符串、tuple元组、dict字典）\n\n![image-20211009102021471](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102021471.png)\n\n\n\n怎么检测数据类型呢？\n\n\n\n![image-20211009102031416](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102031416.png)\n\n\n\n\n\n## 格式化输出及格式符号\n\n\n\n你问我答：什么是python代码的格式化输出？什么是格式符号呢？\n\n\n\n答：代码的格式化输出就是输出的数据是带格式的，格式符号比较常用的就是%d、%S、%f，其中%S是以字符串格式输出出来（代码如下）\n\n\n\n![image-20211009102050059](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102050059.png)\n\n\n\n\n\n格式化输出\n\n\n\n![image-20211009102103196](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102103196.png)\n\n\n\n\n\n浮点数格式化输出保留小数问题\n\n\n\n![image-20211009102114163](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102114163.png)\n\n\n\n整形格式化输出显示的位数\n\n\n\n![image-20211009102124255](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102124255.png)\n\n\n\n多个格式化输出案例\n\n\n\n![image-20211009102135179](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102135179.png)\n\n\n\n\n\n\n## F “{表达式}”的用法！\n\n\n\n你问我答：什么是 f “{ 表达式}”？f “{ 表达式}”怎么用呢？\n\n答：f “{ 表达式}”是用于格式化输出的，用法见截图，相比于 %S 输出 用 f 表达式输出语法更加简洁更加高效\n\n\n\n![image-20211009102448769](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102448769.png)\n\n\n\n\n\n## 转义字符\n\n\n\n![image-20211009102458781](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102458781.png)\n\n\n\n\n\n## 数据类型转换\n\n\n\n你问我答：什么是数据类型装换呢？\n\n答：比如说将字符串类型转化为整形等\n\n\n\n![image-20211009102512305](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102512305.png)\n\n\n\n\n\n注意：转换完变量的数据类型是一次性的\n\n\n\n![image-20211009102526292](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102526292.png)\n\n\n\n\n\n数据转换之tuple（元组）的使用\n\n\n\n![image-20211009102631371](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102631371.png)\n\n\n\neval（ ）的作用——将字符串内数据的类型转换为原来的数据类型（代码如下）\n\n\n\n![image-20211009102647627](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102647627.png)\n\n\n\n\n\n## 运算符相关\n\n\n\n你问我答：什么是整除（取整）运算符呢？什么是次方运算符呢？\n\n\n\n答：// 这个就是整除（取整）运算符，/ 这个是除法运算符\n`2**4`  是什么意思呢？就是2的四次方！（代码解释如下）\n\n\n\n![image-20211009102702696](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102702696.png)\n\n\n\n\n\n算术运算符混合运算的时候优先级（ ）高于` ** 高于 * /  %  // 高于 + - `\n\n\n\n![image-20211009102711259](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102711259.png)\n\n\n\n\n## 赋值运算符\n\n\n\n你问我答：什么是多个变量赋值？（看代码）\n\n\n\n![image-20211009102720613](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102720613.png)\n\n\n\n\n符合赋值运算符问题（变量 num1 += 2+3）计算机应该怎么运算\n\n\n\n![image-20211009102728561](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102728561.png)\n\n\n\n## 逻辑运算符\n\n\n\nand（与）or（或）not（非）\n\n\n\n![image-20211009102738620](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102738620.png)\n\n\n\n逻辑运算符两边条件要加上括号！！\n\n\n\n![image-20211009102747051](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102747051.png)\n\n\n\n\n\n数字之间的逻辑运算\n\n\n\n![image-20211009102758660](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102758660.png)\n\n\n\n拓展：逻辑运算符 与（表达式1）and（表达式2）可以化简为下面这个形式\n\n\n\n![image-20211009102809719](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009102809719.png)\n\n\n\n\n\n\n\n未完待续......\n\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——小游戏开发","url":"/2021/10/09/siki学Python——小游戏开发/","content":"\n\n\n\n\n\n\n本文主讲：利用Python进行小游戏【飞机大战】的开发....\n\n\n\n<!--more-->\n\n\n\n## 游戏单词页\n\n\n\n\n\n1：event（事件）\n2：quit（退出）\n3：type（类型）\n4：exit（出口）\n5：mode（模式）\n6：flip（翻动）\n7：screen（屏幕）\n8：load（加载）\n9：center（中央）\n10：check（校检）\n11：update（更新）\n12：keydown（按键）\n13：keyup（键空）\n14：speed（速度）\n15：sprite（精灵）\n16：bullet（子弹）\n17：draw（画）\n18：Group（组）\n19：SPACE（空格）\n20：enemy（敌人）\n21：create（创建）\n22：index（指数）\n23：groupcollide（群撞）\n\n\n\n\n## 游戏文件代码以及图片资料\n\n\n\n![image-20211009100551875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100551875.png)\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——文件操作与异常","url":"/2021/10/09/siki学Python——文件操作与异常/","content":"\n\n\n\n\n本文主讲：利用Python代码操作计算机中的文件及其代码异常相关的知识....\n\n\n\n<!--more-->\n\n\n\n\n\n## 获取程序工作目录\n\n\n\n你问我答：怎么获取  python  程序的工作目录呢？\n\n\n\n答：利用 os 模块中的 getcwd（ ）方法获取  python  文件的工作目录（代码解释如下）\n\n\n\n![image-20211009100126939](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100126939.png)\n\n\n\n## 修改文件的工作目录\n\n\n\n你问我答：怎么修改python文件的工作目录呢？\n\n\n\n答：首先也要导入系统内置模块 os 然后 利用  os 模块中的 chdir（“工作路径”）方法进行修改工作路径（代码演示如下）\n\n\n\n![image-20211009100138888](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100138888.png)\n\n\n\n## 在python中创建文件夹\n\n\n\n你问我答：怎么在python3.7中创建一个文件夹呢？\n\n\n\n答：创建文件夹实质就是创建目录，我们首先导入 os 模块，利用 os 模块中的 makedirs（“创建文件的目录”）即可在目录下创建新的文件夹（代码演示如下）\n\n\n\n![image-20211009100153483](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100153483.png)\n\n\n\n## 读取文本文件内容\n\n\n\n你问我答：怎么利用 python 读取一个文本文件里面的内容，并且将内容打印出来呢？\n\n\n\n答：利用  with  open （“文件路径”） as  file ：中的  file . Read( ) 进行读取（代码如下）\n\n\n\n![image-20211009100204632](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100204632.png)\n\n\n\n## 文本文件数据的写入\n\n\n\n你问我答：怎么像文本文件里面写入数据呢？\n\n\n\n答：通过with  open （“文件路径”，“参数”） as  file ：中的  file . 参数( ) 来进行写入数据（代码如下）\n\n\n\n![image-20211009100227220](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100227220.png)\n\n\n\n## 代码异常处理\n\n\n\n你问我答：为了避免一段代码出现异常而影响后面代码的运行，我们有异常处理功能，那么什么是异常处理呢？\n\n\n\n答：异常处理就是，测试可能出现问题的代码，如果这段代码真的出现了问题，则用语句传达给开发者代码出现问题，但是这一整段程序会照常运行（代码如下）\n\n\n\n![image-20211009100242299](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009100242299.png)\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——类","url":"/2021/10/09/siki学Python——类/","content":"\n\n\n\n\n\n\n本文主讲：如何定义类及其实例化一个对象等...\n\n \n\n<!--more-->\n\n\n\n\n\n\n\n## 如何创建一个类！\n\n\n\n你问我答：怎么利用  python  创建一个类呢？一个类里面必须包含什么代码呢？\n\n答：利用  class  创建一个类，类简单来说就是一个模板，一个类里面必须包含 --init--（self）函数这是必须的！init函数就是类固有的属性\n\n\n\n![image-20211009095603890](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095603890.png)\n\n\n\n\n## 利用类创建实例（对象）\n\n\n\n你问我答：怎么利用类创建一个实例（对象）呢？并且调用这个类的属性和方法呢？\n\n\n\n答：解释代码看下面，这块难理解\n\n![image-20211009095616658](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095616658.png)\n\n\n\n\n\n\n## 给类属性添加默认值！\n\n\n\n你问我答：怎么给类的属性添加默认值呢？\n\n\n\n答：看代码\n\n\n\n![image-20211009095630743](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095630743.png)\n\n\n\n## 修改类属性的默认值！\n\n\n\n你问我答：用什么办法修改类中的属性或者其属性默认值呢？\n\n\n\n答：修改类中的属性或其默认值，要在类里面定义函数（方法）用来统一修改属性或者其属性默认值\n\n\n\n![image-20211009095647789](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095647789.png)\n\n\n\n\n## 类的继承！\n\n\n\n你问我答：什么是类的继承，进行类的继承代码是什么？\n\n\n\n答：类的继承分为父类和子类，子类继承父类的所有属性和方法，但是子类也可以有自己独特的属性与方法（函数），利用super（）. 父类方法可以调用父类的方法，如super（）. eat( )就是在子类调用父类的 eat 方法   代码如下\n\n\n\n![image-20211009095711388](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095711388.png)\n\n\n\n这段代码里面的  super（）.--init--（name，age）是调动父类里的初始化方法，即 self.name = name 这个，很重要，万万不可以忘记\n\n\n\n\n\n## 给子类赋予新的属性与方法！\n\n\n\n你问我答：讲完类的继承了，那么问题来了，怎么给子类赋予自己独特的属性与方法（函数）呢？\n\n\n\n答：这个问题很简单，就像重新定义一个类一样，看代码\n\n\n\n**这是代码**\n\n\n\n![image-20211009095728586](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095728586.png)\n\n\n\n**这是代码运行后的样子**\n\n\n\n![image-20211009095739720](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095739720.png)\n\n\n\n## 练习题\n\n\n\n练习题1：创建一个父类，里面存放一个人的姓名、年龄、性别、并且定义一个动作来介绍它的这些详细信息，在创建一个子类，继承父类的那些属性，并且有自己独有的属性，即学院以及班级。\n\n\n\n![image-20211009095753795](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095753795.png)\n\n\n\n\n\n练习题2：试着用代码说明魔法方法 --str--（）的作用！\n\n\n\n![image-20211009095803909](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095803909.png)\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——函数","url":"/2021/10/09/siki学Python——函数/","content":"\n\n\n\n\n\n\n\n\n本文主讲：Python内有关于函数的问题，函数定义、调用等...\n\n\n<!--more-->\n\n\n\n## 内置函数与自定义函数\n\n\n\n你问我答：什么是内置函数？怎么样自定义函数呢？\n\n\n\n答：内置函数就是不需要定义的函数，在  python  中可以拿出来直接使用的函数，如 ` print（） len（） list（）input（）`函数等\n\n那么怎么自定义函数呢？代码如下\n\n\n\n![image-20211009094758286](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094758286.png)\n\n\n\n## 函数的参数（形参与实参）\n\n\n\n\n\n你问我答：什么是函数的参数？什么又是形参与实参？\n\n\n\n答：自定义一个函数  def  name（yhq）： 其中括号里面的  yhq  就叫参数\n\n那什么是形参以及实参呢？请看下面代码。\n\n\n\n![image-20211009094811592](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094811592.png)\n\n\n\n## 函数返回值\n\n\n\n你问我答：什么是函数的返回值？\n\n\n\n答：函数的返回值用  return  来接收，将接收到的值返回给函数，用来赋值计算，代码演示如下\n\n\n\n![image-20211009094832132](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094832132.png)\n\n\n\n调用函数时无返回值的情况\n\n\n\n![image-20211009094844785](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094844785.png)\n\n\n\n\n\n\n## 函数的关键字参数\n\n\n\n你问我答：试着列举  print（）函数的两个关键字参数，当自定义函数时，什么又是自定义参数呢？\n\n\n\n答：print（“我爱你”，end = “ ”）中的  end = “ ”就是关键字参数，即将某某值进行赋值，再比如print（“我爱你”，sep = “ | ”）中的sep = “ | ”也是关键字参数，它的作用是在 print（）中的多个字符串之间用什么分隔，代码解释如下\n\n\n\n![image-20211009094902057](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094902057.png)\n\n\n\n了解什么是自定义函数的关键字参数（代码解释如下）\n\n\n\n![image-20211009094914750](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094914750.png)\n\n\n\n\n## 自定义函数的默认值\n\n\n\n你问我答：什么是自定义函数形参的默认值？\n\n\n\n答：就是在自定义一个函数的时候，形参是有数值的，这就叫函数的默认值。（代码解释如下）\n\n\n\n![image-20211009094933216](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094933216.png)\n\n\n\n## 局部变量与全局变量\n\n\n\n\n\n你问我答：什么是局部变量？什么是全局变量呢？\n\n\n\n答：局部变量，自定义函数时，在函数内部区域定义的变量叫做局部变量，这个局部变量只属于自定义的函数，只有自定义的函数才可以访问这个变量，就是这个变量只作用在自定义函数的内部，解释代码如下\n\n\n\n![image-20211009094947116](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094947116.png)\n\n\n\n了解全局变量，全局变量作用在整个代码项目。代码解释如下\n\n\n\n![image-20211009094958680](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094958680.png)\n\n\n\n## 函数与字典和列表的结合\n\n\n\n你问我答：利用函数和其返回值，打印出一个字典出来。\n\n\n\n答：解释代码如下\n\n\n\n![image-20211009095010348](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095010348.png)\n\n\n\n## 自定义函数形参存多个数据\n\n\n\n你问我答：自定义一个函数，怎么让这个函数的形参存放多个数据呢？\n\n\n\n答：将函数形参的代码换成  *n  就可以存放多个数据了，例如  def  name（a，b）：换成 def  name（ *n ）：\n就可以存放多个数据啦（解释代码如下）\n\n\n\n![image-20211009095030008](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095030008.png)\n\n\n\n\n\n\n## 创建与导入模块\n\n\n\n你问我答：怎么调用一个模块中的方法呢？\n\n答：利用 import 关键词即可（解释代码如下）\n\n\n\n![image-20211009095044034](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095044034.png)\n\n\n\n怎么自己创建一个模块呢？\n就是在代码文件同一个目录上面在创建一个 py文件，到时候就可以用  import  加上这个文件的名字导入模块了\n\n\n\n![image-20211009095101382](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095101382.png)\n\n\n\n\n\n## 导入模块中一个方法（函数）\n\n\n\n\n你问我答：怎么导入一个模块中的一个固定的函数（方法）呢？\n\n答：利用  from  模块名  import  函数名  这个方法就可以导入模块中的某一个方法了\n\n\n\n![image-20211009095113367](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095113367.png)\n\n\n\n## 函数的递归调用\n\n\n\n你问我答：利用函数的递归调用计算 f（n）= 1+2+3+4+……..+n-1+n\n\n\n\n答：\n\n\n\n因为 f（n）= 1+2+3+4+……..+n-1+n\n所以 f（n-1） = 1+2+3+4+……..+n-1\n因此 f（n）= f（n-1）+n\n\n\n\n所以 f（n）利用函数的递归调用代码如下\n\n\n\n![image-20211009095130633](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095130633.png)\n\n\n\n\n\n## 类的分化（转化为属性）\n\n\n\n你问我答：如何将一个类中的动作分化为一个新的类？方便管理。\n\n答：通过创建新类的方法  ***现在还是不怎么理解***\n\n请看siki学院第七章第八节具体了解一下\n\n\n\n\n\n## 练习题\n\n\n\n练习题1：定义一个函数，让用户输入一个字符串、元组、列表，判断用户输入的数据长度是否大于6？（代码如下）\n\n![image-20211009095146490](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095146490.png)\n\n\n\n练习题2：怎么遍历一个字符串，并且将字符串中每个字符都打印出来呢？（代码如下）\n\n\n\n![image-20211009095158995](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095158995.png)\n\n\n\n练习题3：写一个函数，判断列表长度是否大于2，如果长度大于2，则删除后面的列表元素。\n\n\n\n![image-20211009095208996](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095208996.png)\n\n\n\n练习题4：利用函数找出一个列表中所有奇数索引的列表元素，并将所有的奇数索引列表元素添加到新的列表中\n\n![image-20211009095220247](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095220247.png)\n\n\n\n练习题5：写函数，判断写入字典value(值)的长度，如果“值”大于2，删除后面的元素\n\n\n\n![image-20211009095230701](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009095230701.png)","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——while循环","url":"/2021/10/09/siki学Python——while循环/","content":"\n\n\n\n\n\n\n本文主讲：Python中while循环的语法等\n\n\n\n<!--more-->\n\n\n\n\n\n## while循环格式\n\n\n\n你问我答：while循环的格式是什么样的呢？利用while循环输出 1 到 10 的数字\n\n答：如下图\n\n![image-20211009093621366](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093621366.png)\n\n\n\n\n\n## 计算1到100的和用循环语句\n\n\n\n![image-20211009093633598](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093633598.png)\n\n\n\n## 例题\n\n\n\n你问我答：利用  while  循环让用户输入整数，并且对用户输入的整数进行加和，直到用户输入的数字为 0 时终止循环。\n\n\n\n答：第一种结题方式，代码如下\n\n\n\n![image-20211009093645827](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093645827.png)\n\n\n\n第二种结题方式如下\n\n\n\n![image-20211009093655493](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093655493.png)\n\n\n\ninput（）插播：\n\n\n\ninput（）写成这样 input（“请你输入一个数字：”），代码运行后直接打印出input（）中的字符串\n\n\n\n![image-20211009093706041](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093706041.png)\n\n\n\n\n\n## 判断奇偶数问题\n\n\n\n你问我答：利用  while  循环判断用户输入的数是否是偶数，如果是偶数则输出，奇数的话，打印“这个数是奇数”这句话，如果是  0  的话，跳出循环。（注意，0 也是偶数）\n\n\n\n答：代码如下\n\n\n\n![image-20211009093718585](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093718585.png)\n\n\n\n## 利用while遍历列表和字典\n\n\n\n你问我答：如何用  while  循环遍历列表 M = [ \"张三\"，“李四”，“王二麻子”，“李红”]   与字典\nN = {“name”：“张三”，“age”：“18”，“gender”：“男”} 呢？\n\n\n\n答  首先遍历列表代码如下\n\n![image-20211009093743197](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093743197.png)\n\n\n\n\n\n二 字典键的遍历\n\n\n\n![image-20211009093828231](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093828231.png)\n\n\n\n\n\n## while循环列表的搬运\n\n\n\n\n\n你问我答：有两个列表  M = [ \"张三\"，“李四”，“王二麻子”，“李红”] 与空列表  N = [  ]   如何将列表  M  中的列表元素搬运至空列表  N  中呢？（顺序不做要求）\n\n\n\n答：代码如下\n\n![image-20211009093841148](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093841148.png)\n\n\n\n## 用while循环给字典添加数据\n\n\n\n\n\n你问我答：利用  while  循环获取用户输入键值对的键和值，并且将用户输入的键和值添加至字典中，添加完后问用户是否继续添加，yes  则继续，no  则终止添加。\n\n\n\n答：代码如下\n\n\n\n![image-20211009093902700](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093902700.png)\n\n\n\n\n\n## print（）的其他用法\n\n\n\n你问我答：print（ ）的真正面目是什么？\n\n\n\n答：print（ ）其实已经是省略过得代码了，它的真正面目其实是这个  print（ end = “  \\n ”）把  end  =  “ \\n ”省略了，因为有了   end  =  “ \\n ”所以在执行一次  print（） 代码后就会进行一次换行。\" \\n \"是转义字符换行的意思，因此我们可以更改这个参数如  print（ end = “  ”）  这样每次执行完代码后就不会换行了\n\n\n\n代码解释\n\n\n\n![image-20211009093919430](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093919430.png)\n\n\n\n## 练习题\n\n\n\n第一题：利用循环的嵌套打印出下面这串字符，即 6 行，每行 20 个星星\n\n\n\n\n```\n********************\n********************\n********************\n********************\n********************\n********************\n```\n\n解：代码如下\n\n\n\n![image-20211009093941802](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093941802.png)\n\n\n\n\n\n第二题：打印下图的九九乘法表\n\n\n\n![image-20211009093956058](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093956058.png)\n\n\n\n代码如下\n\n\n\n![image-20211009094005488](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094005488.png)\n\n\n\n第三题：让用户输入一个数，判断是否为素数\n\n\n\n![image-20211009094016476](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094016476.png)\n\n\n\n第四题：让用户输入一个三位数，分别取出这三位数的个位、十位、百位\n\n\n\n![image-20211009094028347](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094028347.png)\n\n\n\n\n\n第五题：求 8！（8的阶乘）\n\n\n\n![image-20211009094041353](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094041353.png)\n\n\n\n第六题：求1！+ 2！+ 3！+……………+20！\n\n\n\n![image-20211009094102284](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009094102284.png)\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——字典相关","url":"/2021/10/09/siki学Python——字典相关/","content":"\n\n\n\n\n本文主讲：Python中字典的一些知识..\n\n<!--more-->\n\n\n\n## 什么是字典？\n\n\n\n\n你问我答：什么是字典？字典与列表的区别是什么？\n\n答：字典是键值对的集合，用花括号括起来的一个或者多个键值对的集合，列表常用于存储同一类型的数据，但是字典可以存储多种数据类型的数据。\n\n![image-20211009092922213](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092922213.png)\n\n\n\n你问我答：怎么访问字典中一个键值对键对应的值呢？\n\n答：直接用  print(  )  打印相应的“键“ 即可访问对应的值\n\n\n\n![image-20211009092933615](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092933615.png)\n\n\n\n## 字典数据的增加、修改、删除\n\n\n\n你问我答：怎么对一个字典里的数据进行增加、修改和删除呢？\n\n答：字典数据的增加通过赋值形式添加\n\n![image-20211009092946914](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092946914.png)\n\n\n\n字典数据的修改\n\n\n\n![image-20211009092956907](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092956907.png)\n\n\n\n字典数据的删除\n\n\n\n![image-20211009093007446](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093007446.png)\n\n\n\n\n\n## 一行定义与多行定义\n\n\n\n![image-20211009093016190](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093016190.png)\n\n\n\n\n\n## 列表与字典的嵌套\n\n\n\n你问我答：利用列表和字典的嵌套，整理一个班级三名学生的姓名、性别、年龄三种信息。\n\n\n\n答：首先一个字典包含一个同学的姓名、性别、年龄三种信息，之后列出三个字典，将这三个字典分别当做一个列表的元素即可。\n\n\n\n第一种形式\n\n\n\n![image-20211009093031053](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093031053.png)\n\n\n\n第二种形式\n\n\n\n![image-20211009093040679](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093040679.png)\n\n\n\n## 字典的遍历\n\n\n\n\n\n你问我答：怎么利用  for  循环分别实现列表 键的遍历，值的遍历，键值对的遍历呢？\n\n\n\n答：键的遍历，首先利用  . keys（ ）语句将字典中所有的键找出来，但是找出的数据不是列表，可以将数据集合通过  list（ ）转换为一个列表在进行遍历\n\n\n\n![image-20211009093055001](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093055001.png)\n\n\n\n值的遍历，首先利用  . values（ ）语句将字典中所有的键找出来，但是找出的数据不是列表，是一个集合，可以将数据集合通过  list（ ）转换为一个列表在进行遍历，或者直接遍历\n\n\n\n![image-20211009093105621](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093105621.png)\n\n\n\n\n\n键值对的遍历，先利用  .  Items (  )  将字典的键值对转化为一个集合，然后可以先将集合转换为列表在遍历，也可以不用转换直接遍历集合\n\n\n\n![image-20211009093117828](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093117828.png)\n\n\n\n\n\n## 判断某一键或值是否在字典中？\n\n\n\n\n\n你问我答：怎么判断某一 键 是否在某一字典中呢？  怎么判断某一 值 是否在某一字典中呢？\n\n答：利用  in  语句 即可判断   如果在返回  正确即 True   如果不在返回  错误即  false\n\n\n\n![image-20211009093132764](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009093132764.png)\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——if分支语句","url":"/2021/10/09/siki学Python——if分支语句/","content":"\n\n本文主讲：Python中分支语句的各种用法\n<!--more-->\n\n\n\n## If语句与布尔类型\n\n\n\nIf  语句的格式及用法如下\n\n\n\n![image-20211009092412660](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092412660.png)\n\n\n\n布尔类型\n\n\n\n例如，有以下代码 \n```python\na  =  10      b  =  6      c  =  a > b   print ( c )     \n```\n\n\n因为  a  确实大于  b  因此打印的结果为  True    如果  a  不大于  b  则打印的结果为   False   说明  True    正确  而   false  代表错误\n\n\n\n\n## and关键词及or关键词\n\n\n\n你问我答：and  关键词及  or  关键词都有什么用呢？\n\n\n\n答：and  与  or 都是用于判断语句是否正确的，and  相当于数学中的且命令，必须and两边的表达式同时成立语句才正确，返回true值，  而or相当于数学中的或命令，只要or两边的语句有一个正确即表达式正确，返回True值。\n\n\n\n![image-20211009092437905](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092437905.png)\n\n\n\n\n## in与not in 关键词\n\n\n\nin  与  not in  两个关键词是判断字符串或者数字字符串是否在列表中的关键词\n\n![image-20211009092451940](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092451940.png)\n\n\n\n## if-elif-else语句用途\n\n\n\n你问我答：一个小男孩 10 岁去动物园，动物园的购票规则是这样的，小于等于4岁，不用买票，小于等于12岁半价购票，大于12岁全票，利用  if-elif-else  语句做这道题目。\n\n\n\n以下是源代码截图\n\n![image-20211009092505153](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092505153.png)\n\n\n\n## 怎么随机生成数字？\n\n\n\n你问我答：怎么生成随机数字呢？\n\n\n\n答：利用  inport  random  模块引入  random  .  Randint( 1,20 ) 语句即可生成  1  到  20  的随机数字，代码如下：\n\n\n\n![image-20211009092518263](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092518263.png)\n\n\n\n## 练习题\n\n\n\n第一题：让用户输入三个整数，并且用两种方法  sort  和 if  语句分别对这三个数从小到大进行排序\n\n\n\n![image-20211009092530924](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092530924.png)\n\n\n\n\n\n第二题：输入三角形三边，判断这三个边能否组成一个三角形（提示，三角形任意两边之和大于第三边）\n\n\n\n![image-20211009092543063](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092543063.png)\n\n\n\n\n\n第三题：随机生成1到20的一个数字，有5次机会让用户猜大小，如果猜大了，提示猜大了，小了提示猜小了，正确，打印“恭喜你回答正确”\n\n\n\n![image-20211009092554825](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092554825.png)\n\n\n\n\n\n持续更新中......","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——列表与语句","url":"/2021/10/09/siki学Python——列表与语句/","content":"\n\n\n本文主讲：Python中列表的一些相关知识\n\n<!--more-->\n\n\n\n\n\n## 列表定\n\n\n\n列表内可以存放多个数据，使用格式如下\n\n\n\nmassage（列表名） = [数据1，数据2，数据3]\n其中数据可以是字符串，可以是数字\n\n\n\nprint（）有什么用呢？\n相当于换行\n\n\n\n\n## 怎么调用列表中的元素\n\n\n\n有一个列表为 names = [“袁海清”，“姜玲玲”，“嘿嘿嘿”]  怎么单独打印出袁海清呢？\n\n因为“袁海清”在列表元素中占第一位即  names[ 0 ] 所以打印出 names[ 0 ]\n即可打印出 袁海清\n\n![image-20211009091535574](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091535574.png)\n\n\n\n通过倒数访问列表中后几个元素 names[ -1 ] 代表访问元素中倒数第一个元素\n\n\n\nnames[ -2 ] 访问列表中倒数第二个元素\n\n\n\n\n## 怎么截取子列表\n\n有一个列表元素 names = [“张三”，“李四”，“王二麻子”，“大山炮”]\n\n\n\n那怎么截取出一个新的列表元素呢，其中包含“李四”和“王二麻子“\n\n\n\n可以这样截取 names[ 1:3 ] 其中的 1 和 3 代表原列表中第二个和第四个元素，“李四”和“王二麻子“分别为原列表中第二个和第三个元素，但是截取新列表中 3 代表的第四个元素不算，因此就截取到原列表中第三个元素\n\n\n\n![image-20211009091600574](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091600574.png)\n\n\n\n\n\n\n## 怎么修改、增加、删除列表元素\n\n\n\n有一个列表 names = [“张三”，“李四”，“王二麻子”]\n\n\n\n那么请分别解释下面语句的意思：\n\n1  names [ 1 ] = \"大炮\"\n\n\n\n2  names. append( \"王大力\" )\n\n\n\n3  names. insert( 1,\"大傻帽\")\n\n\n\n4 del（ names[ 2 ] ）\n\n\n\n5  names. Remove(\"李四\")\n\n\n\n第一句代码的意思为将 names 列表中第二个元素替换为“大炮”\n\n\n\n第二句代码的意思是在 names 列表中最后增加一个“王大力”的元素\n\n\n\n第三句代码的意思为在 names 列表中将“大傻帽”元素插入到列表第二个元素的位置\n\n\n\n第四句代码的意思为删除列表中第三个列表元素\n\n\n\n第五句代码的意思为删除 names 列表中“李四”这个元素\n\n\n\n\n## 列表中.pop( )弹出语句的用法\n\n\n\n有一个列表 names = [“张三”，“李四”，“王二麻子”]\n\n\n\n那么 s = names .pop( )是什么意思？\n\n\n\n将 names 列表中最后一个列表元素弹出，储存到变量 s 中，弹出说明原列表中没有最后一个元素了\n\n\n\n![image-20211009091635743](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091635743.png)\n\n\n\n\n\n## 列表元素的永久排序sort（）\n\n\n\n\n\n有两个列表，分别为字符串列表 names = [\"dall\"，“ollo”，“andf”] 与数字列表 size = [26,65,27,87,2,11]   怎么将两个列表从大到小排序呢？\n\n\n\n利用  列表元素名 . sort( )来排序 例如  size . sort( )     print（size）结果为 2，11，26，27，65，87    从小到大进行排序\n\n\n\n利用 . sort ( ) 字符串列表是通过 26 字符顺序进行排序的，但注意大写字母在小写字母之前\n\n\n\n语句 names . sort( reverst = True ) 是将列表元素从大到小进行排序的\n\n![image-20211009091654106](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091654106.png)\n\n\n\n\n\n\n\n## 列表的临时排序\n\n\n\n列表永久排序用 . Sort( ) 这个表达式，永久排序会对原列表产生影响，故不返回值\n\n\n\n临时排序用  sorted( )  这个表达式，这个不会对原列表产生影响，会有返回值，产生新的列表。\n\n![image-20211009091708482](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091708482.png)\n\n\n\n\n\n\n## 列表长度\n\n\n\n有一个列表  names = [\"张三\"，“李四”，“张二麻子”]\n\n\n\n利用 len（names） 表达式即可求出列表长度为 3 \n\n\n\n\n\n## 怎么求列表中元素的索引值\n\n\n\n例如：有一个列表  names = [ “张三”，“李四”，“王二麻子”]\n\n那么怎么求出列表元素 “李四”的索引值呢？\n\n\n\n\n\n通过表达式 n1 =  names . Index(\"李四\")     print（n1） 即可求出索引值为 1 \n\n\n\n\n## 怎么将两个列表合并到一起\n\n\n\n![image-20211009091732973](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091732973.png)\n\n\n\n方法二：利用       列表1名称 . extend（列表2名称）即可合并\n\n\n\n![image-20211009091744721](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091744721.png)\n\n\n\n\n\n## 利用for循环实现列表的遍历\n\n\n\nfor循环格式如下：\n```python\nfor  临时变量  in   变量  ：\n       循环体\n```\n\n\n\n\n\n例如有一个列表   names = [\"网吧\"，“宾馆”，“厕所”]  利用for循环实现列表的遍历（即将所有列表元素打印一遍）\n\n\n\n\n\n解：\n```python\nfor  temp  in  names  ：  \n\tprint（ temp ）\n```\n\n\n\n\n其中temp为临时工，names列表为垃圾桶，temp要做的就是每一次循环，从names垃圾桶里面取出一件垃圾来。\n\n\n\n![image-20211009091817794](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091817794.png)\n\n\n\n## 生成有规律的数字列表\n\n\n\n例题：怎么用表达式来生成一个从10到25的有序数字列表呢？\n\n\n\n解：通过   range（10，30）表达式可以生成 10 到 30 的有序数列，但是不是列表，那么怎么将有序数列转换成列表呢？  利用  list（range（10，30））可以将有序数列转换为有序列表\n\n\n\n怎么调节数列增长的步长，即让数列以 2 为单位增长？\n\n\n\n解：通过  range（）语句确定第三个参数，如  range（4，10，2）的意思为，生成一个 4到 10 的数列，每次增长 2 各单位最后生成  [4, 6, 8]\n\n\n\n![image-20211009091836921](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091836921.png)\n\n\n\n\n\n## 问题：将1到10的平方存储到列表中\n\n\n\n第一种解决办法如下：\n\n\n\n![image-20211009091849581](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091849581.png)\n\n\n\n第二种解决办法：利用求出的数值与原列表索引的数值关系\n\n\n\n![image-20211009091907653](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091907653.png)\n\n\n\n\n\n## 利用索引遍历列表\n\n\n\n首先生成列表索引的数列，然后遍历这个数列即可\n\n![image-20211009091921347](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091921347.png)\n\n\n\n\n\n## 列表的最大值、最小值、求和\n\n\n\n如由于列表   shuzi = [1,2,5,7,8,4,6,9,10]   利用  python  求出列表中的最大值与最小值和累计和\n\n\n\n解  利用  min(shuzi )  max(shuzi )   sum(shuzi )  可分别求出列表的最小值、最大值、累计和。\n\n\n\n\n\n你问我答： 有数列  shuzi = [1,2,5,7,8,4,6,9,10]    那么这个语句代表什么意思呢？  News  = [ temp**2  for  temp  in  News : ]\n\n\n\n答，这个语句的意思为在列表  shuzi  的基础上重新生成一个数字列表，其中每个值对其平方处理\n\n\n\n![image-20211009091939131](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091939131.png)\n\n\n\n\n\n\n\n## 复制列表的两种方法\n\n\n\n你问我答：有一个列表，shuzi  =  [ 1 ,5 ,8 ,9 ,4 ,2 ,5 , 4], 那怎么用两种方法将这个列表进行复制呢？这两种方法有什么不同呢？\n\n\n\n\n\n答：第一种方法，通过字列表的形式进行复制  new   =  shuzi [ : ]  注意这种方法复制的列表  改变  new 列表中的值  shuzi 列表中的元素不会发生改变。\n\n\n\n\n\n第二种方法，通过赋值的形式对列表进行复制    即  new  =  shuzi  这种形式的复制  改变列表中  new  元素的值，shuzi  列表中的值也会发生改变。\n\n\n\n![image-20211009091956021](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009091956021.png)\n\n\n\n## 列表的合并\n\n\n\n你问我答：有两个列表，分别问  L1  =  [ \"dd\",\"hh\",\"ll\"]  与  L2  =  [  \"OO\",\"QQ\"]  那么怎么将两个列表合并为一个列表呢？\n\n\n\n答：第一种方式，通过  L1 . extend ( L2 )  可以将  L2  列表加到  L1  列表上\n\n\n\n第二种方式：通过加法的形式可以将两种列表合并在一起，  如  L1  +  L2  即可合并在一起。\n\n\n\n![image-20211009092009788](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009092009788.png)\n\n\n\n\n\n\n## 元组\n\n\n\n什么是元组？\n\n\n\n元组就是不可以改变元素的列表，表示方法为   a  =  （“lala”，“haha”，“hehe”）   注意元组的表示方法要用括号表示。\n\n\n\n\n\n持续更新中......\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"siki学Python——变量","url":"/2021/10/09/siki学Python——变量/","content":"\n\n\n\n\n\n本文主讲：Python中有关于变量的知识！\n\n<!--more-->\n\n\n\n## 什么是变量？\n\n\n\n在python中，为了代码的书写简便，常常用简单的字母串代替固定的代码，则这个简单的字母串就叫变量\n\n\n\n1：例如：mess = “Hello World“就代表以后需要出现Hello World的地方可以用mess代替，为了书写简便。\n\nprint(\"Hello World\") 就可以用 print（mess）代替了。\n\n\n\n2：变量也可以存放数字，例如mess=100  **数字不需要加引号**\n\n\n\n3：变量命名规则，变量名称只能以单词、数字、下划线进行命名，且变量名开头不能为数字，变量名称不能和 python 关键词重名，例\n\n不能以 print 命名。\n\n\n\n**不可以用空格命名**\n\n\n\n\n\n## 什么是字符串变量？\n\n\n\n字符串变量是用双引号或者单引号括起来的字符串\n\n\n\n例如“l love you”中的l love you就是字符串变量，当然也可以用单引号表示‘l love you’ 什么时候用单引号什么时候用双引号呢？当字符串变量内包含双引号时就要用单引号表示了。\n\n\n\n那如果字符串中既包含单引号又包含双引号呢怎么表示？\n如 变量 M = \"my name's is YHQ\" → 要这么表示‘\"my name \\'s is YHQ\"’即在单引号前面加\\就可忽略其单引号，\\名称为转义字符\n\n\n\n## 字符串变量的title（）调用\n\n\n\nM = “my name is yhq” M为变量\n\nTitle（）使用格式：M.title( )\n\nTitle( )有什么用：将字符串变量内每个单词的第一个字母进行大写即M.title( )代表“My Name Is Yhq”\n\n\n\n\n## 字符串变量upper（）作用\n\n\n\n\n和 title（）作用类似，upper（）的作用为将字符串变量内所有的字母进行大写。\n\n\n\n\n\n\n## 字符串变量的lower（）作用\n\n\n\nlower（）作用是将字符串变量的所有字母和单体都变为小写\n\n\n\n## 怎么取字符串变量的长度\n\n\n\n利用 len（）函数对字符串变量进行区长度，即求字符串变量中有多少个字符。\n\n\n\n例如 M = \"l love you\" 取字符串变量 M 中有多少个字符？\n\n\n\n利用 len （）函数进行运算 → len（M）后将 len（M）赋值给 O 打印出来即可， print（O）可求出字符串变量的长度。**空格也算一个字符**\n\n\n\n## 字符串的拼接\n\n\n\n有两个字符串“Hello” “World”怎么将两个字符串变量拼接到一起呢？\n\n借用 + 即可\n\n如\n```python\nname = 'Hello' + 'World'\nprint（name）\nprint（'Hello' + 'World'）\n```\n\n\n打印的结果都是一样的，都是Hello world\n\n\n\n## 转义字符——制表符与换行符\n\n\n\n制表符相当于一个字符，可以用 Tab 键打出来，占位相当于四个空格，注意的是四个空格表示四个字符长度，而一个 Tab 键表示一个字符长度。\n\n\n\n且制表符可以用 \\ t 进行表示的。即 print（“a    b”）和 print（“a\\tb”）打印的结果是一样的都为 a    b\n\n\n\n换行符用 \\n 表示，意义为打印出来的东西要换行。\n\n\n\n![image-20211009090650174](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009090650174.png)\n\n\n\n## 去空白函数\n\n\n\n有字符串常量 D =“     我爱你     ”大家可以看到在这字符串常量里前面和后面都有空白字符，那怎么去掉呢？\n\n\n\n利用 lstrip（）函数即可去除头部空白 格式如下 E =  D.lstrip( )  print( E ) 即可\n\n\n\n\n同理，利用 rstrip（）函数可以去除尾部空白，strip（）函数可以去除顶部与尾部空白\n\n![image-20211009090723817](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009090723817.png)\n\n\n\n\n\n\n## 整形变量的运算\n\n\n\n利用 python 分别运算下面几个式子\n\n1：3+6\n2：3-6\n3：3乘以6\n4：6除以4\n5：6除以4的整数部分\n6：4除以3的余数\n\n\n\n补充：4的三次方用代码这么表示 4**3\n\n\n\n运算之前首先要明白 /   //   % 运算符的含义，/ 代表除以  //代表除完之后取整  \n%代表除完之后取余数。\n\n![image-20211009090739113](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009090739113.png)\n\n\n\n## 运算符优先级修改\n\n\n\n正常来说运算符优先级为先乘除后加减\n\n怎么进行更改呢？\n\n\n\n答案是加括号啊！\n\n\n\n\n## 浮点数运算\n\n\n\n\n浮点数之间的运算是存在精度问题的，即运算结果不准确\n\n\n\n## 数字与数字字符串\n\n\n\n18  与 “18” 是不同的，第一个18为数字，第二个 18 为数字字符串\n\n\n\n例：message = ”我的年龄是“ + 18 是不可以的，必须要加上数字字符串，即 message = ”我的年龄是“ + ”18“ \n\n\n\nstr（）可以将数字转化为数字字符串    如 message = ”我的年龄是“ + str（18）\n\n\n\nMaeeage = “love”* 3 是什么意思，即将字符串复制三遍，三个love\n\n\n\n\n## 代码注释\n\n\n\n在 python 一行中 # 后面的所有文字与代码都为注释\n\n\n\n![image-20211009090756084](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009090756084.png)\n\n\n\n\n\n## input（）的用法\n\n\n\ninput（）具有接收用户输入的信息功能，但是不管用户输入的是什么，input（）都将其转换为 字符串（不是数字字符串）\n\n\n\n怎么获取  input（）的结果呢？很简单，将   input（）存放在变量内即可\n\nMassage = input（）\n\n![image-20211009090808875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211009090808875.png)\n\n\n\n\n## python文档\n\n查询python中文文档链接地址\nhttps://www.sogou.com/link?url=hedJjaC291PES9QO_EuJFi2wiAdA0Gor1TiwqFhz0z6t5pUc3zy0dg..\n\n\n\n持续更新中.....\n\n\n\n\n\n\n\n","tags":["Python基础语法篇"],"categories":["Python基础语法篇"]},{"title":"Win电脑的相关操作【疑难杂症解决】","url":"/2021/10/08/Win笔记本的相关操作/","content":"\n\n\n\n\n\n\n*本文主讲：Win10系统的相关操作，一些疑难杂症问题的解决等~*\n\n<!--more-->\n\n\n\n## 怎么设置应用程序的开机自启？\n\n\n\n第一步：按下 win键 + r键进入命令行工具\n\n第二步：在命令行内输入 shell:startup 进去开机启动项文件夹\n\n\n\n![image-20211008194437949](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008194437949.png)\n\n\n\n\n第三步：将想要开机自启的程序快捷方式拖进去即可！！\n\n\n\n![image-20211008194450489](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008194450489.png)\n\n\n\n\n\n\n## 计算机连接扩展屏幕没有声音的解决办法！\n\n\n\n解决问题站点：\n\n1：https://blog.csdn.net/niuba123456/article/details/105131703/\n\n2：https://jingyan.baidu.com/article/95c9d20d677f1bec4e756117.html\n\n\n\n\n\n\n\n\n## 解决安卓模拟器没网的问题\n\n\n\n问题：如果在电脑上上运行安卓模拟器没网怎么解决呢？\n\n\n\n第一步：在模拟器内找到连接的wifi然后长按选择修改设置\n\n\n\n![image-20211008194511995](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008194511995.png)\n\n\n\n第二步：修改IP设置\n\n\n\n![image-20211008194520756](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008194520756.png)\n\n\n\n持续更新中.....\n\n\n","tags":["疑难杂症篇"],"categories":["疑难杂症篇"]},{"title":"AJAX基础","url":"/2021/10/08/AJAX基础/","content":"\n\n\n*本文主讲：AJAX技术的简单应用...*\n\n\n\n<!--more-->\n\n\n\n## 浏览器页面的全局刷新与局部刷新\n\n\n\n### 浏览器页面的全局刷新与局部刷新\n\n\n\n全局刷新：浏览器整个页面发生改变，跳转到全新的视图，并且用全新的数据去填充浏览器页面视图，例如在原有页面内点击超链接以及Form表单\n\n\n\n局部刷新：浏览器页面大体不发生变化，页面内的视图部分发生改变，利用新获取的数据去填充改变的视图，例如搜索引擎的搜索提示功能以及轮播图\n\n\n\n![image-20211008193249017](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008193249017.png)\n\n\n\n### 全局刷新与局部刷新的对比\n\n\n\n全局刷新：\n\n1：整个页面的视图全部发生了变化，数据传输量大，浏览器渲染时间长，用户等待时间长\n2：用户体验性略差\n3：因为数据传输量大，所以比较消耗带宽\n\t\t\n\t\t\n局部刷新：\n1：数据传输量较全局刷新比较少，在网络中传输较快\n2：浏览器不需要渲染整个页面，所以页面加载时间快，用户体验好\n3：在一个浏览器页面内可以做多个局部刷新\n\t\t\n\n注意：在浏览器页面内能做局部刷新的部分尽量做局部刷新\n\n\n\n\n\n\n## 浏览器内存中的异步JavaScript对象\n\n\n\n### 浏览器页面的全局刷新与局部刷新底层原理\n\n\n\n全部刷新原理：浏览器对象【只有一个】在同一时间内向指定的网站服务器发送请求获取数据【整个浏览器同一时间做一个请求】，然后更新整个页面\n\n\n\n局部刷新原理：浏览器内存中的异步JavaScript对象【可以有多个】在同一时间内，可向指定的网站服务器发送请求获取数据，然后局部刷新页面\n\n\n\n注意：\n\n最重要：全部刷新在同一时间最多只能做一个请求，局部刷新在同一时间内可做多个请求【异步JavaScript对象实现】！\n\t\n1：一个浏览器内可创建多个异步JavaScript对象【XMLHttpRequest】\n2：每一个异步JavaScript对象都可以独立的向服务器发送请求获取数据\n3：正因为1、2两条，所以一个浏览器页面内可以构建多个局部刷新【多个异步JavaScript对象独立发送请求完成】\n\n\n\n![image-20211008193324422](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008193324422.png)\n\n\n\n### 浏览器内存中的异步JavaScript对象【XMLHttpRequest】的介绍\n\n\n\n概念：XMLHttpRequest【异步对象】是一个异步的JavaScript对象，各大浏览器都支持\n\n\n\n创建【实例化】异步的JavaScript对象：\t`var 对象变量名 = new XMLHttpRequest（）`\n【XMLHttpRequest对象名是固定写法！】\n\n\n\n创建完异步的JavaScript对象，就可以使用这个对象中的属性和方法啦\n\n\n\n\n\n## 局部刷新用到的技术汇总\n\n\n\n### 浏览器页面进行局部刷新用到的技术汇总\n\n\n\n前端技术：\n\nJavaScript：用来创建浏览器内存中异步的对象【XMLHttpRequest】，这些异步对象用来携带数据发送请求，获取响应\n\nDOM编程：更新浏览器页面中的一些标签组件【局部组件刷新】\n\nCSS：对局部刷新的标签组件进行美化\n\n\n\n\n后端技术：\nservlet：用来接收客户端发来的请求【不局限于servlet】\n\n数据交换格式：主流为 json、XML，通过这两种数据交换格式将数据传给客户端进行局部刷新用\n\t\t\n\t\t\n总结：以上这些是浏览器页面进行局部刷新的技术汇总，他们统称为 AJAX【阿贾克斯】\n\n\n\n\n\n## 什么是AJAX\n\n\n\n### 什么是 Ajax\n\n\n\n![image-20211008193438147](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008193438147.png)\n\n\n\n重点：\n\n1：Ajax就是无需重载整个浏览器页面的基础上，能够实现页面的部分内容【视图、数据】刷新！！！\n\t\n2：Ajax不是一种新的技术，而是多种旧技术的综合使用\n\n\n\n\n\nAjax功能：实现浏览器页面的局部刷新  【以后一提到 Ajax 就想到浏览器页面的局部刷新】\n\n\n\nAjax核心技术：JavaScript【构建异步的JavaScript对象】 与 XML（json）【数据交换格式，现在主流用 json】\n\n\n\n注意：为什么现在主流的数据交换格式为 json ，但是 Ajax 却叫做异步的 JavaScript 与 XML 呢，因为Ajax技术诞生与2005年，那个时候 json 还未出生，主流数据交换格式还用XML 因此就叫 Ajax 了\n\n\n\n### 什么是同步与异步\n\n\n\n同步：同步就像是两个答打电话，一个人给另外一个人打电话，如果那个人没有接，你就不能给别人打电话【在等待接电话过程中你不能做其他事情（给别人打电话）】\n\n\n\n异步：异步就向发微信，你先给小虎发了个微信，小虎没有回你，但是你可以在小虎没回你的前提下向春丽发微信…..异步的效率远高于同步 【在等待小虎回微信的过程中你可以做别的事情（给别人发微信）】\n\n\n\n![image-20211008193508881](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008193508881.png)\n\n\n\n## 异步JS对象的方法与属性\n\n\n\n\n### 浏览器内存中的异步JS对象中常用的方法与属性的功能\n\n\n\n前提：在JS内创建了异步的JS对象    【var xhr = new XMLHttpRequest（）】\n\n\n\n常用方法：\n\n\n\n初始化请求参数——open（）\n\n\n\n语法格式：异步JS对象.open（请求方式，请求的url，boolean）\n\n\n\n方法实例：异步对象.open（“get”，“https：//www.baidu.com”，true）\n实例详解：以异步的方式向百度的服务器发送get请求\n\n\n\n参数详解：\n\n请求方式：以什么方法向指定服务器发送请求\n请求的url：目标url\nboolean：是否以异步的方式向指定url发送请求，true为异步方式，false是同步方式\n\n\n注意：异步JS对象的open方法只是初始化请求参数，并没有真正的向网站服务器发送请求，而是请求前的准备！！！！！\n\n\n\n\n\n\n\n——————————————————————————————————————————\n\n\n\n发送请求方法—— send（）\n\n\n\n方法功能：向指定的网站服务器真正发送请求\n\n\n\n语法格式：异步JS对象.send（）\n\n\n\n注意：send方法需要在open方法之后使用，等open方法初始化请求参数之后，在使用 open 方法发送请求\n\n\n\n\n\n\n————————————————————————————————————————————\n\n\n\n\n\n常用属性：\n\n\n\n获取发送请求的数字状态码属性—— readyState\n\n\n\n属性功能：判断异步的JS对象发送请求到哪一步了，不同的步骤返回的数字状态码不一样\n\n\n\n语法格式：var data = 异步JS对象.readyState     【data变量是返回值】\n\n\n\n返回值代表的含义：\n\n\n\n0：返回值为 0 代表刚刚创建好异步的 JS 对象\n\t\t\t\t\n1：程序执行了 open 函数【初始化请求参数】\n\t\t\t\t\n2：程序执行了 send 函数【真正的发送请求】\n\t\t\t\t\n3：发送请求结束，异步JS对象接收到服务器返回的数据\n\t\t\t\t\n4：异步JS对象将服务器接收到的数据在内部进行处理完毕【重要的步骤，这一步过后，数据就可以被我们所用了！】\n\n\n\n\n注意：这个数字状态码与响应状态码是不一样的哦【切记！切记】\n\n\n\n______________________________________________________________________________+++++++\n\n\n\n获取响应状态码属性—— status\n\n\n\n\n属性功能：获取服务器响应的状态码，判断响应状态\n\n语法示例：var responesCode = 异步的JS对象.status     【responseCode变量是返回值】\n\n\n\n返回值代表的含义：\n\n200：服务器成功响应\n300：重定向\n404：请求的资源未找到\n500：服务器端出现错误\n\t\t\t\t\n\t\t\t\t\n———————————————————————————————————————————\n\n\n获取服务器端相应的数据属性 —— responseText    【重点】\n\n属性功能：获取服务器响应给浏览器的数据\n\n语法示例：var responseData = 异步JS对象.responseText\n\n\n\n\n\n## 异步JS对象的使用步骤\n\n\n\n\n### 异步JS对象的使用步骤\n\n\n\n第一步：在JS脚本块内创建异步的JS对象\n\n语法实现：var xhr = new XMLHttpRequest（）\n\n注意：这段代码是写在 JS 脚本块内的哦\n\n\n\n第二步：给异步的 JS 对象绑定 readystatechange 事件 【如果请求的数字状态码发生变化就触发这个事件】\n\n\n\n功能：通过判断请求步骤的数字状态码，获取服务器端发送过来的数据并在前端页面上进行局部更新\n\n\n\n语法：\n\n```javascript\n异步JS对象.onreadystatechange = function（）{\n\n\tif （异步JS对象.readState == 4 && 异步JS对象.ststus==200）{\n\t\t\n\t\tvar data = 异步JS对象.responseText\n\t\t\t\n        document.getElementById（“one”）.innerHTML = data\n\t\t\n\t}\n\t\n\t\t}\n```\n\n\n\n语法详解：如果请求过程中数字状态码发生改变执行 function （）{} 内的代码，函数代码内如果数字状态码为4【异步对象对服务器响应的数据进行内部处理完毕】并且响应状态码为200【服务器响应正常】，那么就获取服务器响应的具体数据并且将这些数据更新到前端的页面中\n\n\n\n\n第三步：执行 open 初始化请求方法\n\n功能：向指定服务器网站发送请求前准备\n\n语法：异步JS对象.open（“get”，“https：//www.baidu.com/”，true）\n\n\n\n\n第四步：执行 send 方法向指定服务器发送请求\n\n功能：发送请求\n\n语法：异步JS对象.send（）\n\n\n\nAjax持续更新中......\n\n\n\n\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"了解XML","url":"/2021/10/08/了解XML/","content":"\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/55.jpg)\n\n本文主讲：XML的基本语法和使用场景\n\n\n<!--more-->\n\n\n\n## 什么是 XML\n\n\n\n### 什么是 XML 及其应用场景\n\n\n\nXML：可扩展标记语言，被发明的初衷就是不同系统之间进行传输与存储数据，注意不是展示数据！标记语言表示 XML 代码使用书签格式，可扩展的意思就是 XML 文档的标签名全都是自定义\n\n\n\n应用场景：\n\n1：不同网站、服务器等数据传输交换的一种格式\n\t\t\n2：充当小型数据库【数据较少时可存入XML文件内】\n\t\t\n3：充当配置文件【config.xml】\n\t\n\n优点：XML 语法严谨\n\n\n\n### XML 与 HTML 的区别\n\n\n\n区别：\n\n1：HTML的标签名是内置的，不能自定义，XML的标签名只能自定义\n2：HTML是对数据进行展示的，XML是对数据进行传输和存储的\n3：HTML语法不严谨，标签不成对也没事，XML语法特别严谨，标签必须成对出现\n\n\n\n\n\n\n## 书写 XML 文件要求\n\n\n\n### 书写XML 文件的要求\n\n\n\n要求：\n\n\n\n1：每个 XML 文件的开头都要写上   <?xml version=1.0 encoding=\"utf-8\"?>\n\n\n2：在 XML 文件内必须要有一个根标签，包含其他标签，否则报错【根标签是其他标签的父类标签】\n\t\n3：在 XML 文件内每个标签都需要成对出现\n\t\n4：XML 文件内的标签严格区分大小写\n\t\n5：XML 文件内多个标签不能交叉书写，例如       `<name><age>26</name></age>`\n\t\n\n\n注意：`<?xml version=1.0 encoding=\"utf-8\"?> `  中的两个 ? 两边不能有空格，否则会报错\n\n\n\n![image-20211008190717178](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190717178.png)\n\n\n\n\n\n## XML 文件内标签的属性\n\n\n\n### XML 文件在标签内怎么定义属性以及定义属性有什么要求\n\n\n\n标签内怎么定义属性：向 HTML 一样，在标签内直接定义属性即可！【属性名完全自定义】\n\n\n\n定义属性的注意事项：\n\n1：在 XML 文件的标签内，属性可有可无，比较鸡肋，而且在解析 XML 文件获取数据时，因为属性的存在好，解析获取数据的代码或增加。\n\t\t\t\t\n2：在 XML 文件的标签内定义属性，属性名完全自定义，属性值必须用双引号括起来！！\n\t\t\t\n3：标签内的属性可以有多个\n\n\n\n![image-20211008190733949](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190733949.png)\n\n\n\n\n\n## 标签的字符数据问题以及CDATA区域\n\n\n\n### XML 文档内出现标签的字符数据解析错误问题\n\n\n\n出现问题原因解析：XML 文档解析器错把特殊字符数据解析为标签等数据\n\n\n\n程序报错截图：\n\n![image-20211008190751032](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190751032.png)\n\n\n\n程序截图：\n\n![image-20211008190803647](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190803647.png)\n\n\n\n### 解决 XML 文档内出现标签的特殊字符数据解析错误问题的两种方式\n\n\n\n第一种方式：特殊字符使用实体字符进行转义\n\n\n\nXML文件内需要进行实体转义的特殊字符：\n\n![image-20211008190822397](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190822397.png)\n\n![image-20211008190841871](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190841871.png)\n\n\n\n\n\n注意：将特殊字符利用实体字符进行转义，实体字符最后面不要忘记加分号 ；\n\n\n\n\n\n\n\n第二种方式：CDATA区域\n\n\n\n语法格式：< ![CDATA [ 不需要被XML解释器解释执行的数据 ] ] >\n\n注意：第一种方式适用于少量特殊字符，第二种方式适用于大量特殊字符\n\n\n\n![image-20211008190858372](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190858372.png)\n\n\n\n\n\n## Xpath.......待续\n\n\n\n\n\n持续更新中......\n\n\n\n\n\n\n\n","tags":["HTML基础"],"categories":["HTML基础"]},{"title":"抓包工具Mitmproxy详解","url":"/2021/10/08/抓包工具Mitmproxy详解/","content":"\n\n\n\n\n本文主讲：命令行抓包工具Mitmproxt的下载，抓取http协议与https协议的数据包、抓取手机数据包等...\n\n<!--more-->\n\n\n\n## 认识Mitmproxy抓包工具\n\n\n\n### 什么是 mitmproxy 以及 mitmproxy 抓包工具的优点\n\n\n\n答：mitmproxy 中文名为中间人攻击，也就是代理服务器，mimtproxy包含三个命令行工具分别为 mitmproxy【windows不支持】mitmdump、mitmweb，mitmproxy 相比于 fiddler 以及 charles 优点在于可以通过自定义 python 脚本实现进行二次开发，另外mitmproxy是利用python语言开发的哦！\n\n\n\n### 怎么安装 mitmproxy 抓包工具\n\n\n\nWindows系统安装指令：`pip3 install mitmproxy`\n\n![image-20211008110945501](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110945501.png)\n\n\n\nLinux安装指令：`sudo pip3 install mitmproxy`\n\n\n\n略……….\n\n\n\n\n查看 mitmproxy工具是否安装成功：\n\n指令：`mitmdump --version`\n\n\n\n![image-20211008111009731](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008111009731.png)\n\n\n\n### mitmproxy 抓包工具由哪几个组件构成的\n\n\n\n答：有三个命令行工具组成，分别是 mitmproxy、mitmdump、mitmweb\n\n\n\nmitmproxy命令行工具：不支持Windows系统，提供一个在终端下的图形界面，具有修改请求和响应，流量重放等功能，具体操作方式有点 vim 的风格\n\n\n\nmitmdump命令行工具：可设定规则保存或重放请求和响应，mitmdump 的特点是支持 inline 脚本，由于拥有可以修改 request 和 response 中每一个细节的能力，批量测试，劫持等都可以轻松实现\n\n\n\n\nmitmweb命令行工具：提供的一个简单 web 界面，简单实用，初学者或者对终端命令行不熟悉的可以用 mitmweb 界面\n\n\n\n \n\n\n## Mitmproxy抓http包前的设置\n\n\n### 利用Mitmproxy抓http数据包的设置【mitmproxy配置和浏览器配置】\n\n\n\n#### mitmproxy配置：\n\n终端输入指令：`mitmdump` 或者 `mitmdump -p 自定义端口号`\n\n![image-20211008185714000](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185714000.png)\n\n\n\n\n\n\n#### 浏览器设置：\n\nPs：设置完 mitmproxy 后在进行浏览器设置【打开mitmproxy代理服务器后在进行浏览器设置】\n\n\n\n![image-20211008185731544](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185731544.png)\n\n\n\n\n\n选择mitmproxy为浏览器的代理服务器\n\n\n\n![image-20211008185744843](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185744843.png)\n\n\n\n\n\nmitmproxy与浏览器全部配置完成后开始抓取 https 数据包：\n\n![image-20211008185755393](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185755393.png)\n\n\n\n\n\n\n## Mitmproxy抓取https协议数据包【重点】\n\n\n\n### Mitmproxy 怎么抓取 https 协议的数据包\n\n\n\n第一步：将 mitmproxy 和浏览器设置抓取 http 数据包的样子【上一节的笔记】\n\n第二步：在 windows 计算机上面安装mitmproxy 数字证书\n\n\n\n![image-20211008185822329](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185822329.png)\n\n\n\n每一个数字证书的含义\n\n\n\n![image-20211008185837310](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185837310.png)\n\n![image-20211008185851835](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185851835.png)\n\n\n\n\n\n\n\n第三步：重启 mitmdump 命令行工具以及 浏览器 后开始抓取 https 数据包\n\n\n\n![image-20211008185906301](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185906301.png)\n\n\n\n## Mitmproxy抓取手机数据包【http与https】\n\n\n\n\n### mitmproxy 怎么抓取手机APP数据包【http协议与https协议】\n\n\n\n第一步：将手机与mitmproxy所在计算机连接在同一局域网下面\n\n\n\n\n第二步：windows 计算机终端打开mitmproxy 代理服务器\n\n指令：`mitmdump`\n\n\n\n![image-20211008185927295](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185927295.png)\n\n\n\n第三步：对手机连接的网络进行代理设置【手动代理设置】\n\n\n\n![image-20211008185944951](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185944951.png)\n\n\n\n第四步：手动代理设置成功后手机登录 http://mitm.it 网站下载相对应的证书并且安装\n\n\n\n![image-20211008185954608](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008185954608.png)\n\n\n\n\n\n第五步：手机端打开待抓包的APP或者小程序进行抓包\n\n\n\n![image-20211008190006227](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008190006227.png)\n\n\n","tags":["爬虫常用工具"],"categories":["爬虫常用工具"]},{"title":"抓包工具Charles详解","url":"/2021/10/08/抓包工具Charles详解/","content":"\n\n\n本文主讲：抓包工具Charles的简单配置，抓取电脑端及手机端的https协议的数据包、小程序的抓包等..\n\n<!--more-->\n\n\n## Charles安装以及破解\n\n\n\n### 为什么要学习Charles工具抓包【对比与Fiddler】\n\n\n\n![image-20211008105218270](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105218270.png)\n\n\n\n### 如何安装 Charles 工具以及破解使用‘\n\n\n\n软件官网：https://www.charlesproxy.com/latest-release/download.do\n\n\n\n如何破解：\n\n\n\n第一步：打开下面网站获取 Charles 秘钥\n\n\n\n破解网站：https://www.zzzmode.com/mytools/charles/\n\n获取秘钥\n\n![image-20211008105244168](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105244168.png)\n\n\n\n\n第二步：打开 Charles 软件菜单栏上的【Help】最上方的一个选项就是输入秘钥激活软件\n\n![image-20211008105253163](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105253163.png)\n\n\n\n\n\n## 认识Charles界面\n\n\n\n### Charles 界面的框架\n\n![image-20211008105328041](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105328041.png)\n\n\n\n###  Charles 菜单栏的功能\n\n![image-20211008105355560](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105355560.png)\n\n\n\n禁止缓存\n\n\n\n![image-20211008105409074](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105409074.png)\n\n\n\n查看当前计算机的IP地址\n\n![image-20211008105421034](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105421034.png)\n\n\n\n\n\n### Charles 工具栏的功能\n\n\n\n![image-20211008105438963](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105438963.png)\n\n\n\n\n### Charles 监听面板【会话展示窗口】的功能\n\n\n\n![image-20211008105449613](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105449613.png)\n\n\n\n### Charles 指定数据包详细信息展示面板的功能\n\n![image-20211008105504129](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105504129.png)\n\n\n\n\n查看查询参数或者表单数据\n\n\n\n![image-20211008105514136](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105514136.png)\n\n\n\n## 抓包前的设置【Charles与浏览器设置】\n\n\n\n### 利用 Charles 抓 http包前的设置【计算机设置、Charles设置、浏览器设置】\n\n\n\n各种程序设置的顺序【从前到后】：计算机设置 → Charles设置 → 浏览器设置\n\n\n\n注意：以下设置的步骤只针对抓取 http 协议的数据包，抓取 https 协议数据包还要额外设置【安装证书】\n\n\n\n#### 计算机代理设置：\n\n\n\n![image-20211008105533962](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105533962.png)\n\n\n\n#### Charles客户端设置：\n\n\n\n![image-20211008105545301](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105545301.png)\n\n\n\n#### 浏览器设置【在SwitchyOmega插件内设置浏览器使用Charles为代理服务器】\n\n\n\n![image-20211008105556849](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105556849.png)\n\n![image-20211008105606809](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105606809.png)\n\n\n\n## Charles抓取https数据包的设置【重点】\n\n\n\n### 一：Charles 抓取 https 数据包的设置\n\n\n\n第一步：在 Charles 上安装根证书\n\n\n\n![image-20211008105644864](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105644864.png)\n\n\n\n将证书安装在【受信任的证书颁发机构】内\n\n\n\n![image-20211008105653263](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105653263.png)\n\n\n\n\n第二步：启用 HTTP 透明代理\n\n\n\n![image-20211008105813297](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105813297.png)\n\n\n\n第三步：进行 SSH 代理设置【安全证书代理设置】\n\n\n\n![image-20211008105830763](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105830763.png)\n\n\n\n导入规则\n\n\n\n![image-20211008105841010](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105841010.png)\n\n\n\n\n第四步：重启浏览器以及 Charles 后进行 HTTPS 协议数据包的抓取\n\n\n\n![image-20211008105849159](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105849159.png)\n\n\n\n\n\n## Charles对指定请求打断点【重要】\n\n\n\n### Charles 怎么对指定请求打断点\n\n第一步：开启断点选项\n\n\n\n![image-20211008105906752](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105906752.png)\n\n\n\n\n第二步：找到需要打断点的数据包后鼠标在上面右击选择【Breakpoints】\n\n![image-20211008105914773](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105914773.png)\n\n\n\n\n第三步：对刚才打断点的数据包进行重新发送\n\n![image-20211008105924014](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105924014.png)\n\n\n\n第四步：对打断点的数据包进行修改【修改请求协议】\n\n\n\n![image-20211008105933467](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105933467.png)\n\n![image-20211008105942279](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105942279.png)\n\n\n\n\n第五步：对打完断点后的数据包取消断点选项\n\n![image-20211008105956121](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008105956121.png)\n\n\n\n## Charles重新指定数据包的请求【爬虫用到！】\n\n\n\n###  Charles 怎么对指定数据包进行更改后重新发送请求\n\n\n\n第一步：找到需要更改请求重新发送的数据包，鼠标左键选中\n\n![image-20211008110018005](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110018005.png)\n\n\n\n第二步：点击【钢笔】图标对数据包请求进行更改\n\n![image-20211008110037139](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110037139.png)\n\n\n\n第三步：获取更改请求后重新发送的数据包信息\n\n![image-20211008110046252](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110046252.png)\n\n\n\n\n第四步：删除初始化数据包\n\n\n\n![image-20211008110056133](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110056133.png)\n\n\n\n### Charles 怎么对指定数据包进行更改后重新发送请求在爬虫领域的应用\n\n答：找到指定数据包后，对查询参数或者表单数据进行更改分析返回的数据\n\n\n\n\n\n## Charles抓取手机数据包【重点】\n\n\n\n### Charles 抓取手机数据包的设置【charles与手机客户端的设置】\n\n\n\n#### Chrales设置\n\n![image-20211008110115177](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110115177.png)\n\n\n\n提示信息\n\n![image-20211008110124684](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110124684.png)\n\n\n\n#### 移动设备设置：\n\n\n\n第一步：将手机与 charles 所在的计算机处在同一局域网下面\n\n第二步：对手机的网络进行代理设置【手动设置代理】\n\n![image-20211008110137503](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110137503.png)\n\n\n\n第三步：手机登录 chls.pro/ssl 网站下载根证书后并安装这个证书\n\n![image-20211008110146330](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110146330.png)\n\n\n\n安装证书\n\n![image-20211008110212309](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110212309.png)\n\n\n\n\n\n第四步：手机打开 APP 进行抓包即可\n\n\n\n![image-20211008110220963](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008110220963.png)\n\n\n\n\n\n## Charles对小程序进行抓包\n\n\n\n### 如何利用 Charles 对小程序进行抓包\n\n\n\n答：设置代理的步骤和用手机抓APP数据包是一样的，代理设置好之后，利用微信打开某个小程序进行抓包即可！！\n\n\n\n\n持续更新中.....\n\n\n\n\n\n\n\n\n\n","tags":["爬虫常用工具"],"categories":["爬虫常用工具"]},{"title":"抓包工具Fiddler详解","url":"/2021/10/08/抓包工具Fiddler详解/","content":"\n\n\n\n本文主讲：对Fiddler的简单配置、认识Fiddler面板各项选项功能、利用Fiddler对电脑浏览器及其手机APP进行抓包等\n\n<!--more-->\n\n\n## 一些名词的解释\n\n\nURL：统一资源定位符   格式：协议类型 ：// 域名 ：端口号 资源路径\n\n响应状态码：\n\n![image-20211008102912950](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008102912950.png)\n\n\n\n## Fiddler工具安装以及使用\n\n\n\n### 什么是 Fiddler\n\n\n\n答：Fiddler是一种抓包工具，可用于网页端以及手机端的抓包，与浏览器开发者模式的网络选项功能差不多，浏览器通过Fiddler向服务器发送请求，服务器将数据包先发给 Fiddler 后通过 Fiddler 在发给浏览器，Fiddler 就相当于服务器代理\n\n\n\n\n### 如何安装 Fiddler\n\n软件官网：https://www.telerik.com/download/fiddler\n傻瓜式安装即可\n\n\n\n### Fiddler 抓包前的配置【Fiddler客户端配置、浏览器配置】\n\n\n\n#### 本地计算机的配置：\n\n![image-20211008102947599](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008102947599.png)\n\n\n\n\nps：因为作者太懒了，所以将图中的 charles 换成 fiddler 即可\n\n\n\n#### Fiddler客户端的配置：\n\n\n\n 注意：Fiddler 客户端配置完成后一定要重启客户端以及浏览器才能生效！【不要忘记重启浏览器】\n\n\n\n\n配置 Fiddler 监听的端口号\n\n![image-20211008103026332](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103026332.png)\n\n\n\n配置截取 HTTPS 的数据流量包\n\n\n\n![image-20211008103037698](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103037698.png)\n\n\n\n#### 浏览器的配置：\n\n\n\n第一步：安装 switchyomega 插件【用于管理浏览器的代理服务器】\n\n![image-20211008103052064](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103052064.png)\n\n\n\n\n第二步：在插件内设置 fiddler 为浏览器的代理服务器\n\n![image-20211008103103371](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103103371.png)\n\n\n\n\n第三步：使用刚才设置的代理服务器为浏览器的代理服务器\n\n![image-20211008103113620](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103113620.png)\n\n\n\n### 利用 Fiddler 抓包的步骤【前提是fiddler客户端与浏览器全部配置完成】\n\n\n\n第一步：打开 fiddler\n\n\n\n第二步：打开浏览器通过 switchyomega  插件将浏览器代理服务器设置为 fiddler\n\n![image-20211008103128746](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103128746.png)\n\n\n\n第三步：浏览器打开需要抓包的网站\n\n\n\n第四步：fiddler客户端对指定网站进行抓包\n\n![image-20211008103138219](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103138219.png)\n\n\n\n## 初识Fiddler界面以及一些常用功能\n\n\n\n\n### Fiddler 界面的组成\n\n答：Fiddler 界面由五部分组成，分别是菜单栏、工具栏、数据包监听面板、命令行+状态栏、辅助标签+工具\n\n![image-20211008103209918](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103209918.png)\n\n\n\n### Fiddler 界面的一些常用功能\n\n\n\n菜单栏常用功能\n\n![image-20211008103227112](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103227112.png)\n\n\n\n工具栏常用功能：\n\n![image-20211008103250236](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103250236.png)\n\n\n\n![image-20211008103306911](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103306911.png)\n\n\n\n![image-20211008103319641](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103319641.png)\n\n\n\n![image-20211008103344501](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103344501.png)\n\n\n\n![image-20211008103356130](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103356130.png)\n\n\n\n![image-20211008103409198](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103409198.png)\n\n\n\n![image-20211008103421562](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103421562.png)\n\n\n\n认识数据包监听面板：\n\n\n\n![image-20211008103433390](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103433390.png)\n\n\n\n命令行+状态栏常用功能：\n\n![image-20211008103454335](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103454335.png)\n\n\n\n辅助标签+工具常用功能：\n\n\n\n统计信息工具\n\n![image-20211008103509719](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103509719.png)\n\n\n\n\n查看工具\n\n![image-20211008103526760](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103526760.png)\n\n\n\n\n自动响应器工具\n\n![image-20211008103557629](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103557629.png)\n\n\n\n设计者工具\n\n![image-20211008103620171](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103620171.png)\n\n\n\n过滤器工具\n\n\n\n![image-20211008103633176](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103633176.png)\n\n\n\n![image-20211008103644624](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103644624.png)\n\n\n\n![image-20211008103658329](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103658329.png)\n\n\n\n![image-20211008103721179](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103721179.png)\n\n\n\n\n\n\n## Fiddler抓取安卓APP数据包【重点】\n\n\n\n\n### Fiddler 对安卓手机进行抓包前的设置【fiddler客户端以及安卓手机设置】\n\n\n\n#### FIddler客户端设置：\n\n\n\n![image-20211008103742568](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103742568.png)\n\n\nps：设置完成后重启 fiddler\n\n\n\n#### 安卓手机设置：\n\n\n\n第一步：将安卓手机与 fiddler 所在的电脑连接在同一局域网下【同一wifi】\n\n第二步：手机打开 Wifi 设置找到所连接的 Wifi 选择代理\n\n\n\n![image-20211008103801258](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103801258.png)\n\n\n\n第三步：在代理选项内找到手动后输入fiddler 所在的电脑的ip地址以及 fiddler监听的端口号点击保存\n\n\n\n![image-20211008103813220](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103813220.png)\n\n\n\n\n第四步：设置完成之后手机就利用 fiddler 做代理上网，fiddler就可以抓到手机 APP 的数据包了\n\n\n\n\n\n ## Fiddler 怎么抓取 http 协议的安卓 APP 数据包\n\n\n\n答：手机与 Fiddler 进行上面的设置之后，手机打开浏览器或者其他 APP ，fillder就可以抓到 http 协议的数据包了\n\n\n\n![image-20211008103835693](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103835693.png)\n\n\n\n## Fiddler 怎么抓取 https 协议的安卓 APP 数据包\n\n\n\n### fiddler客户端设置：\n\n\n\n![image-20211008103904261](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103904261.png)\n\n\n\n### 安卓手机设置：\n\n\n\n第一步：手机浏览器打开网站   https://fiddler所在计算机ip地址:fiddler监听的端口号 下载数字证书 例如 https：//192.168.1.8：8888 \n\n![image-20211008103918034](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103918034.png)\n\n\n\n\n\n第二步：手机打开设置 → 更多设置 → 系统安全→ 加密与凭证 →从存储设备上进行安装→选择下载好的fiddler数字证书\n\n\n\n这个步骤进行省略……….\n\n\n\n第三步：手机打开 app 应用进行抓包【Http协议以及Https协议的】\n\n![image-20211008103936009](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103936009.png)\n\n![image-20211008103949649](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008103949649.png)\n\n\n\n\n\n注意：在抓包结束后应该将代理关闭，否则会造成手机无法上网的情况@！！\n\n\n\n\n## Fiddler插件下载与使用\n\n\nFiddler插件下载网：https://www.telerik.com/fiddler/add-ons\n\n\n插件使用：下载完插件后直接运行即可安装\n\n\n\n\n\n持续更新中.......\n\n\n\n\n\n\n\n","tags":["爬虫常用工具"],"categories":["爬虫常用工具"]},{"title":"Python的有趣案例【第一期】","url":"/2021/10/08/Python的有趣案例【第一期】/","content":"\n\n\n本文主讲：利用Python第三方库完成有趣的小案例，包括但不限于生成动态二维码、下载视频等...\n\n<!--more-->\n\n\n\n## 利用 myqr 库生成个性二维码\n\n\n\n第一步：利用 pip3库 安装 myqr 轮子\n\n指令：进入终端输入 `pip3 install myqr` 安装轮子\n\n\n\n第二步：准备好二维码背景图片（图片名不要有中文）\n\n\n\n![image-20211008101537355](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008101537355.png)\n\n\n\n第三步：准备好网址（即扫码后呈现的界面），可用二维码解码器（草料二维码）将二维码解码生成一串网址\n\n\n\n![image-20211008101551429](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008101551429.png)\n\n\n\n第四步：在二维码背景图片路径处进入终端或者powershell 输入指令生成二维码\n\n\n\n指令：`myqr -c -v20 -p 二维码背景图片   二维码解码地址或其他地址`\n\n\n\n指令选项：\n\n\n\n-c：生成彩色的二维码，即你二维码背景图片的颜色\n-v[1~40]：代表生成二维码的尺寸，一共40个版本尺寸，-v20代表生成第20版本大小的二维码\n-p：生成的二维码背景图片路径\n-d：生成二维码图片存放的路径\n-n [.jpg  .gif] ：生成相对应后缀的二维码图片文件\n\n\n\n图示\n\n![image-20211008101617046](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008101617046.png)\n\n\n\n\n\n## 利用you-get库下载腾讯等视频！\n\n\n\n\n网站链接：https://blog.csdn.net/wsad861512140/article/details/105574094\n\n\n\n\n\n持续更新中......\n","tags":["Python有趣案例"],"categories":["Python有趣案例"]},{"title":"Python的疑难杂症【第一期】","url":"/2021/10/08/Python的疑难杂症【第一期】/","content":"\n\n\n\n本文主讲：在学习Python编程的过程中遇到的各种疑难杂症，包括但不限于pip安装第三方库下载慢的问题、在ubuntu系统中安装火狐浏览器的flash插件等等.....\n\n<!--more-->\n\n\n\n## 解决pip安装第三方库下载速度慢的问题\n\n\n\n### 如何利用 pip 指令在 Linux 终端快速下载第三方库\n\n\n\n步骤截图如下：\n\n\n\n第一步：找到中国的pip软件镜像源，如清华大学pip源、阿里源等\n\n阿里云 http://mirrors.aliyun.com/pypi/simple/ \n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ \n豆瓣(douban) http://pypi.douban.com/simple/ \n清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ \n中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/\n\n\n\n第二步：Linxu下利用 vi 指令修改 /home/lamb/.pip/pip.conf 文件没有则创建目录及文件（.pip目录 与 pip.conf文件）\n\n![image-20211008093839549](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008093839549.png)\n\n\n\n第三步：将下面内容复制到 pip.conf 文件内保存即可\n\n文件内容如下（其中蓝色网址代表pip中国镜像网站，可更改）：\n\n```\n[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n[install]\ntrusted-host=mirrors.aliyun.com\n```\n\n\n\n![image-20211008093903251](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008093903251.png)\n\n\n\n注意事项：利用 pip3 install 库名 安装的库是安装在 主机上面的，不是安装在虚拟机上面，虚拟机上面需要用别的指令\n\n\n\n\n\n\n## 怎么在ubuntu中安装火狐浏览器的flash插件\n\n\n\n答：在终端输入以下指令即可快速安装 flash 插件\n\n`sudo apt-get install flashplugin-installer`\n\n\n\n快速代码体验\n\n\n\n![image-20211008093939634](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008093939634.png)\n\n\n\n\n\n## Windows怎么用 pyinstaller 库将py文件打包成exe文件\n\n\n\n第一步：打开终端安装 pyinstaller 库\n\n指令：`pip3 install pyinstaller `\n\n图示\n\n![image-20211008093959725](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008093959725.png)\n\n\n\n\n\n\n第二步：将 需要打包的py文件独立放到一个文件夹内（文件夹不要中文），在地址栏输入cmd进入文件夹终端\n\n\n\n![image-20211008094025086](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094025086.png)\n\n![image-20211008094039290](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094039290.png)\n\n\n\n第三步：输入指令 pyinstaller -F -w video.py 即可将文件打包成功\n\n\n\n指令选项：\n-F：生成单个可执行文件（exe文件）\n-w：去除窗口控制台，这个很重要，python在GUI软件中打包 -w 选项很有用\n-i：将打包的可执行文件（exe文件）加上自己准备的图标（ico文件）\n\n\n\n\n注意事项：\n\n1：打包好的的 exe文件在dist文件夹内！！\n\n2：如果想要给打包好的 exe 文件加上自己的图标，可在指令中加上 -i 选项   \n\n例如  pyinstaller -i  ico图标路径 -F -w video.py   其中 ico图标路径是准备好的ico文件路径，video是待打包的py文件\n\n\n\n图示\n\n\n\n![image-20211008094056402](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094056402.png)\n\n\n\n\n\n\n## ubuntu系统解决长时间不使用，桥接模式无法上网的问题\n\n\n\n第一步：在ubuntu系统终端输入下面指令，查看ubuntu系统的网络设置  \n\n`cd /var/lib/NetworkManager`\n`sudo  gedit NetworkManager.state`\n\n查询的结果如下图后，关闭这个文件\n\n![image-20211008094147275](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094147275.png)\n\n\n\n第二步：关闭文件后回到终端 输入指令  `sudo service network-manager stop` 关闭网络\n\n\n\n第三步：输入下面指令来修改这个文件\n\n\n\n`sudo gedit /var/lib/NetworkManager/NetworkManager.state`\n\n来自 <https://www.jianshu.com/p/38b5318efc25> \n\n\n\n![image-20211008094233909](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094233909.png)\n\n\n\n\n第四步：退回终端输入下面指令重新开启网络即可大功告成\n\n`sudo service network-manager start`\n\n\n\n## navicat连接本地数据库失败的问题！\n\n\n\n问题一：\n\n![image-20211008094251400](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094251400.png)\n\n\n\n\n解决办法：将 localhost 更改为 127.0.0.1 即可\n\n\n\n问题二：\n\n![image-20211008094307735](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094307735.png)\n\n\n\n解决办法步骤：\n\n第一步：进入管理员用户 sudo -s \n第二步：重启数据库 service mysql restart\n第三步：进入数据库 mysql -u root -p\n第四步：更改密码（默认密码为空）分步骤输入下面代码\n\n1：use mysql；\n\n![image-20211008094339903](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094339903.png)\n\n\n\n#其中yhq256112是设置的新密码！\n\n\n2：ALTER USER 'root'@'localhost' IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY 'yhq256112';\n\n![image-20211008094352215](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094352215.png)\n\n\n\n3：flush privileges;\n\n![image-20211008094405124](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094405124.png)\n\n\n\n4：quit;\n\n![image-20211008094417913](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094417913.png)\n\n\n\n5：重新利用 navicat 登录数据库\n\n![image-20211008094431437](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094431437.png)\n\n\n\n问题1、问题2参考网站：https://blog.csdn.net/qq_25719943/article/details/107760503?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161147949816780264046707%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161147949816780264046707&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-107760503.pc_search_result_hbase_insert&utm_term=linux%E5%88%A9%E7%94%A8navicat%E8%BF%9E%E6%8E%A5mysql8.0.22%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%BE%E7%A4%BA%20Access%20denied%20for%20user%20%27root%27@%27localhos\n\n\n\n问题3：\n\n建立数据库报1449号错误截图\n\n![image-20211008094445875](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094445875.png)\n\n\n\n解决方案代码如下（先进入mysql数据库）：\n\n\n\n` drop user  `mysql.infoschema`@\"localhost\";`\n // 这个部分``mysql.infoschema`@\"localhost\"`就是连接数据库报错提示的用户与地址\n\n\n\n flush privileges;\n //刷新权限\n\n\n\ncreate user `mysql.infoschema`@\"localhost\" identified by 'h102';\n//`mysql.infoschema`@\"localhost\" 这个也要改成你报错的用户与地址\n\n\n\nflush privileges;\n\n\n————————————————————————————————————\n\n\n\n问题4：\n\n\n\n解决问题4后又报出 ERROR 1356 (HY000): View ‘information_schema. SCHEMATA’… 错误\n\n\n\n解决方案代码：\n\n\n\nuse mysql\n\n\n\nupdate user set Select_priv = 'Y' where User = 'mysql.infoschema';\n//这里注意用户名，也是你报错的用户名\n\n\n\nflush privileges;\n\n\n\n\n问题3、问题4解决方案参考博客：https://blog.csdn.net/weixin_43558190/article/details/108676123?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161148985916780265486587%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161148985916780265486587&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-108676123.pc_search_result_hbase_insert&utm_term=navicat%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E5%87%BA1449%20-%20The%20user%20specified%20as%20a%20definer%20(%27mysql.infoschema%27@%27localhost%27)%20does%20not%20exist\n\n\n\n\n\n## navicat远程连接linux服务器出现2003—10061号错误解决方案\n\n\n\n\n问题截图（windows远程连接服务器数据库出现的错误！）：\n\n![image-20211008094521338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094521338.png)\n\n\n\n出错原因：配置出错！\n\n解决步骤：\n\n第一步：查看3306端口号的主机！\n\n查看指令：netstat -ntlp | grep -v tcp6;\n\n截图：\n\n![image-20211008094534297](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094534297.png)\n\n\n\n第二步：修改 mysql 的配置文件（将 bind-address = 127.0.0.1 修改成 bind-address = 0.0.0.0）\n\n\n\n打开文件指令：`gedit /etc/mysql/mysql.conf.d/mysqld.cnf  `\n\n将 bind-address = 127.0.0.1 修改成 bind-address = 0.0.0.0\n\n\n\n截图：\n\n![image-20211008094554394](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094554394.png)\n\n\n\n第三步：重启mysql数据库、重新连接\n\n\n\n重启指令：service mysql restart\n\n再次查看3306端口号主机\n\n截图：\n\n![image-20211008094656725](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094656725.png)\n\n\n\n重新远程连接截图：\n\n![image-20211008094717664](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094717664.png)\n\n\n\n## ubuntu手欠按下 ctrl + alt + del 黑屏怎么解决\n\n\n答：在黑屏界面按下  ctrl + alt + F7 就行啦\n\n\n\n\n\n## 怎么手动安装python第三方包（.whl文件）\n\n\n\n第一步：进入下面网站下载对应版本的python包（.whl后缀文件）\n\n\n\n网站：\n官方网站：https://pypi.org/\n非官方网站【只用于windows系统】：https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\n\n\n\n第二步：找到.whl后缀文件所在目录，在目录下进入终端\n\n![image-20211008094742677](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094742677.png)\n\n\n\n\n\n第三步：在终端输入指令 pip3 install   whl后缀文件的全名（带上.whl）即可安装成功\n\n\n\n![image-20211008094756619](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094756619.png)\n\n\n\n\n## 怎么手动安装python第三方包（.tar.gz文件）\n\n\n\n\n\n第一步：进入下面网站下载对应版本的python包（.tar.gz后缀文件）\n\n网站：\n官方网站：https://pypi.org/\n非官方网站：https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud\n\t\n\n第二步：找到下载python包（.tar.gz后缀文件）的文件夹【linux系统为例】，将这个压缩包进行解压\n\n![image-20211008094816247](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094816247.png)\n\n\n\n第三步：解压后进入这个包的文件夹后在终端打开\n\n![image-20211008094826935](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094826935.png)\n\n\n\n第四步：在终端输入下面指令即可安装成功\n安装指令：`sudo python3 setup.py install`\n\n\n\n![image-20211008094839450](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094839450.png)\n\n\n\n\n\n## redis数据库的安装与配置\n\n\n\n\n教程网站：https://blog.csdn.net/weixin_41996197/article/details/89427073?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162640227416780255259420%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162640227416780255259420&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89427073.pc_search_result_control_group&utm_term=WIN10%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85redis&spm=1018.2226.3001.4187\n\n\n\n\n\n\n## 解决cmd命令行输入python打开商店问题\n\n\n\n出现的问题：安装好 python 之后，环境变量也配置好了，但是在终端输入 python 直接打开了应用商店的解决办法\n\n\n\n解决办法：按下 win + q 搜索 管理应用执行别名 打开这个程序，将应用安装程序全部关闭即可解决\n\n\n\n![image-20211008094902190](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094902190.png)\n\n\n\n\n问题解决网站：\nhttps://blog.csdn.net/qq_43706426/article/details/104347702\n\t\t\t\nhttps://blog.csdn.net/qq_36949278/article/details/115265034?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162893118616780357254654%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162893118616780357254654&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-115265034.first_rank_v2_pc_rank_v29&utm_term=%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5python%E6%89%93%E5%BC%80%E4%BA%86%E5%95%86%E5%BA%97&spm=1018.2226.3001.4187\n\n\n\n\n\n## 怎么卸载python\n\n\n\n第一步：首先在终端看一下 python 的版本\n指令： python3\n\n![image-20211008094916206](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094916206.png)\n\n\n\n\n第二步：复制 python 的名称以及版本号，在查找文件软件中粘贴查找\n\n\n\n![image-20211008094939993](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008094939993.png)\n\n\n\n第三步：点击…..将python进行卸载\n\n\n\n![image-20211008095004472](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008095004472.png)\n\n\n\n\n\n## windows怎么升级 python\n\n\n\n第一步：对原版本的 python 进行卸载\n\n第二步：去官网下载指定版本的 python 安装包\n\n第三步：进行安装【配置好环境变量】\n\n\n\n## python怎么卸载安装的包\n\n\n\n\n第一步：查看当前所有安装的包\n指令：`pip list`\n\n![image-20211008095034003](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008095034003.png)\n\n\n\n第二步：对安装包进行卸载\n指令：` pip uninstall 包名`\n\n\n\n\n\n## python中pip与pip3有什么区别\n\n\n\n1、pip是python的包管理工具，pip和pip3版本不同，都位于Scripts\\目录下：\n\n2、如果系统中只安装了Python2，那么就只能使用pip。\n\n3、如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的。\n\n4、如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用。\n\n5、重要：虚拟环境中，若只存在一个python版本，可以认为在用系统中pip和pip3命令都是相同的\n\n\n\n\n\n## windows安装Scrapy的注意事项【重中之重】\n\n\n\n问题出现：在windows下用指令 pip install Scrapy 会出现各种各样的错误，下面是安装 Scrapy 之前必须要安装的一些依赖库，只有安装了这些依赖库，scrapy才能安装成功！\n\n\n\nscrapy所需依赖库大纲网站：https://my.oschina.net/xtfjt1988/blog/364577\n注意：pyOpenSSL库很重要\n\n\n\n问题解决网站：https://www.cnblogs.com/liuliliuli2017/p/6746440.html\n\n\n\n\n\n\n## 浏览器抓包时犯病怎么解决\n\n\n\n\n浏览器清除缓存快捷键：Ctrl + Shift + Del 【如果浏览器犯病就试试这个快捷键】\n\n\n\n\n\n\n## 怎么安装特定版本的python包【重点】\n\n\n\n\n安装指令：pip install 包名 == 版本号\n\n\n\n![image-20211008095131684](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211008095131684.png)\n\n\n\n遇到的问题持续更新中.........\n\n\n\n\n\n\n\n\n","tags":["疑难杂症篇"],"categories":["疑难杂症篇"]},{"title":"CSS基础","url":"/2021/10/07/CSS基础/","content":"![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/20210214221720.jpg)\n\n*本文主讲：认识CSS、HTML内嵌入CSS样式的三种方式、CSS隐藏样式、CSS文字装饰样式、CSS鼠标悬停样式、标签组件定位等*\n<!--more-->\n*掌握上面的知识足够爬虫工程师用了！*\n\n## 认识CSS\n\n\n\n### 什么是 CSS\n\n概念：CSS 也叫层叠样式表语言【没有变量、函数因此不是编程语言】，相当于 HTML 文档的化妆品，可以让 HTML 页面变得更好看，CSS 是依赖于 HTML 文档的，因此 CSS 样式是依附于 HTML 文档内的，在 HTML 文档内嵌入 CSS 样式有三种方式，分别是内联定义、内部样式块、外部引入 .css 文件\n\n\n\n## HTML内嵌入CSS样式的三种方式\n\n\n\n### HTML 文档内嵌入 CSS 样式的三种方式分别是什么？\n\n\n\n第一种方式：内联定义，在 HTML 标签组件内定义 style 属性\n\n\n\n第二种方式：内部定义样式块，在`<head>`标签内定义` <style></style> `标签样式块\n\n\n\n第三种方式：外部引入 .css 文件，在`<head>`标签内定义`<link />`标签，通过 href 属性引入 .css 文件\n\n\n\n\n\n### HTML 文档嵌入 CSS 样式——内联定义 的具体做法\n\n\n\n具体实现：在 HTML 任意标签内定义 style 属性，并给这个属性赋值【css样式】即可\n\n\n\nstyle属性语法格式：style=“样式名1：样式值1；样式名2：样式值2；样式名3：样式值3……”\n\n\n\n示例：\n```html\n<input type=\"text\" style=\"width=10px ; height=20px ; border=6px\"/>\n```\n\n\n\n注意：\n\n1：CSS样式不需要我们去背，用的时候直接去找文档\n2：在 HTML 的任何标签内都可以定义 style 属性…..\n\n\n\n![image-20211007154902525](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007154902525.png)\n\n\n\n\n\n### HTML 文档嵌入 CSS 样式——内部定义样式块的具体做法【掌握CSS选择器】\n\n\n\n具体实现：在 `<head> `标签内创建样式块标签`<style></style>`，并且在样式块标签内通过 CSS 选择器选中指定一个或多个标签后添加 CSS 样式\n\n\n\n语法示例：\n```html\n\t\t<head>\n\t\t\n\t\t\t<style type=”text/css“>\n\t\t\t\t#one{\n\t\t\t\t\t样式名1：样式值1；\n\t\t\t\t\t样式名2：样式值2；\n\t\t\t\t\t样式名3：样式值3\n\t\t\t\t}\n\t\t\t</style>\n\t\t</head>\n```\n\n\n\n语法详解：找到 id 属性值为 one 的标签，为这个标签添加{ }内的所有样式…\n\n注意：style 脚本块标签内的 type=”text/css“是固定写法哦…..\n\n\n\n#### CSS选择器\n\n\n\nCSS常见选择器分类：\n\n标签选择器：通过标签名选取指定一个或多个标签…              示例： div   【找到 HTML 文档内所有的 div 标签】\n\n\n\nid选择器：通过 id 属性值选取指定一个标签…..           示例：#one  【找到id属性值为one的那一个标签】\n\n\n\nclass选择器：通过 class 属性值选取指定一个或多个标签…..        示例：. students    【找到class属性值为 student 那一类的一个或多个标签】\n\n\n\n注意：\n\n1：标签选择器可以选取多个同名的标签，id 选择器只能选择一个标签，因为每一个标签的 id 属性值唯一\n\n2：类【class】选择器可以选取一个或多个标签，因为不同标签的 class 属性值可以相同，这点和 id 属性值有区别哦\n\n3：不同标签的 id 属性值肯定不相同，但是 class 属性值可以相同，因为 id 属性值是唯一的….\n\n4：id 选择器的作用域最小，只能作用于一个标签组件，而标签选择器与类选择器可以作用于一个或者多个标签…..\n\n\n\n\n第二种嵌入 CSS 样式的方式图示\n\n![image-20211007154943340](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007154943340.png)\n\n\n\n### HTML 文档嵌入 CSS 样式——外部引入.css文件的具体做法\n\n\n\n实现语法：`在 <head>` 标签内定义 `<link />` 标签，通过这个标签内的 href 属性引入外部 .css 文件\n\n\n\n注意：HTML 文档引入 CSS 样式的三种方式中，第三种方式是最常见的……\n\n\n\n![image-20211007155004775](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155004775.png)\n\n\n\n\n### CSS 选择器三种选择器方式对标签组件生效的优先级\n\n\n\n优先级从低到高分别是：标签选择器 、 类选择器、id选择器\n\n\n\n解释：如果三个选择器都选择了同一个标签组件，那么 id 选择器选择的标签组件添加的样式生效，其他两个选择器添加样式不会生效\n\n\n\n![image-20211007155020780](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155020780.png)\n\n\n\n## CSS隐藏样式\n\n\n\n### HTML 文档内如何为标签组件设置隐藏样式\n\n\n\n效果实现：利用CSS选择器选取指定标签后为这个标签设置样式名为display，样式值为 none 的样式即可隐藏该标签\n\n\n\n实现语法：\n\n```html\nCSS选择器选取待隐藏样式的标签 {\n\tdispaly：none\n\t\t\n}\n```\n\n![image-20211007155044010](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155044010.png)\n\n\n\n## CSS文字装饰样式\n\n\n\n### HTML 内如何为指定标签添加文本装饰样式\n\n\n\n效果实现：利用 CSS 选择器选取待添加文本装饰样式的标签【文本标签】，给这个标签添加样式名为text-decoration，属性值分别为none【无文本样式】、blink【文本闪烁】、underline【文本下划线】、line-through【贯穿线】、overline【上划线】的样式\n\n\n\n\n语法示例：\n```html\n#one{\n\t\t\n\ttext-decoration : underline\n\t\t\n}\n```\n\n语法讲解：利用 id 选择器找到 id 属性值为 one 的标签，为这个标签添加文本下划线的样式\n\n\n\n![image-20211007155106016](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155106016.png)\n\n\n\n\n## CSS鼠标悬停样式\n\n\n\n### 怎么为 HTML 标签组件设置鼠标悬停样式效果\n\n\n\n效果实现：利用 CSS 选择器选取待设置鼠标悬停效果的组件标签，通过 hover 实现效果\n\n语法示例：\n```html\n#one：hover{\n\tcolor：red；\n\tFont-size：20px\n}\n```\n\n语法详解：利用 id 选择器选取 id 属性值为 one 的标签组件，当鼠标悬停在这个标签上面时，字体变为红色…，字体大小变为20px\n\n\n\n注意：#one：hover  中冒号两边不能有空格！！！，否则设置悬停样式失败….\n\n![image-20211007155127015](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155127015.png)\n\n\n\n### 怎么为 HTML 标签组件设置鼠标悬停后鼠标变为小手样式效果\n\n\n\n语法实现：\n\n```html\n#one：hover{\n\t\t\n\tcursor：point\n\t\t\n}\n```\n\n\n\n![image-20211007155151567](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155151567.png)\n\n\n\n\n\n## 标签组件定位\n\n\n\n### HTML 中如何通过 CSS 样式对标签组件进行定位\n\n\n\n定位实现：通过CSS选择器选取待定位的标签，给这个标签添加一个属性名为 position，属性值为absolute的样式后，在添加属性名为top属性值为像素与属性名为left，属性值为像素的样式即可对这个标签进行定位\n\n\n\n\n语法实现：\n\n```html\n\t\t#one{\n\t\t\n\t\t\tposition：absolute；\n\t\t\ttop：100px；\n\t\t\tleft：100px\n\t\t}\n```\n\n\n语法解释：利用 id 选择器选取 id 属性值为 one 的标签，为这个标签进行定位，这个标签组件的左上角距离浏览器页面顶部100像素，距离浏览器页面左面100像素\n\n\n\n注意：对组件进行定位，是以该组件标签左上角为基准开始定位的\n\n![image-20211007155216770](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007155216770.png)\n\n\n\n\n\n\nCSS基础讲解完毕.....\n\n\n\n\n\n\n","tags":["CSS基础"],"categories":["CSS基础"]},{"title":"HTML基础","url":"/2021/10/07/HTML基础/","content":"\n*本文主讲：认识 HTML、HTML文档格式、HTML文档格式、段落与标题字标签、常用的独目运算符、字体处理标签、预览格式标签、实体符号、HTML中的表格、浏览器界面设置背景色及背景图片、图片标签、超链接标签、herf与src属性的区别、无序列表与有序列表、Form表单、input输入域的type属性、下拉列表与文字域标签、实现简单的注册表单、文件控件、隐藏域、文本框的三种常用属性、HTML 标签中的 id 属性、div与span图层标签*\n\n\n\n  *基本包括了常用的HTML标签及其标签内的属性功能等.....*\n\n   <!--more-->\n\n## 认识 HTML\n\n\n\n### 什么是 HTML\n\n\n\n答：HTML（超文本标记语言），HTML运行在浏览器上面，超文本的意思就是，它可以展示超级文本流，例如图片流、声音流、视频流等，标记语言代表这门语言是用标签【开始标签与结束标签】进行编程的，严格来说 HTML 不算是一门编程语言，因为它没有控制语句、函数等，它是一套规范，浏览器语言规范.\n\n\n\nHTML开发：新建后缀的 .html 或者 .htm 的文件利用文本编辑器打开即可编程\n\n\n\n### 目前五大主流浏览器分别是什么以及 WEB 开发又是什么？\n\n\n\n五大主流浏览器：\n\nEdge：微软新版浏览器\nFirefox：Mozilla公司的产品\nChrome：谷歌公司的\nOpera：欧朋公司产品\nSafari：苹果笔记本专用浏览器\n\t\t\t\n\n\n\n### WEB开发是什么？\n\n\n\nWEB开发分为前端开发以及后端开发！\n\n\n\n前端开发：用户使用各种产品时看到的展示页面，前端程序员需要精通 HTML+CSS+JavaScript\n\n后端开发：前端程序员需要的各种动态数据都需要后端程序员提供，后端程序员就是需要为前端提供数据！\n\n\n\n### W3C 是什么\n\n\n\nW3C：万维网联盟，非盈利组织，制定了很多标准，例如 html、https、javascript等，万维网联盟创始人是 蒂姆伯纳斯 李   老牛批了这个人，因为这个人我们才可以上网！！\n\n\n\n## HTML文档格式\n\n\n\n### 文档格式\n\n![image-20211007151830348](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007151830348.png)\n\n\n\n\n###  HTML 文档有什么特点\n\n\n\n特点：\n\n1：HTML语法松散\n2：HTML语法有的标签不成对出现也没有问题【不是所有标签都允许不成对出现的】\n3：HTML语法标签不严格区分大小写\n\n\n\n![image-20211007151846359](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007151846359.png)\n\n\n\n## 段落与标题字标签\n\n\n\n### HTML 中段落与标题字标签分别是什么？\n\n\n\n段落标签：`<p>待分段的内容</p> `\n\n\n\n标题字标签：\n\n```html\n<h1>一号标题字数据</h1>\n<h2>二号标题字数据</h2>\n<h3></h3>\n<h4></h4>\n<h5></h5>\n<h6></h6>\n```\n\n\n\n注意：\n\n1：在HTML源代码内手动换行是不起作用的\n2：标题字标签中 h1 标签的标题最大，h2 标签的标题最小\n3：标题字标签独占行\n\n\n\n![image-20211007151940815](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007151940815.png)\n\n\n\n\n\n\n## 常用的独目运算符\n\n\n\n### HTML 中常用的独目运算符及其用法\n\n`<br>`：换行标签\n\n注意：一个` <br>` 标签就代表换一行\n\n\n\n\n`<hr>`：水平线标签\n\n![image-20211007152048352](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152048352.png)\n\n\n\n\n## 字体处理标签\n\n\n\n### HTML 内常用的字体处理标签\n\n\n\n\n字体加粗标签：`<b>待加粗的数据</b>`\n\n字体倾斜标签：`<i>待倾斜的数据</i>`\n\n插入字样式标签：`<ins>待插入字处理的数据</ins>`\n\n删除字样式标签：`<del>待删除字处理的数据</del>`\n\n字体右上方的插入数据标签：`100 <sup>向100右上方插入的数据</sup>`\n\n字体右下方的插入数据标签：`100<sub>向100右下方插入的数据</sub>`\n\n字体综合标签：`<font>字体综合数据……..</font>`\n\n\n\n![image-20211007152106254](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152106254.png)\n\n\n\n\n## 预览格式标签\n\n\n\n### HTML 内预留格式标签怎么写及其功能\n\n\n\n语法：\n```html\n<pre>预留格式的内容</pre>\n```\n\n\n\n功能：因为 HTML 源代码内的手动空行【非`<br>`标签】被浏览器解释执行后就会消失【自动去除手动空白】，因此我们自己设置的空白格式就会消失，这是就可以利用`<pre>`标签将自己设置的空白格式保留下来\n\n\n\n![image-20211007152131031](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152131031.png)\n\n\n\n使用 pre 标签\n\n\n\n![image-20211007152141513](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152141513.png)\n\n\n\n## 实体符号\n\n\n\n###  HTML 中实体符号的应用场景以及其格式\n\n\n\n应用场景：在 HTML 源代码内如果要写 <> 等数据，会被浏览器解释为标签符号，因此 <>这两个数据不会被显示，这是就要将 <> 换成实体符号\n\n格式：&开头    ；结尾 \n\n示例：&nbsp；\n\n\n\n\n\n\n### 常见的实体符号\n\n空格实体符号：&nbsp；\n\n大于号实体符号：&gt；\n\n小于号实体符号：&lt；\n\n\n\n![image-20211007152207483](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152207483.png)\n\n\n\n## HTML中的表格\n\n\n\n\n### HTML 中表格的图示原理\n\n![image-20211007152224309](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152224309.png)\n\n\n\n\n### 利用 HTML 代码创建一个表格\n\n![image-20211007152238412](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152238412.png)\n\n\n\n### 怎么对表格内的单元格进行合并【多行单元格合并与多列单元格合并】\n\n\n多行单元格合并与多列单元格合并图示\n\n![image-20211007152258968](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152258968.png)\n\n\n\n\n\n多行单元格合并口诀：将最后的单元格注释掉，在最前面的单元格内【td标签】添加 rowspan 属性，合并几个单元格就将 rowspan 的属性值设置几\n\n多行单元格合并图示：\n\n\n\n![image-20211007152315665](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152315665.png)\n\n\n\n多列单元格合并口诀：将其中一个单元格注释掉，在另外一个单元格内【td标签】添加 colspan 属性，合并几个单元格就将 rowspan 的属性值设置几\n\n多列单元格合并图示：\n\n![image-20211007152330416](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152330416.png)\n\n\n\n\n\n### HTML 中 th 标签的功能\n\n\n\n\n功能：th 标签可代替表格中的 td 标签，并且将 th 标签内的数据全部加粗居中显示，一般用于表格的标题信息处\n\n图示：\n\n![image-20211007152349462](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152349462.png)\n\n\n\n### HTML 的一个表格中 thead、tbody、tfoot三个标签的功能\n\n\n\n功能：把一个表格分为三部分，分别是表格头、表格体、表格脚，这样做在后期方便 JavaScript 进行处理\n\n\n\n\n图示：\n\n![image-20211007152406204](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152406204.png)\n\n\n\n\n\n## 浏览器界面设置背景色及背景图片\n\n\n\n### 在 HTML 内怎么为浏览器网页界面设置背景色及其背景图片\n\n\n\n设置网页背景色实现：在 HTML 的源代码的` <body>` 标签内添加一个叫做 bgcolor 的属性即可设置当前页面背景色\n\n\n\n设置网页背景图片实现：在 HTML 的源代码的 `<body> `标签内添加一个叫做 background 的属性即可设置当前页面背景图片\n\n\n\n![image-20211007152427027](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152427027.png)\n\n\n\n## 图片标签\n\n\n\n### HTML 中设置图片是什么标签\n\n\n\n答：是 `<img></img>` 标签\n\n\n\n注意：\n1：img 图片标签和在 body 标签内设置的浏览器页面背景图片是不一样滴\n2：如果一个标签内没有内容，那么就可以不写最后的标签，例如 `<img></img> `可以写成` <img />` \n\n\n\t\n\n### 图片标签的属性及其功能\n\n\n\n属性：\n\nsrc：设置图片的访问路径\ntitle：鼠标悬停在图片上时提示的文字信息\nwidth：用于设置图片的宽度\nalt：图片加载失败显示的文字信息\n\t\n\n注意：在利用 width 属性设置完图片宽度后，不可以在设置图片高度，因为图片的高度是根据宽度自动调整的！！\n\n\n\n![image-20211007152458321](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152458321.png)\n\n\n\n\n\n\n## 超链接标签\n\n\n\n### HTML 中超链接标签是什么及其超链接的特点\n\n\n\n超链接标签：\n```html\n<a href=“链接的网站或本地文件”>待连接的文本或图片</a>\n```\n\nhref：表示热链接\n\n\n\n超链接特点：\n\n1：超链接的 href 属性值可以是网站，也可以是本地文件\n2：超链接不仅可链接文本，还可以设置图片超链接\n3：指针悬停在超链接文本或图片上，鼠标指针变为一个小手\n4：超链接文本会自动在文本下面加上下划线\n5：鼠标悬停在超链接文本或图片上会自动在左下角显示连接的网站或者本地文件\n\n\n\n![image-20211007152556340](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152556340.png)\n\n\n\n### 超链接标签内的 target 属性的功能\n\n\n\ntarget属性值及其功能：\n\n\n\n_self：点击超链接在当前网页打开链接的网站\n_blank：点击超链接在新的网页打开链接的网站\n_parent：点击超链接在当前网页的父窗口打开链接的网站\n_top：点击超链接在当前网页的顶级窗口打开链接的网站\n\t\n\n\n\n\n注意：\n\n1：在不设置 target 属性值时，超链接默认在当前网页内打开！！\n2：父级窗口与顶级窗口是在网页内存在 iframe 标签时在生效\n3：iframe 标签是一个窗口中的内部窗口【常常用于网站登录！】\n\n\n\n![image-20211007152622061](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152622061.png)\n\n\n\n\n\n### herf与src属性的区别\n\n\n\n区别：href 属性只能用在超链接标签`<a>`与外部导入.css文件的`<link>`标签内，src 属性可用在很多标签内，例如 `<script>`、`<img>`、`<iframe`>等\n\n\n\n## 无序列表与有序列表\n\n\n\n### HTML内怎么创建无序列表\n\n\n\n实现标签：\n```html\n<ul><li></li></ul>    \n```\n\n【其中 ul 标签代表无序列表，li 标签代表列表项】\n\n\n\nul 标签的 type 属性值：\n\ncircle：列表项前面显示圆圈\ndisc：列表项前面显示圆点\nsquare：列表项前面显示方块\n\n\n\n注意：在无序列表内的列表项中还可以嵌套无序列表…….\n\n\n\n图示：\n\n![image-20211007152652994](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152652994.png)\n\n\n\n### HTML内怎么创建有序列表\n\n\n\n实现标签：\n```html\n<ol><li></li></ol>       \n```\n\n【其中 ol 代表有序表列标签  li 代表列表项标签】\n\n\n\n注意：在有序列表内的列表项中还可以嵌套有序列表…….\n\n\n\n图示：\n\n![image-20211007152716641](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152716641.png)\n\n\n\n### 无序列表与有序列表的区别\n\n\n1：无序列表用 `<ul>` 标签代表，有序标签用` <ol> `标签代表\n2：无序列表内的列表项前面的符号没有顺序，有序列表内的列表项前面的符号有顺序\n\n\n\n\n\n## Form表单\n\n\n\n### 什么是 from 表单及它有什么用？\n\n概念：form表单可收集用户的数据，并且带着这些数据一起发送给指定的网站服务器\n\n用途：form表单常常用来验证用户登录信息\n\n![image-20211007152741062](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152741062.png)\n\n\n\n### from 表单与 超链接的异同点\n\n\n\n相同点：form表单与超链接都可以向指定的网站服务器发送请求\n\n不同点：form可以带着用户填写的数据一起发送给网站服务器，超链接被点击后直接向网站服务器发送请求，用户不能填写数据\n\n\n\n### HTML 怎么创建简单的表单并且提交表单\n\n\n\n创建表单标签：\n```html\n<form action=”目标网站“></form>         \n```\n【action属性值代表提交表单时向哪个网站服务器发送请求，一般填写网站】\n\n\n\n\n提交表单的实现：在` <form></form> `标签内嵌套一个`<input>`标签，且 type 属性值为 submit 的按钮，点击这个按钮即可提交表单！！\n\n\n\n表单对象的属性值：\naction：类似于超链接标签内的 href 属性，代表向哪个服务器提交表单，一般值都是网站地址\n\n\n\n注意：\n1：所有能够提交表单的按钮，其 type 属性值都为 submit类型【目前来说】\n2：想要提交一个表单，那么 `<input/>` 标签 type 属性值为 submit 的按钮必须在 form 表单内定义\n3：一个网页内可以有多个表单对象\n\n\n\n![image-20211007152804841](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152804841.png)\n\n\n\n\n\n### 四：实现重置表单\n\n\n\n实现标签：\n```html\n<input type=\"reset\" value=\"重置表单\" />\n```\n\n注意：重置表单的标签必须在 form 表单内才可以重置表单\n\n\n\n![image-20211007152818903](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152818903.png)\n\n\n\n\n\n### HTML 内一个 Form 表单对象的组成【自己总结版本】\n\n\n\n组成：表单项、提交表单按钮\n\n表单项：用于接收用户填写的数据\n\n提交表单按钮：向指定网站服务器提交表单发起请求\n\n注意：提交表单按钮不能有 name 属性哦\n\n![image-20211007152845385](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152845385.png)\n\n\n\n### 在 Form 表单内怎么实现点击按钮即可携带用户填写的数据向指定服务器提交表单\n\n\n\n实现：\n\n1：在所有获取用户数据的表单项的标签内必须要有 name 属性！\n2：提交表单按钮的 type 属性值必须为 submit\n3：书写提交表单按钮的标签位置必须要在 Form 标签内部！\n\n\n\n\n注意：\n1：在最终提交表单的时候，表单项内有name属性的才会被提交，没有name属性的不会被提交哦\n\t\n2：提交表单按钮不能设置name属性值，要不然就会把提交表单的 value 提交上去….\n\t\n3：浏览器向服务器提交表单的 url 格式为 ： 服务器地址?表单项name属性值=表单项的value值&表单项name属性值=表单项的value…【非常重要】\n\t\n4：上面的提交表单 url 格式是 W3C 制定的标准所有浏览器都需要遵守…\n\t\n\n实现提交表单\n\n![image-20211007152908195](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152908195.png)\n\n\n\n注意事项第二条图示：\n\n\n\n![image-20211007152919736](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152919736.png)\n\n\n\n\n\n### 创建一个简单的登录表单\n\n\n\n![image-20211007152931868](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007152931868.png)\n\n\n\n\n## input输入域的type属性\n\n\n\n### HTML 中 input 输入域标签\n\n标签简介：input 输入域标签是用来获取用户输入及其选择的数据的，input标签中的 type 属性值可设置input标签为文本框或者密码框、单选框、复选框、普通按钮、提交表单按钮、重置表单按钮等等…\n\t\n\t\n### HTML 中 input 输入域标签中的 type 属性的一些常用值及其对应的样式\n\ntype属性值：\n\ntext：当前 input 输入域标签变为文本框\n\t\t\npassword：当前 input 输入域标签变为密码框\n\t\t\nradio：当前 input 输入域标签变为单选框\n\t\t\ncheckbox：当前 input 输入域标签变为复选框【多选框】\n\t\t\nbutton：当前 input 输入域标签变为普通按钮\n\t\t\nsubmit：当前 input 输入域标签变为提交表单按钮\n\t\t\nreset：当前 input 输入域标签变为表单重置按钮\n\t\t\nfile：当前 input 输入域标签变为文件选择按钮\n\t\t\nhidden：当前 input 输入域标签变为隐藏域\n\n\n\n注意：\n\n1：在指定的一组单选框与复选框中的一个框内设置 checked 属性【复选框可多选】，默认选择当前的单选框或者复选框…..\n2：同一组的单选框name属性值都要一致…..否则会出现单选框可以多选的情况\n3：同一组的复选框的name属性值都要一致……\n4：除了文本框与密码框与文字域，其他的组件的value值需要自己定义，上面三种可从用户填写获取\n\n\n\n![image-20211007153002309](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153002309.png)\n\n\n\n提交表单与重置表单按钮：\n\n![image-20211007153016955](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153016955.png)\n\n\n\n\n\n\n## 下拉列表与文字域标签\n\n\n\n### HTML 中创建下拉列表的标签\n\n\n\n实现标签：\n```html\n<select><option>下拉列表的值1</option></select>\n```\n\n\n\noption 标签内的 selected 属性值功能：在哪个 option 标签上设置 selected 属性值，那么下拉列表就默认选择哪个数据\n\n\n\n![image-20211007153042037](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153042037.png)\n\n\n\n\n\n###  HTML 中创建文字域的标签\n\n\n\n标签实现：\n\n```html\n<textarea></textarea>\n```\n\n文字域功能：用来接收用户填写的大量数据…\n\n\n\n标签属性：\nrows：设置文字域占浏览器几行\ncols：设置文字域占浏览器几列\n\t\t\n\n注意：文字域可以接收用户填写的数据，因此文字域标签内不需要设置 value 属性..\n\n\n\n![image-20211007153101341](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153101341.png)\n\n\n\n## 实现简单的注册表单\n\n\n\n\n\n### 利用上面所学的知识创建一个用户注册的提交表单\n\n![image-20211007153123304](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153123304.png)\n\n\n\n\nps：上面的注册表单提交后，浏览器会携带具有name属性值的标签的 value 值跳转到百度网站页面，浏览器的地址栏数据如下：\n\n地址：https://www.baidu.com/?username=askdskad&userpsd=asdasdasd&gender=male&hubby=basketball&hubby=swim&Education=benke&Introduction=woaini\n\n\n\n\n## 文件控件\n\n\n\n### HTML 中怎么创建文件控件\n\n实现语法：\n```html\n<input type=\"file\" value=\"选择文件\" />\n```\n\n![image-20211007153140603](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153140603.png)\n\n\n\n\n\n## 隐藏域\n\n\n\n### HTML 中隐藏域组件的功能\n\n功能：开发者不希望用户在填写表单时看到一些信息，但是提交表单数据时这些数据还要提交，那么就可以利用隐藏域进行实现，隐藏域在浏览器上是看不到的哦\n\n\n\n### HTML 中怎么创建隐藏域组件\n\n实现语法：\n```html\n<input type=\"hidden\" name=\"one\" value=\"two\" />        \n```\n\n【name属性和value属性不是必须的，在充当表单项时才必须】\n\n\n\n![image-20211007153207718](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153207718.png)\n\n\n\n## 文本框的三种常用属性\n\n\n\n\n### HTML 文本框的 readonly 与 disabled 属性的功能及其异同点\n\n\n\n readonly属性功能：被装饰的文本框不能写入数据，只能看到数据\n\n disabled属性功能：被装饰的文本框不能写入数据，只能看到数据【只读】\n\n\n\n\n异同点：\n\n\n相同点：修饰的文本框都只能读，不能对文本框内的数据进行修改\n\n\n不同点：如果修饰的是 Form 表单内的文本框【表单项】，那么在提交表单时 readonly属性修饰的文本框可被提交，disabled则不可以\n\n\n\n![image-20211007153235324](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153235324.png)\n\n\n\n\n### HTML 文本框的 maxlength 属性功能\n\nmaxlength 属性功能：限制文本框最多输入的数据长度\n\n语法格式：maxlength = \"3\"     [文本框内最多输入三个字符数据]\n\n\n\n![image-20211007153248213](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153248213.png)\n\n\n\n\n\n\n## HTML 标签中的 id 属性\n\n\n\n### HTML 所有标签中的 id 属性\n\n\n\nid属性详解：\n\n1：在 HTML 文档中任何结点标签都是存在 id 属性的，主要是看开发者写不写这个 id 属性\n\t\t\n2：一个结点标签的 id 属性就是这个结点的身份证号，每一个结点的 id 属性值都唯一…\n\t\t\n3：不同的结点中 id 的属性值是不可能相同的\n\n结点 id 属性的功能呢个：方便后期 JS 代码查找某个结点，对这个结点进行增删改查，实现网页的动态效果….\n\n\n\n![image-20211007153309804](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153309804.png)\n\n\n\n\n\n## div与span图层标签\n\n\n\n### 认识 div 标签与 span 标签\n\n\n\ndiv 与 span 标签概念：这两个标签相当于浏览器页面的图层，把浏览器整个页面比作一张图片，在页面上的 div 与 span 标签就是这个图片上面的图层\n\n\n\ndiv 与 span 标签功能：页面布局，在很久之前浏览器页面布局需要用 table 布局，现在全都用div+span了，因为它们非常灵活【图层之间的嵌套等，图层可以在页面任何位置出现等..】\n\n\n\ndiv 与 span 标签定位：可以这两个标签比作盒子，在盒子的左上方有 x、y坐标，就通过这个坐标对 div 与 span 标签进行定位，后期学CSS实现图层定位！\n\n\n\ndiv 与 span 标签差异：div图层标签独占一行，span图层标签不独占一行\n\n\n\n图示：\n\n\n\n![image-20211007153327855](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007153327855.png)\n\n\n\nHTML基础知识完毕.....\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["HTML基础"],"categories":["HTML基础"]},{"title":"JavaScript--JSON相关","url":"/2021/10/07/JavaScript-JSON相关/","content":"\n\n\n*本文主讲：什么是 JSON 以及应用场景、JS 中创建 JSON 对象以及获取 JSON 对象内的数据、了解XML、复杂的 JSON、JS 中的 eval 函数*\n\n<!--more-->\n\n\n## 什么是 JSON 以及它的应用场景\n\n\n\n概念：JSON 也就是 JavaScript Object Notation 【JavaScript对象标记】，JSON是一种 标准的轻量的数据交换格式\n\n\n\n应用场景：不同系统【编程语言】之间的数据通信，例如一号APP是利用 flutter 语言开发的，另外一款二号APP是利用 java 开发的，这两款APP要进行数据库的数据交换，那么一号APP就可以利用 flutter语言从数据库取出数据并且封装为 JSON 字符串数据类型，发给二号APP，二号APP在通过 java语言将 JSON 的数据进行解析，把数据在存入数据库内，这样不就完成不同系统之间的数据交换了嘛~\n\n\n\nJSON的特点：标准的、体积小【轻量】、易解析\n\n\n\n常见的数据交换格式：JSON 、XML\n\n\n\nXML：可扩展标记语言，XML也常常用来做数据交换格式，但是它体积大、不易解析、优点是语法严谨，常常用于银行的业务中\n\n\n\n\n\n\n## JS 中创建 JSON 对象以及获取 JSON 对象内的数据\n\n\n\n\n创建 JSON 对象语法：var jsonObj = {“key1”：“value1”，“key2”：“value2”，………}\n\n\n\n获取 JSON 对象内数据的两种语法：\n\n```javascript\nvar data = JSON对象.key值\t\t\t\t\t\nvar data = JSON对象 [ key值 ]\n```\n\n​\t\t\t\n\n![image-20211007122107585](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007122107585.png)\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\n## 了解XML\n\n\n\n### 什么是 XML 及其应用场景\n\n\n\n概念：XML就是可扩展标记语言，它与HTML是同一个父亲，XML是一种体积大、解析麻烦、语法严谨的数据交换格式语言\n\n\n\nXML与HTML对比：\n\n\n\n共同点：都有共同的父亲 SGML【标准通用标记语言】\n\t\t\t\n\n区别：\n\nHTML：用于前端页面数据的展示，因此语言不是特别严谨\nXML：用于数据的存储以及数据描述，语法相当严谨，体积大、解析麻烦\n\t\t\t\t\n\nXML应用场景：因为语法严谨，所以常常做与钱有关的数据交换格式【例如银行系统】\n\n\n\n### 怎么创建 XML 文件以及略知 XML 文档的语法\n\n\n\n创建 XML 文件：文本文本把后缀改为小写的 xml 即可\n\n\n略知 XML 文档语法：\n\n![image-20211007122143612](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007122143612.png)\n\n\n\n浏览器运行这个 XML 文件效果\n\n![image-20211007122157462](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007122157462.png)\n\n## 复杂的 JSON\n\n\n\n### JS 中如何创建复杂的 JSON 对象 【JSON对象内嵌套JSON对象等…】\n\n\n\n复杂的JSON对象：\n\n\n\nJSON对象内嵌套 JSON 对象\n数组内嵌套 JSON 对象\nJSON对象内嵌套数组等\n\t\t\t\n\t\t\t\n注意：\n1：JSON对象的 key 值必须是字符串数据类型\n2：JSON 对象内的 value 可以是任何数据类型的数据，比如 Number、Boolean等\n\n\n\n![image-20211007122223334](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007122223334.png)\n\n\n\n\n## JS 中的 eval 函数\n\n\n\n### JS 中 eval 函数的用法及其功能\n\n\n\n功能：在JS脚本块内，把字符串数据类型的数据解释执行为 JS 代码\n\n\n\n语法：window.eval（“var i = 100”）   这段代码就等价于    var i = 100\n\n\n\n应用场景：不同系统之间进行通信，java语言写的系统从数据库内提取数据并打包为 JSON 格式的字符串发送给 JavaScript语言写的系统，因为发送过来的是字符串，因此 JavaScript 要想办法将这个字符串转为 JSON 对象，因此 JavaScript 就要用到 eval 函数进行转换喽~\n\n![image-20211007122243267](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007122243267.png)\n\n\n\n\n\n\nJavaScript完.........\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript--BOM编程","url":"/2021/10/07/JavaScript-BOM编程/","content":"\n\n\n\n\n*本文主讲：JS 对浏览器窗口进行操作、设置浏览器的两种弹、JS 代码实现浏览器页面的前进和后退、JS代码更改浏览器地址栏地址进入指定网站、浏览器向服务器发送请求的几种方式*\n\n<!--more-->\n\n\n\n## JS 对浏览器窗口进行操作\n\n\n\n### BOM 编程的要领\n\n\n\n\n答：BOM编程是对浏览器窗口进行操控，也就是说在 BOM 编程中的顶级类为 window，window类就代表浏览器窗口\n\t\n\t\n### JS 代码如何实现打开指定的浏览器窗口\n\n\n\n实现方法：window.open（“https://www.baidu.com/”）    【在当前页面打开一个百度的新窗口】\n\n\n\n注意：\n\n1：window.open（）方法不仅可以实现打开新窗口，还可以在当前页面打开窗口，以及打开父窗口，这里我他妈的就不想写了\n\n2：window.open（）方法可以打开自己写好的 html 文件\n\n\n\n\n\n\n### JS 代码如何实现关闭当前页面的浏览器窗口\n\n\n\n实现语法：window.close（）     【关闭当前窗口】\n\n![image-20211007121306804](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007121306804.png)\n\n\n\n## 设置浏览器的两种弹窗\n\n\n\n\n### JS 中如何生成消息框以及确定框\n\n\n\n生成消息框语法：window.alert（消息窗显示的数据）\n\n\n\n生成确定框语法：var boolData = window.confirm（确认框显示的数据）\n确认框应用场景：删除数据是进行提示是否要删除数据\n\n\n\n消息框以及确认框的区别：消息框就是弹出一个消息，确认框的话有两个按钮，一个是确认一个是取消，用户点击确认返回 true，点击取消返回 false\n\n\n\n注意：确认框是有返回值的，用户点击确认返回 true，点击取消返回false\n\n\n\n![image-20211007121333573](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007121333573.png)\n\n\n\n\n## JS 代码实现浏览器页面的前进和后退\n\n\n\n### 利用 JS 代码实现浏览器页面的后退【回到历史页面】的两种方式\n\n\n\n第一种方式：window.history.back（）    【这种方法可以回到最近的一层历史页面】\n\n第二种方式：window.history.go（-1）     【这种方式原本用来控制页面的前进，但是前进 -1 页不就是后退一页嘛~】\n\n\n\n![image-20211007121354357](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007121354357.png)\n\n\n\n### 利用 JS 代码实现浏览器页面的前进\n\n\n\n实现方式：window.history.go（1）   【如果当前页面是从其他页面退回来的，那么这样就可以回到原页面】\n\n\n\n注意：想要实现页面的前进，必须在之前去过那个页面【在那个页面返回来的】\n\n![image-20211007121404007](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007121404007.png)\n\n\n\n## JS代码更改浏览器地址栏地址进入指定网站\n\n\n\n### JS 代码更改浏览器地址栏的地址进入指定网站的两种方式\n\n\n\n第一种方式：通过 windos 对象的 location 属性的 href 属性实现，当然href也可以省略\n\n\n\n实现语法：\n\n```javascript\nwindow.location.href = “https://www.baidu.com/“ \n```\n\n【更改浏览器地址栏的地址为 https://www.baidu.com/】\n\n```javascript\nwindow.location =“https://www.baidu.com/”\n```\n\n\n\n第二种方式：通过 document 对象的 location 属性的 href 方法实现，当然这个 href 也可以省略\n\n\n\n实现语法:\n\n```javascript\ndocument.location.href = “https://www.baidu.com/”    \n```\n\n【更改浏览器地址栏的地址为 https://www.baidu.com/】\n\n```javascript\ndocument.location = “https://www.baidu.com/”\n```\n\n\n\n![image-20211007121502526](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007121502526.png)\n\n\n\n\n\n\n## 浏览器向服务器发送请求的几种方式\n\n\n\n1：提交form表单\n\n\n2：点击超链接\n\n3：window.location.href=“目标链接”\n\n\n4：document.location.href=“目标链接”\n\n\n5：window.open（指定链接）\n\n6：在浏览器地址栏内输入地址\n\n\n\n持续更新中......\n\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript--DOM编程","url":"/2021/10/07/JavaScript-DOM编程/","content":"\n\n\n\n*本文主讲：什么是DOM编程、JS 代码操作文本框内的数据、JS 中元素标签的innerHTML与innerText属性功能、正则表达式、JS 中为字符串去除两端空白、正则表达式验证邮箱、获取下拉列表的value值、JS 中获取系统时间以及时间戳毫秒数、JS 中的周期函数 setInterval（）、JS 中创建数组等.....*\n\n<!--more-->\n\n\n\n## 什么是DOM编程\n\n\n\n### JavaScript 都包括什么？\n\n\n\n\nJavaScript包括三部分如下：\n\nECMAScript：JavaScript的核心语法【变量、控制语句、函数、对象等】\n\n\n\nDOM编程：Document Object Modle【页面对象模型】，对网页的组件结点进行增删改的过程，整个网页是由一个一个结点元素组成，这些结点元素统称为DOM树！\n\n\n\n核心实例代码：var elmObj = document.getElementById（“指定节点的id属性值”）    【通过id属性值获取指定节点对象】\n\n\n\nBOM编程：Browser Object Modle【浏览器对象模型】，对浏览器窗口进行编程，例如浏览器页面的前进、后退、刷新，关闭浏览器窗口等等操作\n\n\n\n\n\n### JS 中 DOM 与 BOM 的联系与区别\n\n\n\n两者的区别：\nDOM：DOM的顶级对象是 JS 中内置的 window \nBOM：BOM的顶级对象是 JS 内置的 document\n\t\t\n\n两者的联系：BOM其实包括DOM，因为 document.getElemetById（…..）可以写成 window.document.getElemetById（…..），window省略了！\n\n\n\nDOM与BOM两者关系图：\n\n\n\n![image-20211007115659940](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115659940.png)\n\n\n\n## JS 代码操作文本框内的数据\n\n\n\n\n### 如何用 JS 代码获取文本框内的数据并且修改这个数据呢？\n\n\n\n第一步：获取指定文本框结点对象\n\n第二步：通过文本框结点对象的 value 属性获取文本框内的数据，并且修改\n\n![image-20211007115724338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115724338.png)\n\n\n\n\n### 在HTML组件的事件句柄属性后面添加 this.属性名 代码的含义\n\n\n\n\n代码格式：\n```html\n<input type=\"button\" value=\"点我\" id=\"one\"  onclick=\"alert(this.value)\"/>\n```\n\n代码详解：this代表当前节点对象，this.value 代表获取当前节点的value属性值！\n\n\n\n![image-20211007115743600](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115743600.png)\n\n\n\n## JS 中元素标签的innerHTML与innerText属性功能\n\n\n\n### 怎么为 div 标签设置 css 样式\n\n\n\n代码如下：\n\n\n\n![image-20211007115802275](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115802275.png)\n\n\n\n注意：上图的代码在 style 标签内忘记添加了 type=“text/css”属性！\n\n\n\n\n\n### JS 中元素标签【div、span】的innerHTML与innerText属性的功能以及用法\n\n\n\nps：这里我们以 div 标签的innerHTML和innerText属性为例！\n\n\n\n\n\n功能：\n\ninnerHTML属性：为指定节点元素【div】设置【添加等】一段数据，设置的数据会被 innerHTML解释执行为 HTML 代码\n\t\ninnerText属性：为指定节点元素【div】设置【添加等】一段数据，设置的数据不管是不是HTML代码都会被 innerText解释执行为普通文本\n\n\n语法：\ninnerHTML属性语法：待设置数据的标签对象.innerHTML = “HTML代码或者普通文本”\n\t\ninnerText属性语法：待设置数据的标签对象.innerText = “普通文本”\n\t\n\n\n\n注意：\n\n1：innerHTML属性会把赋值的字符串解释执行为HTML代码，innerText赋值的字符串即使是HTML代码也被解释为普通文本\n2：innerHTML与innerText属性为div或者span标签设置数据时，如果这两个标签原来就有数据，那么在重新设置就是替换\n\t\n\n图示：\n\ninnerHTML属性：\n\n![image-20211007115858062](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115858062.png)\n\n\n\ninnerText属性：\n\n![image-20211007115912338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115912338.png)\n\n\n\n\n\n\n## 正则表达式\n\n\n\n\n\n### 什么是正则表达式\n\n\n\n![image-20211007115927045](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007115927045.png)\n\n\n\n\n\n\n### 正则表达式中的常用符号\n\n答：参考之前学过的正则表达式\n\n\n\n\n\n### 在 JS 中创建正则表达式对象的两种方式\n\n\n\n第一种方式：通过字符的方式直接创建字符串对象变量\n\n\n\n语法：var regExp = /正则表达式或普通字符串/attributes\n\n\n\n语法示例：var regExp=/ [0-9a-z] / g\n\n\n\nattributes参数含义：attributes参数代表三个可选字符，也就是“g”，“i”，“m”\n\n\n\n“g”：通过正则表达式对全文进行检索\n\t\t\t\t\n“i”：匹配数据时严格区分大小写\n\t\t\t\t\n“m”：多行搜索，如果/…/内的数据为正则表达式，attributes的值一定不能为 “m”\n\t\t\t\n\n​\t\n\n注意：\n1：如果/…/内的数据为正则表达式，attributes的值一定不能为 “m”\n\n2：在以后的编程中如果看见 /……./ 格式的数据，那就是正则表达式\n\n\n\n图示：\n\n![image-20211007120005651](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120005651.png)\n\n\n\n第二种方式：通过 JS 内置的 RegExp 类来创建正则表达式对象\n\n\n\n语法：var regObj = new RegExp（“正则表达式”，attributes参数）\n\n语法示例：var regExp = new RegExp（“[0-9a-z]”，\"g\"）\n\nattributes参数含义：与第一种方式一致\n\n\n\n![image-20211007120024664](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120024664.png)\n\n\n\n\n\n### JS 中正则表达式对象三种方法的功能【最常用的是 text 方法】\n\n\n\n方法1：正则表达式对象.test（“待匹配的字符串”）  【重要，常常用于验证邮箱格式是否正确！】\n\n\n方法1功能：根据正则表达式从待匹配的字符串内匹配数据，成功匹配返回 true，失败返回false\n\n\n注意：方法名是 test，不是 text\n\n\n———————————————————————————————————————————\n\n方法2：正则表达式对象.exec（“待匹配的字符串”）\n\n\n方法2功能：根据正则表达式从待匹配的字符串内匹配数据，成功匹配返回匹配的字符串，失败返回 null\n\n\n\n———————————————————————————————————————————\n\n方法3：正则表达式.compile（“更改后的正则表达式”）\n\n![image-20211007120048366](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120048366.png)\n\n\n\n\ntest方法图示：\n\n\n\n![image-20211007120058586](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120058586.png)\n\n\n\n\n\n\n## JS 中为字符串去除两端空白\n\n\n\n\n\n### JS 中 trim（）方法可以为字符串去除两端空白\n\n\n\n\n语法：var 接收去除空白的字符串变量 = 待去除空白的字符串.trim（）\n\n应用场景：表单验证用户邮箱时，如果用户在邮箱两侧加上了空白，我们可以给它去除掉\n\n\n\n![image-20211007120114977](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120114977.png)\n\n\n\n\n## 正则表达式验证邮箱\n\n\n\n核心代码：\n\n![image-20211007120130136](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120130136.png)\n\n\n\n\n整段代码保存路径：G:\\Codefile\\JavaScript编程\\JavaScript初步学习\\DOM编程\\利用正则表达式验证邮箱格式.html\n\n\n\n\n\n## 获取下拉列表的value值\n\n\n\n\n### JS 代码怎么获取下拉列表的 value 的值\n\n![image-20211007120144411](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120144411.png)\n\n\n\n\n## JS 中获取系统时间以及时间戳毫秒数\n\n\n\n### 在 JS 代码中如何获得系统的时间\n\n\n\n答：通过 JS 的内置类 Date（）来获取\n\n\n\n获取语法：\n\nvar 系统时间变量名 = new Date（）     【获取系统当前时间】\n\ndocument.write（系统时间变量名）       【将系统时间在浏览器页面上显示出来】\n\n![image-20211007120208166](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120208166.png)\n\n\n\n\n通过这个系统时间格式化输出其他格式的时间\n\n![image-20211007120221516](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120221516.png)\n\n\n\n### 在 JS 代码中如何获得系统的时间戳毫秒数【现在距离1970年1月1日多少毫秒】\n\n\n\n答：通过 Date（）类实例化对象的getTime方法来获取\n\n语法格式：var times = new Date（）.getTime（）\n\n![image-20211007120244395](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120244395.png)\n\n\n\n\n\n## JS 中的周期函数 setInterval（）\n\n\n\n### JS 中周期函数 setInterval（）的功能及其用法\n\n\n\n\n功能：周期函数 setInterval（）的功能就是每间隔多长时间执行一次某函数~【用于创建数字时钟】\n\n语法：result = setInterval（周期执行函数名，时间间隔）\n\n语法示例：result = setInterval（“code（）”，1000）\n\n语法解释：每间隔 1000 毫秒 执行一次 code 函数，并且每执行一次有一个返回值 result\n\n\n\n\n\n注意：\n\n1：result 是 setInterval 函数运行的的返回值，用于停止周期函数的运行\n2：周期函数的第一个参数要加“”，第二个参数是毫秒\n\n![image-20211007120309385](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120309385.png)\n\n\n\n\n\n### JS 中怎么停止周期函数的运行….\n\n答：周期函数运行的时候不是有返回值嘛，把这个返回值传给 window.clearInterval（）函数即可停止周期函数\n\n\n\n语法：\n\nresult = setInterval（“code（）”，1000）     【周期函数没间隔1秒执行一次 code函数，并且返回值 result】\n\nwindow.clearInterval（result）                       【将上面的返回值传给这个函数，即可停止周期函数的执行】\n​\t\t\n\n![image-20211007120343279](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120343279.png)\n\n\n​\t\t\n\n## JS 中创建数组\n\n\n\n### JS 中创建数组的两种方式\n\n第一种方式：直接创建\n\n创建语法：var 数组变量名 = [元素1，元素2，元素3]\n\n\n\n注意：\n\n1：数组内的元素数据类型不限，元素数量也不限\n\t\n2：如果创建的数组长度为 6【索引最大为5】 ，我们这样操作数据： 数组变量名[7] = “啦啦” 虽然索引为 7 ，但是也自动添加索引为6的数据为“啦啦”\n\n![image-20211007120408250](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120408250.png)\n\n\n\n第二种方式：通过 JS 内置的 Array（）类创建\n\n创建语法：\n\t\t\nvar arr = new Array( )                     [创建长度为0的数组 arr]\n\t\t\nvar arr = new Array（3）             【创建长度为3的数组  arr】\n\t\t\nvar arr = new Array（6，8）        【创建长度为2的数组 arr 数组内有两个元素 6与 8】\n\t\t\n\t![image-20211007120422605](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120422605.png)\t\n\t\n\t\t\n\n### JS 中数组的几种方法及其功能\n\n\n\n数组常用方法：\n\n\n\nvar str1 = 数组对象.join（“-”）：将数组内的元素全部通过“-”进行拼接为一个字符串传给  str1 变量\n\t\t\t\n数组对象.push（“lala”）：在数组的最后面增加“lala”元素数据\n\t\t\t\nvar data = 数组对象.pop（）：把数组的最后面一个元素弹出来传给 data 变量\n\t\t\t\n数组对象.reverse（）：把数组对象内的元素数据进行反转，第一个元素变为最后一个元素\n\n\n\n\n\n\n注意：JS 中的数组可以自动模拟栈模型，数组的push方法模拟数据入栈，pop方法模拟数据出栈【栈模型数据先入后出】\n\n\n\n![image-20211007120445924](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007120445924.png)\n\n\n\n持续更新中.....\n\n\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript--控制语句","url":"/2021/10/07/JavaScript-控制语句/","content":"\n\n\n本文主讲：JS 中常用的分支语句、JS 中常用的循环语句、for in遍历循环、with语句的用法\n\n<!--more-->\n\n\n## JS 中常用的分支语句\n\n### JS 中常用的分支语句及其语法格式\n\n\n\n常见分支语句：if、if-else、if-else-if、switch-case、三目运算符【条件 ？：】\n\n\n\n\nif 语句与 if-else 语法格式：\n\nif语句：\n\n![image-20211007113916129](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113916129.png)\n\n\n\n\nif-else：\n\n![image-20211007113934275](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113934275.png)\n\n\n\n\nif-else-if 语法格式：\n\n\n\n![image-20211007113946943](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113946943.png)\n\n\n\nswitch-case语法格式：\n\n\n\n注意：\n\n1：switch括号里面一般传入的都是一个变量！\n\n2：不要忘记 case 后面的 ：\n\n\n\n![image-20211007114002086](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114002086.png)\n\n\n\n三目运算符语法格式：\n\n\n\n![image-20211007114014024](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114014024.png)\n\n\n\n## JS 中常用的循环语句\n\n\n\n### JS 中常见的循环语句及其语法格式\n\n\n\n\n常见循环语句：while、do-while、for\n\nwhile循环语法格式：\n\n![image-20211007114047290](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114047290.png)\n\n\n\ndo-while语法格式：\n\n注意：这种循环方式比较占用内存，实际开发中用这个形式的循环很少见！！\n\n![image-20211007114058720](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114058720.png)\n\n\n\nfor循环语法格式：\n\n注意：for 循环括号里面的两个 ；必须要写！！！\n\n\n\n![image-20211007114112674](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114112674.png)\n\n\n\n### JS 中关键字 break 以及 continue 的作用\n\n\n\n\nbreak：在循环体内遇到 break 直接跳出当前循环\n\ncontinue：在循环体内遇到 continue 关键字跳出本次循环，继续执行下次循环\n\n\n\n![image-20211007114121679](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114121679.png)\n\n\n\n\n## for in遍历循环\n\n\n\n### for in 循环遍历的两种应用场景\n\n\n\n第一种应用场景：循环遍历 JS 中的数组【列表】，获取数组内的数据\n\n第二种应用场景：遍历 JS 中的实例化对象，从而获取对象内的所有属性名【属性名全部都是字符串】\n\n\n\n\n\n### for in 循环遍历元组的语法\n\n\n\n语法：for（var i in 元组名）{ }\n\n\n\n注意：\n\n1：JS 内元组的数据类型和数据的数量不限\n\n\n\n2：for in 循环遍历元组，变量 i 获得的只是元组内元素的下标索引，要想获取元组内数据，需要    元组名[获取到的数据下标索引]\n\n\n\n![image-20211007114220755](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114220755.png)\n\n\n\n\n### for in 循环遍历 Object 对象的语法\n\n\n\n\n语法：for（var i in Object实例化的对象）{  ……  }\n\n功能：获取实例化对象内所有的属性名称，从而根据属性名称获取实例化对象属性值\n\n注意：for in 循环遍历 Object 对象获取到对象的属性名是字符串形式的！！！\n\n\n\n![image-20211007114315247](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114315247.png)\n\n\n\n\n## with语句的用法\n\n\n\n\nwith语句功能：简化代码\n\nwith语句语法：with（对象名）{ }\n\n\n\n![image-20211007114328639](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007114328639.png)\n\n\n\n持续更新中......\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript--键盘鼠标事件","url":"/2021/10/07/JavaScript-键盘鼠标事件/","content":"\n\n\n\n*本文主讲：JS中常用事件、JS中回调函数、JS 中代码因执行顺序报错的两种解决办法、获取页面标签（组件）的属性并修改、JS 中事件执行后怎么获取事件对象、JS 代码捕获键盘按下指定键子事件、JS 代码执行指定事件等*\n\n<!--more-->\n\n\n\n## JS 中常用的事件\n\n\n\n### JS 中常用的几种事件【知道事件名称和功能】\n\n\n\nblur：网页内容失去焦点【光标移动到了其他地方】发生的事件\nfocus：网页内容获取焦点【光标移动到了自己这里】发生的事件\n\n\n\nkeydown：键盘按下发生的事件\nkeyup：键盘键子 弹起发生的事件\n\n\n\nclick：鼠标单击发生的事件\ndblclick：鼠标双击发生的事件\n\n\n\nmousedown：鼠标按下发生的事件\nmouseup：鼠标弹起发生的事件\nmouseover：鼠标经过发生的事件\nmousemove：鼠标移动发生的事件\nmouseout：鼠标离开发生的事件\n\n\n\nreset：重置表单发生的事件\nsubmit：提交表单发生的事件\n\n\n\nchange：下拉列表框内的选项产生变化发生的事件\n\nselect：文本被选中发生的事件\n\nload：整个网页的全部组件元素加载完毕发生的事件【非常重要】\n\n\n\n![image-20211007110746635](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007110746635.png)\n\n\n\n\n\n注意：\n1：任何事件都有其对应的事件句柄，就是在事件前面加上一个 on ，例如onclick、onkeydown\n\n\n\n2：事件句柄以属性的形式存放在 HTML 标签内！  \n\n例如 \n```html\n<input type=\"button\" value=\"hello\" onclick=\"JS 代码\"/>  \n```\n\n里面的 onclick 属性就是鼠标单击的事件句柄！\n\t\n\n\n\n### JS 中注册事件【事件存在】的两种方式\n\n\n\n第一种方式：把事件以事件句柄的方式注册到HTML标签组件的属性之中，当在这个标签组件上发生了该事件，事件句柄后的JS代码被执行\n\n\n\n![image-20211007110801213](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007110801213.png)\n\n\n\n第二种方式：通过纯 JS 代码实现注册事件\n\n第一步：在脚本块外创建某一个标签组件\n\n第二步：创建需要回调的函数\n\n第三步：获取这个结点对象\n\n第四步：为这个结点对象的指定事件句柄添加回调函数【函数不能加括号】\n\n\n\n![image-20211007110816282](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007110816282.png)\n\n\n\n注意：\n\n1：document与window类似，都是JS内置的对象，document代表当前页面内的源代码，window代表当前页面的窗口！\n\n2：为标签组件对象的指定属性赋值【回调函数】时，回调函数不能加括号！\n\n\n最常用方式：通过对第二种方式的合并加上匿名函数实现注册事件\n\n\n\n![image-20211007110830488](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007110830488.png)\n\n\n\n注意：通过事件句柄注册的回调函数，浏览器打开这个函数并不会执行，只有在指定组件上发生了指定事件，回调函数才会执行\n\n\n\n\n\n## JS 中的回调函数\n\n\n\n\n概念：JS 中的回调函数就是开发者写好一个函数，但自己不去主动调用它，等待其他用户【程序】的主动调用\n\n\n\n![image-20211007112948933](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007112948933.png)\n\n\n\n\nps：浏览器打开注册到按钮上的回调函数并不会执行，当这个按钮被点击之后，那个回调函数才会执行！\n\n\n\n\n\n\n## JS 中代码因执行顺序报错的两种解决办法\n\n\n\n\n### JS 中注册事件后因为 JS 代码执行顺序程序报错的现象\n\n\n\n![image-20211007113014715](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113014715.png)\n\n\n\n\n### JS 中解决注册事件后因为 JS 代码执行顺序程序报错的两种方式\n\n\n\n第一种方式：在 body 标签内添加属性名为onload，属性值为回调函数的属性\n\nps：load事件是当页面内全部组件数据加载完毕才会被触发执行的事件\n\n\n\n![image-20211007113047068](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113047068.png)\n\n\n\n\n第二种方式【最常用】：通过 window.onload 方式解决\n\n注意：其实第二种和第一种解决问题的方式原理是一样的！\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113047068.png)\n\n\n\n## 获取页面标签（组件）的属性并修改\n\n\n\n### JS 代码怎么获取页面内的组件【标签】的属性并且修改这个属性值\n\n\n第一步：通过 JS 代码获取组件标签对象\n\n第二步：获取组件标签对象内的属性并且修改属性值\n\n\n\n![image-20211007113118268](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113118268.png)\n\n\n\n\n注意：一个HTML组件标签，只要是有的属性，我们都可以对它进行获取并且修改赋值等等！【只要是属性存在，代码写没写出来都可更改】\n\n\n\n![image-20211007113132224](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113132224.png)\n\n\n\n\n## JS 中如何在事件执行后获取这个事件对象\n\n\n\n\n答：通过匿名回调函数获取，回调函数括号内可以用形参的方式来接收发生事件的对象，不管回调函数是都用形参来接收这个事件对象，这个事件对象都会传给匿名回调函数，问题就是你是否想通过这个事件对象来获取其他有关于这个事件的数据\n\n\n\n![image-20211007113145168](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113145168.png)\n\n\n\n## 如何用 JS 代码获取键盘按下后程序判断按下的是什么键子！\n\n\n\n答：通过回调函数接收键盘按下的事件对象，在通过这个事件对象的keyCode属性即可获取按下键子的键值从而判断按下的是什么键子\n\n\n\nps：Enter的键值为13，Esc键子的键值为27，通过键值可以判断键盘按下的是什么键子\n\n\n\n程序获取键子键值的方式：键值 = 键盘按下对象.keyCode     【键盘按下是一个事件，可通过结点的回调函数获取】\n\n\n\n![image-20211007113213155](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113213155.png)\n\n\n\n\n\n## JS 中如何利用代码执行指定事件\n\n\n\n实现语法：事件绑定的组件对象.事件名（）\n\n\n\n功能：不用通过人工进行事件的实现，程序模拟实现!\n\n\n\n语法示例：btuObj.click（）   【在 btuObj 这个按钮上面程序执行鼠标单击事件】\n\n图示：\n\n\n\n![image-20211007113227652](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007113227652.png)\n\n\n\n\n\n持续更新中......\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript--运算符","url":"/2021/10/07/JavaScript-运算符/","content":"\n\n\n*本文主讲：JS中常见的运算符*\n\n<!--more-->\n\n\n\n## JS 中常见的运算符\n\n### JS 中常见的运算符及其功能\n\n\n\n\n\n![image-20211007105820614](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105820614.png)\n\n![image-20211007105830305](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105830305.png)\n\n\n\n\n### JS 中 void 运算符的用法以及使用场景\n\n\n\nvoid运算符语法：void（任意的表达式）\n\n\n\n功能：一段程序使用 void 后，将不返回任何值，注意是不返回任何值，不是返回空字符串“”，null、undefined、NaN等等，就是啥也不返回\n\n\n\n\n\n注意：在 void 括号内一定要放上表达式，要不然会出现报错，任何表达式都可以，例如 void（0），void（26）等等\n\nvoid运算符使用场景：点击超链接之后，执行一段JS代码【弹出窗口】，但是不会跳转到任何页面【包括刷新当前页面】\n\n\n\n![image-20211007105906160](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105906160.png)\n\n\n\n\n\n持续更新中......","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript——数据类型","url":"/2021/10/06/JavaScript——数据类型/","content":"\n\n\n\n*本文所讲：JS中变量的数据类型及详解、三种数据类型的prototype属性、创建数组、undefined与null和NaN的区别！*\n\n<!--more-->\n\n\n## JS中的变量数据类型\n\n\n\n### JS 中变量都有哪几种基本数据类型\n\n\n\n ES6【ECMAScript6】（欧洲计算机脚本规范） 之前：JS的变量数据类型总共有6种，分为原始数据类型和引用数据类型\n\n\n\n原始数据类型：String、Number、Undefined、Boolean、Null\n引用数据类型：object以及其子类【类】\n\n\n\n\nES6【ECMAScript6】（欧洲计算机脚本规范） 之后：在之前的6中数据类型基础上加上了 Symbol\n\n\n\n\n\n### JS 中 typeof 方法的功能以及其语法\n\n\n\n功能：在程序运行过程中动判断变量的数据类型\n语法：typeof 变量名\n\n\n\n结果：typeof 方法的返回值【结果】有六种，结果都是小写的字符串！！！\n\n \t\t6种结果分别为：“string”、“number”、“boolean”、“undefined”、“function”、“object”\n\t\n\t\n注意：\n\n1：数据类型为 Null 的变量，利用 typeof 方法获得的结果为 “object”，这也是 JS 历史遗留的BUG吧\n\n\n\n2：在 JS 中判断两个变量是否相等用的是 “==”\n\n\n\n3：利用 typeof 检测函数数据类型时，typeof 后面的函数不能加括号\n\n\n\n![image-20211007104859859](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007104859859.png)\n\n\n\n\n\n\n## Undefined数据类型\n\n\n\n变量数据类型：Undefined\nUndefined变量数据值：undefined 【一定要是小写】\n\n\n\n须知：在 JS 中如果声明了一个变量却没有赋值，那么系统默认给这个变量赋值为 undefined，当然我们也可以手动给一个变量赋值为 undefined\n\n\n\n![image-20211007104920789](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007104920789.png)\n\n\n\n## Number数据类型\n\n\n\n### JS 中变量的 Number 数据类型\n\n\n\n变量数据类型：Number\nNumber变量数据值：正数、负数、小数、零、整数……NaN【不是一个数字】、Infintiy【无穷大】\n\n\n\nNaN解答：当运算结果本应该是一个数字的时候，最后算完却不是一个数字，例如 10 / “啦啦啦”的结果就是 NaN【有除号结果本应该是一个数字】\n\n\n\n\n\nInfintiy解答：除法运算时，除数为0结果就是 Infinity\n\n\n\n注意：\n\n1：Number数据类型的变量值不一定只是数字，例如 NaN、Infinity\n\n\n\n2：+符号有两个功能，一个功能是做字符串的拼接，第二个功能是做加法运算符，当+符号两边变量有一个为字符串的时候，那么+充当字符串的拼接，而不是加法的运算，这点非常重要！\n\n\n\n![image-20211007105002072](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105002072.png)\n\n\n\n\n\n### JS 内置的 isNaN（）、parseInt（）、parseFloat（）、Math.ceil（）方法的功能\n\n\n\n\nisNaN（变量值或者变量名）函数功能：判断变量是否为一个数字，不是数字返回结果为 ture，是数字返回 false\nps：isNaN就是 is Not a Number  翻译为中文就是，不是一个数字\n\n\n\n![image-20211007105028397](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105028397.png)\n\n\n\nparseInt（字符串或者数字类型变量）函数功能：如果变量是一个字符串，首先将字符串转为数字，并且取这个数字的整数部分，不是字符串就直接取整\n\n\n\nparseFloat（字符串或者数字类型变量）函数功能：自动将字符串转为一个数字\n\n\n\nMath.ceil（字符串或者数字类型变量）函数功能：如果变量是一个字符串，首先将字符串转为数字，并且在数字基础上向上取整，不是字符串就直接向上取整\nps：2.1向上取整为3，2.99向上取整也为3\n\n\n\n\n\n![image-20211007105037898](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105037898.png)\n\n\n\n## Boolean数据类型\n\n\n\n### JS 中变量的 Boolean 数据类型\n\n\n\n\n变量数据类型：Boolean\nBoolean数据类型值：true和false     【Boolean数据类型只有这两个值】\n\n注意：Boolean变量数据类型只有两个值，true和false\n\n\n\n![image-20211007105122818](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105122818.png)\n\n\n\n\n### JS 中 Boolean（）函数的应用场景\n\n应用场景：分支语句和循环语句后面括号里的数据必须是Boolean数据类型，也就只能是 true 和 false 两个值，如果后面括号里面的数据不是 Boolean\n\n数据类型，那么分支语句和循环语句会自动调用 Boolean（）函数，将非Boolean的数据转为Boolean数据类型\n\n\n\n语法：Boolean（变量或者数据）\n\n\n\n\n\n\n转换结果：\n\n\nBoolean（1）：true\n\t\t\nBoolean（0）：false\n\t\t\nBoolean（“ ”）：false\n\t\t\nBoolean（“啦啦啦”）：true\n\t\t\nBoolean（undefined）：false\n\t\t\nBoolean（NaN）：false\n\t\t\nBoolean（null）：false\n\t\t\nBoolean（Infinity）：true\n\t\t\n口诀：有就是true，没有就是false\n\n\n\n\n\n![image-20211007105139789](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105139789.png)\n\n\n\n\n## String数据类型\n\n\n### JS 中的 String 变量数据类型\n\n\n\n变量数据类型：String\nString变量数据值：“数据”    ‘数据’\n\n\n\n创建字符串对象的两种方式：\n\n\n\n1：var str1=”啦啦啦“        【这种的字符串数据类型称为小String，用typeof 测该变量数据类型为 string】\n\t\t\t\t\t\n2：var str2 = new String（“啦啦啦”）         【这种的字符串数据类型称为大String，用typeof 测该变量数据类型为 object】\n\t\t\t\t\t\n\n注意：\n\n\n1：利用第二种方式创建字符串，其中 String（）是 JS 的内置类，它的父类是 Object（），因此它创建的字符串称为大String，用typeof 测该变量数据类型为 object\n\t\n2：不管是哪种方式创建的字符串对象【大String和小String】他们的方法和属性都是共用的\n\n\n\n![image-20211007105213597](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105213597.png)\n\n\n\n\n### JS 中 String 数据类型常用的属性和方法\n\n\n\n常用属性：字符串.length    【获取字符串的长度】\n\n\n\n\n\n常用方法：\n\t\t\n总字符串.indexOf（指定字符串）：获取指定字符串在总字符串内第一次出现的下标索引，没有出现过返回 -1 ，出现了则返回下标\n\t\t\n总字符串.lastIndexOf（指定字符串）：获取指定字符串在总字符串内最后一次出现的下标索引，没有出现过返回 -1 ，出现了则返回下标\n\t\t\n字符串.replace（待替换字符串，替换字符串）：将字符串内的指定字符进行替换，如果待替换的字符有多个只替换第一个，全部替换需要正则\n\t\t\n字符串.substr（startIndex，length）：根据字符串开始位置的下标索引和截取长度，截取字符串\n\t\t\n字符串.substring（startIndex，endIndex）：根据字符串开始位置的下表索引和结束位置的下标索引截取字符串，ps：截取的字符串不包括结束索引\n\t\t\n字符串.toLowerCase（）：将字符串全部转为小写\n\t\t\n字符串.toUpperCase（）：将字符串全部转为大写\n\t\t\n字符串.split（字符）：根据括号内的字符将字符串进行分割，分割为多个字符串存放到Object对象内\n\n\n\n\n\n注意：substr和substring两个方法的区别是面试问题\n\n\n\n\n\n![image-20211007105240305](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105240305.png)\n\n\n\n\n### JS 中的三目运算符格式\n\n\n\n格式：条件 ？ 条件成立执行的语句 ： 条件不成立执行的语句\n\n\n\n![image-20211007105248244](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105248244.png)\n\n\n\n## Object数据类型\n\n\n\n### JS 中 Object 数据类型的一些知识\n\n\n\n概念：Object是所有自定义类的父类【超类】，也就是所有自定义的类都会默认继承 Object 类的所有属性和方法，自定义的类可以重写Object类的属性和方法，也就是说自己定义的类里面可以使用 Object类里面的所有属性和方法，和python一样\n\n\n\n\n\nObject 类的属性：\n\nprototype【就学这个】：作用是动态的给类扩展属性和方法\nconstructor：……..\n\t\t\t\nObject 类的方法【知道就行】：\n\ntoString（）：…….\nvalueOf（）：…….\ntoLocaleString（）：……\n\n\n​    \n\n### JS 中怎么定义类和创建类对象\n\n\n\n\n定义类的方式：\n\n第一种方式：function 类名（形参）{ }\n\t\t\n第二种方式：类名 = function（形参）{ }\n\t\t\n注意：对，你没有看错，定义类的方法和定义函数的两种方法一样！！！就是这么六批！！！就是说构造函数和创建类是放在一起完成的\n\n\n\n创建【实例化】类对象的方法：var 类对象 = new 已经定义的类名（实参）           【可以看做先调用这个函数，在实例化对象，就可以解释下面的注意了】\n\n\n\n注意：在利用定义好的类创建对象时，会自动执行类里面的代码！\n\n\n\n![image-20211007105324485](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105324485.png)\n\n\n\n\n\n\n\n### JS 中如何为定义的类添加属性以及访问类实例化对象的属性两种方法\n\n\n\n为类添加自身属性语法：this.类的属性名 = 类的属性值      【this代表当前类，类似于 python 的 self】\n\n\n\n\n访问类属性的两种方法：\n\n1：类的属性值 = 实例化对象.类的属性名\n2：类的属性值 = 实例化对象[\"类的属性名\"]\n\n\n\n​\t\t\t\t![image-20211007105347243](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105347243.png)\n\n\n\n### JS 中如何为定义的类添加函数以及如何调用类实例化对象的方法\n\n为类添加自身函数：this.函数名 = funtion（）{ }\n\n\n调用类实例化对象自身的函数：实例化对象.函数名\n\n\n\n![image-20211007105416429](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105416429.png)\n\n\n\n## JS三种数据类型的prototype属性\n\n\n\n### JS 中有哪六种数据类型\n\n答：Undefined、String、Number、Null、Boolean、Object\n\n\n\n### JS 中六种数据类型中的 prototype 属性的功能以及用法\n\n\n\npytotype属性功能：为String、Boolean、Object 数据类型动态添加【扩展】属性以及方法，方便后面使用\n\n\n\n\n\n添加属性语法：\n\n1：String.prototype.添加的属性或者方法名\n2：Boolean.prototype.添加的属性或者方法名\n3：Object【方法名】.prototype.添加的属性或者方法名\n\t\t\t\n\t\t\t\n获取【调用】prototype 添加的属性和方法语法：\n1：“略略库”.添加的属性或者方法名\n2：false.添加的属性或者方法名\n3：实例化对象.添加的属性或者方法名\n\n\n\n注意：\n\n\n1：prototype 为什么样的数据类型动态添加属性和方法，那么获取或调用添加的属性和方法时，就用这个数据类型获取！！！\n\n2：prototype 可以为上面哪三种数据类型动态添加属性和方法，当然也可以重写！\n\n3：利用 prototype 为类添加属性时，要这样  类名.prototype.添加的属性或方法名\n\n\n\n\n\n![image-20211007105452195](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105452195.png)\n\n\n\n\n## JS中undefind、null、NaN的区别\n\n\n\n### JS 中undefind、null、NaN 三者的区别\n\n\n\n\n1：undefind、null、NaN 数据类型不一样\n\nundefined：Udefined\n\nnull：Null\n\nNaN：Number\n\n\n\n2：null 与 undefined 值【类型不相同】相等，其他两者不相等！\n\n\n\n![image-20211007105510895](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105510895.png)\n\n\n\n\n### JS 中 “==”以及“===”的区别\n\n\n“==”：等号运算法，判断运算符两边的数据值是否相等，相等返回 true、不等返回 false\n\n“===”：全等运算符，判断运算符两边的数据值与类型是否相等，相等返回 true、不等返回 false   【JS特有】\n\n\n\n![image-20211007105523408](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105523408.png)\n\n\n\n\n## JS 中怎么创建数组\n\n\n\n\n创建语法：var arr = [“啦啦啦”，false，“略”，26，null ]\n\n获取元组内数据：元组名 [ 数据的下标索引 ]\n\n\n\n注意：\n\n\n\n1：在 JS 中元组就相当于 python 中的列表\n\n2：在 JS 中的元组内可以存放任何类型的数据！\n\n\n\n![image-20211007105542919](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211007105542919.png)\n\n\n\n持续更新中.......\n\n​\t\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript——JS基础","url":"/2021/10/06/JavaScript——JS基础/","content":"\n本文主讲：什么是JavaScript及其历史、JavaScript嵌入到HTML代码的三种方式【重点】、JavaScript标识符命名规则与规范、JavaScript变量、JS中的函数、JS中的全局变量与局部变量\n\n<!--more-->\n\n\n\n## 什么是JavaScript及其历史\n\n\n\n### 什么是JavaScript及其历史\n\n\n\n![image-20211006213357428](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006213357428.png)\n\n\n\n### 什么是脚本语言\n\n\n答：脚本语言就是代码可以直接放在文本文件内即可以执行，代码文件不需要进行编译\n\n\n\n## JavaScript嵌入到HTML代码的三种方式\n\n第一种方式：嵌入到HTML代码属性中的事件句柄后面\n\n![image-20211006213952578](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006213952578.png)\n\n\n\n注意：\n1：第一种方式嵌入的JS代码，浏览器打开JS代码并不会执行，而是把JS代码注册到相应组件的事件句柄上面，当这个事件在组件上被执行的时候，组件内HTML代码属性中的事件句柄后面的JS代码才会执行\n\t\n2：JS代码中 window.alert（）方法是打开一个窗口，window就代表浏览器窗口，当然 window 也可以省略\n\t\n3：句柄后面的JS代码要加上“ ”\n\n\n\n注意1图示：\n\n![image-20211006214012678](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214012678.png)\n\n\n\n第二种方式：JavaScript脚本块嵌入到HTML代码中\n\n\n\n![image-20211006214023030](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214023030.png)\n\n\n\n注意：\n1：JavaScript脚本块在一个HTML代码文档中可以有多个，并且可以出现在任何位置\n2：JavaScript脚本块内的JS代码不需要通过事件执行，程序启动脚本块里面的JS代码就会从上向下执行\n3：JS代码中的 alert 方法【窗口】会阻塞程序的执行\n4：脚本块里面的JS代码不需要加双引号\n\n\n\n第三种方式：JavaScript脚本块引入外部独立的JS文件\n\n![image-20211006214037601](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214037601.png)\n\n\n\n注意：\n1：一个JS文件可以被多个脚本块引入多次，但是实际开发中不这么做\n2：如果脚本块引入了外部独立JS文件，那么脚本块标签里面的JS代码不会被执行\n3：外部独立的JS文件会遵循从上到下的顺序执行JS代码\n\n\n\n\n\n\n## JavaScript标识符命名规则与规范\n\n\n\n### JavaScript 标识符命名规则\n\n\n\n\n1：标识符是由数字、字母、下划线、￥组成\n2：数字不能用作标识符开头\n3：严格区分大小写\n4：并用关键字做标识符\n\n\n\n### JavaScript 标识符的命名规范\n\n\n\n\n常量：每个字母都大写，并且单词与单词之间用_作分隔\n\n变量和函数名：首字母小写，后面每个单词大写\n\n类名与接口名：首字母大写，后面每个单词的首字母大写\n\n\n\n### JavaScript 两种注释方法\n\n\n\n\n单行注释：//\n多行注释：/*         */\n\n\n\n![image-20211006214058520](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214058520.png)\n\n\n\n\n## JavaScript变量\n\n\n\n### 什么是强类型与弱类型编程语言\n\n强类型语言：变量在声明是什么数据类型之后，在整个程序执行结束【内存释放】，这个变量的数据类型都不能发生改变。\n\n例如：java、c 、c++\n\n\n\n弱类型语言：变量在声明之后【没有具体声明是什么数据类型】，在程序执行直到结束，这个变量的数据类型都是可以变的，你可以给这个变量赋予任何类型的值\n\n例如：JavaScript、python\n\n\n\n\n\n### 类型语言中数据类型的大小【字节】顺口溜\n\n\n\nbyte short int long float double boolean char\n\n1 2 4 8 4 8 1 2\n\n\n\n###  JavaScript 中变量\n\n\n\n变量定义：var 变量名\n变量赋值：变量名 = 变量值        【变量必须先声明才能使用，否则程序报错】\n\n注意：\n\n1：JavaScript是弱类型语言，没有编译阶段，在声明一个变量之后，可以为这个变量赋任何类型的值\n\n\n\n2：在声明一个变量之后，不给这个变量赋值，这个变量默认值为 undefined，在JS中，undefined是一个具体存在的值！\n\n\n\n3：在JS中如果一个变量没有声明就拿来被使用，这种语法是错误的，程序报错\n\n\n\n4：在JS中声明一个变量用 var 关键字，但是如果直接这么写 变量名 = 变量值  这也是对这个变量进行声明，且这个变量在任何位置都是全局变量\n\n\n\n5：在JS中，var a，b，c = 200；  打印结果 a = undefined   b = undefined  c = 200\n\t\n6：在JS中，因为变量都是用 var 进行声明的因此可以出现 10 + “略略”以及 200 + false 的现象，这种现象在python是不行的\n\t\n7：两个 undefined 相加的值为 NaN 表示不是一个数字\n\n\n\n![image-20211006214134668](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214134668.png)\n\n\n\n\n## JS中的函数\n\n\n### JS 中定义函数的两种方式及其注意事项\n\n\n\n第一种方式：function 函数名（形参……）{ }\n\n\n\n第二种方式：函数名 = function（形参….）{ }\n\n\n\n注意事项：\n\n1：JS 中定义函数时形参的数量以及类型都没有要求，和python很像\n\n\n\n2：如果定义了两个同名的函数，后定义的那个函数会在内存中覆盖掉先定义的函数，先定义的那个函数就消失了！这也解释了注意的第三条\n\n\n\n3：JS 中的函数不能重载，因此多个函数之间不能出现函数名重名的现象\n\n\n\n![image-20211006214158295](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214158295.png)\n\n\n\n### JS 中调用函数时的注意事项\n\n\n\n注意1：如果函数定义时有返回值，在调用这个函数时需要有变量进行接收，那这个变量必须要用 var 进行声明，不声明的变量是不能用的\n\n例如：var result = 函数名（）\n\n\n\n注意2：在脚本块内定义好的函数，可以在外部html组件的句柄后面进行调用的！\n\n例如：\n```html\n<input type=“button” value=“点我” onclick = “函数名（）”/>\n```\n\n\n\n具体图示看上图！！！\n\n\n\n## JS中的全局变量与局部变量\n\n\n\n### JS 中什么是全局变量与局部变量以及两者的区别\n\n\n\n全局变量：在 JS 函数体外部声明的变量，变量的生命周期是整个程序，前端开发来言就是浏览器打开到浏览器关闭这个全局变量都可以被访问的，浏览器打开变量声明，浏览器关闭变量销毁，但也正因为如此，全局变量与局部变量比起来很占浏览器内存，因此全局变量应该慎重使用\n\n\n\n局部变量：在 JS 函数体内部声明的变量，包括函数的形参也是局部变量，局部变量的生命周期是从函数执行开辟变量空间【出生】到函数执行结束释放内存空间【局部变量死亡】\n\n\n\n区别：\n\n1：全局变量的作用域是整个程序，局部变量作用域是函数\n2：全局变量生命周期长，局部变量生命周期短\n\n\n\n注意：\n\n1：在函数外部以及内部声明两个同名的变量，在函数内部访问这个变量，要按就近原则访问！\n\t\n2：当一个变量没有用 var 关键字进行声明时，那这个变量不管在哪里定义它都是全局变量！ 例如 在函数体内部声明的变量  name = “xiaoli”，name变量虽然在函数体内部声明，但它却是全局变量【JS独有】\n\t\n3：如果在浏览器执行html文件【js代码】出现语法错误，程序不会继续向下执行\n\n\n\n​\t![image-20211006214237999](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006214237999.png)\n\n\n\n持续更新中......\n\n\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JavaScript——常见的JS浏览器操作","url":"/2021/10/06/JavaScript——常见的JS浏览器操作/","content":"\n\n\n本文主讲内容：认识JavaScript、常见的JS浏览器操作\n\n<!--more-->\n\n\n## 认识JavaScript\n\n\n### JavaScript 都包括什么？\n\nJavaScript包括三部分如下：\n\nECMAScript：JavaScript的核心语法【变量、控制语句、函数、对象等】\n\nDOM编程：Document Object Modle【页面对象模型】，对网页的组件结点进行增删改的过程，整个网页是由一个一个结点元素组成，这些结点元素统称为DOM树！\n\n核心实例代码：var elmObj = document.getElementById（“指定节点的id属性值”）    【通过id属性值获取指定节点对象】\n\nBOM编程：Browser Object Modle【浏览器对象模型】，对浏览器窗口进行编程，例如浏览器页面的前进、后退、刷新，关闭浏览器窗口等等操作\n\n\n\n### JS 中 DOM 与 BOM 的联系与区别\n\n\n两者的区别：\n\nDOM：DOM的顶级对象是 JS 中内置的 window \nBOM：BOM的顶级对象是 JS 内置的 document\n\t\t\n两者的联系：BOM其实包括DOM，因为 document.getElemetById（…..）可以写成 window.document.getElemetById（…..），window省略了！\n\nDOM与BOM两者关系图：\n\n\n\n![image-20211006212923877](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006212923877.png)\n\n\n\n## 常见的 JS 浏览器操作\n\n\n\nwindow.alert（“啦啦啦啦”）：在浏览器内出现弹窗，弹窗值为“啦啦啦啦”\n\n\n\nwindow.promut（“请输入你要的值：”60）：在浏览器内出现输入框，输入框内的默认值为 60\n\n\n\n![image-20211006213032820](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006213032820.png)\n\n\n\n## 常见的 JS 浏览器页面操作\n\n\n\n\n\ndocument.write（“浏览器页面要显示的数据”）\n\n\n\n![image-20211006213046434](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006213046434.png)\n\n\n\n持续更新中.......","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"redis数据库【第四期】","url":"/2021/10/06/redis数据库【第四期】/","content":"\n\n\n\n\n*本文主讲：数据持久化存储、redis数据库主从概念、设置redis主从集群等....*\n\n<!--more-->\n\n## redis数据持久化存储\n\n\n\n### 为什么要对 redis 数据进行持久化存储\n\n\n\n答：因为 redis 数据库是通过内存进行数据的增删改查的，如果遇到突然断电的情况，存放在redis数据库里面的数据将会消失，这时就不得不考虑数据持久化了\n\n\n\n### redis 进行数据持久化存储的两种方式\n\n\n\n\n第一种方式：快照存储\n\n存储指令：bgsave\n\n![image-20211006204550454](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204550454.png)\n\n\n\n关于快照存储的一些设置：\n\n![image-20211006204617006](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204617006.png)\n\n\n\n![image-20211006204629469](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204629469.png)\n\n\n\n\n\n注意：\n\n1：dump.rdb文件是通过保存数据的 key 和value 进行数据持久化存储的\n\n\n\n2：快照存储方式还是会造成一部分数据的丢失，因为如果在部分时间内没有超过快照持久化存储的条件，那么是不会快照存储数据的\n\n\n\n\n第二种方式：aof 持久化存储【实时存储】\n\n打开 aof 持久化存储\n\n\n\n![image-20211006204649334](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204649334.png)\n\n\n\n注意：\n\n1：aof 持久化存储数据是通过把 redis 命令存放到 appendonly.aof 文件内\n\n2：在 redis4.0 版本之前如果开启了 aof 持久化存储，那么快照持久化存储就会失效\n\n\n\n\n\n### redis 进行数据持久化存储的两种方式优缺点\n\n\n\n\n快照存储：\n\n优点：长期进行数据的持久化存储不会占用太多内存\n缺点：在特殊情况下还是会造成数据的缺失【更改key的数量未超过时间阈值时断电】\n\t\t\n\t\t\naof存储：\n\n优点：可以实时进行数据的存储\n缺点：长期进行数据的持久化存储占用太多内存\n\n\n\n\n\n## redis数据库主从概念\n\n\n\n### 单台 redis 主机数据库的优缺点\n\n\n\n\n优点：部署容易，数据的操作【增、删、改】也容易\n\n缺点：数据量特别大的时候，读取和写入数据压力特别大\n\n\n\n### 为什么要为 redis 数据库设置主从【集群】\n\n\n\n\n答：因为 redis 经常用作缓存【大量的读操作】，这样如果读取数据的压力很大的时候，单台 redis 服务器就不够看了，因此就要布置 redis 数据库的主从集群\n\n\n\n### redis 数据库主从的实现\n\n\n\n实现：准备多台用于部署 redis 集群的服务器，一般是单数，设置其中一台为主服务器，另外的其他服务器设置为从服务器\n\n\n\n注意：为什么设置 redis 集群，服务器的数量时是单数，因为当集群中有一半的服务器不能用的时候，整个集群系统就不能用了，设置双数那么不是浪费服务器资源吗！\n\n\n\nredis数据库集群优点：\n\n1：提高可用性，一台服务器宕机，其他服务器也可以完成这个操作\n\n2：分散 redis 数据库大量操作的压力！\n\n\n\n图示：\n\n\n\n![image-20211006204748492](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204748492.png)\n\n\n\n注意：从服务器也可以进行写操作，但是 Redis 做缓存的时候，从服务器只执行读操作是最理想的\n\n\n\n## 设置redis主从集群\n\n\n\n### 为多台 redis 服务器设置主从集群的步骤【主服务器与从服务器的设置】\n\n\n\n第一步：准备多台装了一个版本的 redis 的服务器\n\n\n\n第二步：主服务器的配置【修改主服务器的 redis.conf 文件】\n\n\n\n配置可以远程连接\n\n\n\n![image-20211006204923811](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204923811.png)\n\n\n\n设置主服务器的密码\n\n\n\n![image-20211006204938140](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204938140.png)\n\n\n\n开启redis-server后台启动\n\n\n\n![image-20211006204959531](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204959531.png)\n\n\n\n\n\n配置完之后重启主服务器\n\n\n\n\n第三步：从服务器的配置【修改从服务器的 redis.conf 文件】\n\n配置可以远程连接\n\n\n\n![image-20211006205024844](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205024844.png)\n\n\n\n\n开启 redis-server 后台启动\n\n\n\n![image-20211006205047105](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205047105.png)\n\n\n\n设置从服务器连接哪台主服务器以及连接那台主服务器的密码\n\n\n\n![image-20211006205059238](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205059238.png)\n\n\n\n设置从服务器的读写权限\n\n\n\n![image-20211006205113157](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205113157.png)\n\n\n\n\n配置完之后重启所有的从服务器\n\n第四步：重新连接主服务器以及所有的从服务器\n\n\n\n![image-20211006205125160](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205125160.png)\n\n\n\n### 设置完 redis 主从集群之后，怎么查看当前服务器是主服务器还是从服务器\n\n\n\n第一步：连接待查看的 redis 数据库\n\n连接指令：redis-cli\n\n\n\n\n第二步：输入下面指令即可查看\n\n查看指令：info replications\n\n\n\n![image-20211006205216956](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205216956.png)\n\n\n\n持续更新中......","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"redis数据库【第三期】","url":"/2021/10/06/redis数据库【第三期】/","content":"\n\n\n*本文主讲内容：数据的时效时间及其redis与python进行交互！*\n\n<!--more-->\n\n\n## 数据的失效时间\n\n\n\n### 什么是数据的失效时间\n\n\n\n\n答：为数据设置一个时限，超过这个时限，这个数据就会自动删除，应用场景：验证码！\n\n\n\n### 在 redis 数据库为 key【数据】 设置失效时间的两种方式\n\n\n\n第一种形式：创建数据时为指定 key 设置失效时间\n\n\n\n语法：\n\n\n\n1：set key value ex 30        为这个 key 设置失效时间，失效时间为 30 秒\n\n2：set key value px 300000      为这个 key 设置失效时间，失效时间为 300000 毫秒\n\n\n\n![image-20211006203218465](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203218465.png)\n\n\n\n第二种形式：为已经创建的 key 添加失效时间\n\n语法：expire 已经存在的key  30       【为这个 key 设置失效时间，失效时间为 30 秒】\n\n\n\n![image-20211006203231339](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203231339.png)\n\n\n\n\n### 如何在 redis 数据库内查询某个 key 的失效时间还剩多长\n\n\n\n语法：\n\n1：ttl 指定key    【查询指定key还剩多少时间失效，查询单位显示为秒】\n2：pttl 指定key     【查询指定key还剩多少时间失效，查询单位显示为毫秒】\n\n\n\n结果：\n\n正数：查询某个键还有多少时间失效，如果显示为正数就说明还有正数这些时间失效\n\t\n-1：查询某个键还有多少时间失效，如果显示为 -1 就说明这个键永远不失效\n\t\n-2：查询某个键还有多少时间失效，如果显示为 -2 就说明这个键已经永远不失效\n\t\n图示：\n\n\n\n![image-20211006203257034](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203257034.png)\n\n\n\n\n### 在 redis 数据库内创建数据时，nx 参数与 xx 参数的作用\n\n\n\n语法：\n\n1：set key value nx         【如果这个key在redis数据库内不存在那么创建这个 key 成功】\n\t\n2：set key value xx         【如果这个key在redis数据库内存在那么创建这个 key 成功】\n\t\n3：set key value ex 30  nx         【如果这个key在redis数据库内不存在那么创建这个 key 成功，并且在30秒后这个key失效】\n\t\n4：set key value ex 30  xx         【如果这个key在redis数据库内存在那么创建这个 key 成功，并且在30秒后这个key失效】\n\n\n\n图示：\n\n\n\n![image-20211006203313886](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203313886.png)\n\n\n\n应用场景：前两种语法用于加锁的机制上面，后两种情况用于锁机制避免出现死锁的情况\n\n\n\n\n\n## redis数据库与python交互【重点】\n\n\n\n### redis 与 python 进行交互的步骤\n\n\n\n第一步：安装 python 的 redis 第三方库    →  pip3 install redis\n\n\n\n第二步：导入 redis 第三方数据库             →        import redis\n\n\n\n第三步：创建 redis 连接数据库对象        →          red_obj = redis.Redis(host=主机，port=端口号，db=数据库号)\n\n\n\n注意：redis默认有16个数据库，也就是数据库号可以是  0-15，一般选择0   redis的端口号是6379（整形）\n\n\n\n第四步：利用创建的 redis 数据库对象对数据库进行操作      →  result = red_obj.sadd(\"name：age\" , \"21\")   向外键名为name的集合内插入键为age值为“21”的一条数据\n\n\n\n注意：redis内的集合数据类型具有数据唯一性以及无序性的特征，如果上述插入的数据在集合内存在返回0，不存在返回数据1\n\n\n\n截图：\n\n\n\n![image-20211006203447702](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203447702.png)\n\n\n\n\n\n### redis 与 python 交互后通过代码对redis数据库的操作\n\n\n\nps：确保对 redis 数据库操作之前已经成功通过代码连接上 redis 数据库\n\n操作截图【对redis数据库内的string数据类型进行操作】：\n\n\n\nps：下面代码中的 sr 是建立数据库连接的对象\n\n\n\n![image-20211006203133995](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203133995.png)\n\n![image-20211006203142675](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203142675.png)\n\n持续更新中......","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"redis数据库【第二期】","url":"/2021/10/06/redis数据库【第二期】/","content":"\n\n本文主讲：连接redis数据库及其redis数据库的数据类型\n\n<!--more-->\n\n\n## 通过指令连接 redis 数据库\n\n\n第一步：开启 redis 服务器\n\n指令：redis-server\n注意：redis-server中的 - 两边没有空格\n\n\n\n\n第二步：开启 redis 客户端\n\n指令：redis-cli -a 设置的密码\n注意：如果设置了密码需要在 redis-cli 后面跟上 -a 设置的密码\n\n\n\n第三步：输入 ping 即可进入 redis 数据库\n\n\n\n![image-20211006201254018](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201254018.png)\n\n\n\n## redis-cli 的指令选项都是干什么的\n\n\n\n选项：\n\n\n\n-a：用于认证密码                 例如 redis-cli -a yhq256112\n\n-h：用于指定连接的 ip 地址  例如 redis-cli -h 192.168.1.8      【可用于远程连接数据库】\n\n-p：用于指定redis数据库监听的端口号        例如 redis-cli -p 6379     【注意端口号一般都指定为6379】\n\n\n\n![image-20211006201319023](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201319023.png)\n\n\n\n远程连接数据库\n\n\n\n![image-20211006201326357](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201326357.png)\n\n\n\n\n\n## redis数据库的数据类型\n\n\n### 如何向 redis 指定数据库添加数据\n\n答：在连接上数据库之后执行下面指令即可选择指定数据库存放数据【redis默认有16个逻辑数据库，第一个数据库索引编号为0】\n\n\n\n指令：select 2\n\n指令解析：选择索引编号为2的数据库【第三个数据库】存放数据\n\n\n\n![image-20211006201835213](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201835213.png)\n\n\n\n### redis 数据库中 String 数据类型的操作\n\n\n数据结构：{“key”：“value”}\n\n操作语法：\n\n\n\n添加单条数据：set key value\n\t\t\n取出单条数据：get key\n\t\t\n添加多条数据：mset key1 value1 key2 value2\n\t\t\n取出多条数据：mget key1 key2\n\n\n\n图示：\n\n\n\n![image-20211006201858412](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201858412.png)\n\n\n\n\n### redis 数据库中 Hashes【散列】 数据类型的操作\n\n\n\n数据结构：{“外key”：{ “key1”：“value1”，“key2”：“value2”}}       也就是字典的嵌套\n\n\n\n![image-20211006201915642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201915642.png)\n\n\n\n操作语法：\n\t\t\n添加单条数据：hset 外key key1 value1\n\t\t\t\n取出单条数据：hget 外key key1\n\n添加多条数据：hmset 外key key1 value1 key2 values\n\t\t\t\n取出多条数据：hmget 外key key1 key2\n\t\t\t\n取出外key对应的所有数据：hgetall 外key\n\t\t\t\n删除数据：hdel 外key key1 key2\n\t\t\t\n\n图示：\n\n\n\n![image-20211006201933622](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201933622.png)\n\n\n\n### redis 数据库中 List【列表】 数据类型的操作\n\n\n\n数据结构：{“外键key”：“ [ 'value1','value2','value3' ] ”}\n\nPS：value的值可以重复，并且列表是有序的\n\n\n\n![image-20211006202005338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202005338.png)\n\n\n\n操作语法：\n\t\t\n在列表的左侧插入数据【单条和多条】：lpush 外键 value1 value2…..\n\t\t\n在列表的右侧插入数据【单条和多条】：rpush 外键 value1 value2…..\n\t\t\n查找列表内指定索引的值：lrange 外键 开始索引 结束索引\n\t\t\n计算外键对应列表的长度：llen 外键\n\t\t\n删除指定数量的数据：lrem 外键 删除数量 待删除的value\n\n\n\n​\t\n\n图示：\n\n\n\n![image-20211006202021426](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202021426.png)\n\n\n\n注意事项：\n\n\n\n1：在列表内插入【两端插入】数据，新来的数据总是占两端端点处！\n\n\n\n![image-20211006202033646](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202033646.png)\n\n\n\n2：删除数据时，如果删除数据的数量大于现存数据量，那么这些数据全部删除，如果小于现存数据量，就从列表前面【左端】依次开始删除\n\n\n\n### redis 数据库中 Sets【集合】 数据类型的操作\n\n\n\n\n数据结构：{“外键key”：“ （ 'value1','value2','value3' ） ”}\n\nPS：value的值不可重复，并且set是没有顺序的\n\n![image-20211006202101239](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202101239.png)\n\n\n\n操作语法：\n\t\t\n向外键key内的集合添加数据【单条和多条】：sadd 外键 value1 value2 value3\n\t\t\n查找外键内集合的所有数据：smembers 外键\n\t\t\n计算外键内集合的长度：scard 外键\n\t\t\n删除外键内集合中指定数据：srem 外键 待删除的数据1  待删除的数据2\n\t\n\n图示：\n\n![image-20211006202115415](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202115415.png)\n\n\n\n注意：\n\n\n\n1：因为集合是无序的，索引不支持索引，因此不能用索引查询\n\n\n\n\n2：集合说是无序的【应用层】，其实底层系统也帮集合数据排好序了\n\n\n\n\n\n### redis 数据库中 Sorted Set【有序集合】 数据类型的操作\n\n\n\n数据结构：{“外键key”：“ （ 'value1','value2','value3' ） ”}\n\nPS：value的值不可重复，并且set是有顺序的【根据权重从小到大排序】\n\n\n\n![image-20211006202141528](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202141528.png)\n\n操作语法：\n\n\n向外键key所对应的有序集合内插入有序数据【单条和多条】：zadd 外键key  值1的权重  值1 值2的权重 值2\n\t\t\n查找外键所对应的有序集合内指定索引的数据：zrange 外键 开始索引 结束索引\n\t\t\n计算外键内有序集合的长度：zcard 外键\n\t\t\n删除外键内有序集合中指定数据：zrem 外键 待删除的数据1  待删除的数据2\t\t\n\n\n\n图示：\n\n\n\n![image-20211006202200317](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202200317.png)\n\n\n\n### redis 数据库中查找与删除的通用操作\n\n\n\n通用操作：指令作用域是五个数据类型，而不仅仅是指定一个\n\n\n\n查找所有键【字符串类型】与外键【哈希、列表、集合、有序集合】指令：keys *\n\n\n\n删除指定键【字符串类型】与外键【哈希、列表、集合、有序集合】指令：del 键1 键2 外键1….\n\n\n\n图示：\n\n\n\n![image-20211006202221048](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202221048.png)\n\n\n\n### reids 数据库中层级目录的操作\n\n\n\n什么是层级目录：在 redis 数据库内层级目录就类似于文件夹的分级结构！\n\n\n\n为什么要设置层级目录：方便同类型数据的查询\n\n\n\n图示：\n\n![image-20211006202238649](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202238649.png)\n\n\n\n\n层级目录文件结构：\n\n\n\n![image-20211006202248298](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202248298.png)\n\n\n\n持续更新中.......\n\n\n\n\n\n\n\n","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"redis数据库【第一期】","url":"/2021/10/06/redis数据库【第一期】/","content":"\n\n*\n本文教程主讲：\n1：什么是redis\n2：怎么安装redis\n3：如何配置redis\n*\n<!--more-->\n\n## 什么是 redis 数据库\n\n注意：\n\n\n1：redis 是非关系型数据库（以键值对的形式存储数据）\n\n\n2：互联网三高：高并发、高性能、高可用\n\n\n\n![image-20211006195929959](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195929959.png)\n\n\n\n\n\n## redis的安装\n\n\n\nwindows安装方式：\n\n\n\n安装链接：https://blog.csdn.net/weixin_41996197/article/details/89427073?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162640227416780255259420%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162640227416780255259420&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89427073.pc_search_result_control_group&utm_term=WIN10%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85redis&spm=1018.2226.3001.4187\n\n\n\n\nlinux安装指令：\n\n```\nsudo apt-get install redis-server\n```\n\n\n\n## 配置redis\n\n*注意：修改完 redis.conf 文件参数后一定要重启 redis 数据库才能生效*\n\n\n\n\n### 如何配置reids完成redis的后台启动\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件 【windows系统是redis.windows-service.conf 文件】\n\n\n\n第二步：对文件内的 daemonize 的参数进行修改即可【windows系统不支持这个参数】\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195706202](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195706202.png)\n\n\n\n### 如何配置reids实现数据库可被远程连接\n\n\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件\n\n\n\n第二步：对下面两个参数进行修改即可\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195729062](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195729062.png)\n\n\n\n### 如何配置redis实现为数据库增加密码保护\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件\n\n\n\n第二步：修改 requirepass 参数即可\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195750992](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195750992.png)\n\n\n\n### 如何配置redis实现改变数据库的数量\n\n\n\n注意：redis内数据库只是逻辑数据库，并不是真实的数据库\n\n\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件\n\n\n\n第二步：修改 database 参数即可\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195812670](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195812670.png)\n\n\n\n配置生效：\n\n\n\n![image-20211006195829959](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195829959.png)\n\n\n\n","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"爬虫工程师查缺补漏大纲流程图","url":"/2021/10/06/爬虫工程师查缺补漏大纲流程图/","content":"\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/1.png)\n\n<!--more-->\n\n\n\n\n\n目前距离爬虫工程师的道路还有很远，下面是我自己整理待学习的爬虫资源目录，砥砺前行！\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F.png)\n\n\n\n\n\n下面是面试可能会问到的技能树【拉钩招聘整理】\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png)\n\n\n\n\n\n爬虫路漫漫........\n\n热爱可抵岁月漫长......\n\n加油！！！！","tags":["爬虫练习"],"categories":["爬虫练习"]},{"title":"爬虫常用解析类库——pyquery","url":"/2021/10/06/爬虫常用解析类库——pyquery/","content":"\n本文主讲内容：爬虫解析数据的类库pyquery的简单使用\n\n<!--more-->\n\n\n## 怎么安装 pyquery\n\n\n安装指令：\n```\npip3 install pyquery\n```\n\n\n\n## 使用 pyquery 匹配数据的步骤\n\n\n\n第一步：导入模块\n\n语法：\n\n```python\nfrom pyquery import PyQuery as pq\n```\n\n\n第二步：通过 PyQuery 类实例化一个 PyQuery 对象\n\n\n语法：\n\n```python\ndoc = pq（网页源代码）\ndoc = pq（url = “网站”，encoding = “字符集”）\ndoc = pq（filename= html文件，encoding = “字符集”）\n```\n\n注意：第一种实例化 PyQuery 对象的方法最常用，因为像网站发送请求时可以更加灵活的控制请求头【headers】，第三种方法也挺常用的\n\n\n\n\n\n\n\n\n\n第三步：通过实例化对象的属性和方法匹配标签以及数据！\n\n其中一种匹配数据的语法示例：doc(\"li\")            表示匹配html源代码内的所有 li 标签并且返回一个 pyquery类型的对象\n\n\n\n![image-20211006185937139](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006185937139.png)\n\n\n\n## pyquery 匹配数据的几种方法\n\n\n\n1.匹配 PyQuery 对象中的指定标签\n\n\n\n语法：\n```python\nresult = doc（“li”）\nresult = doc（“li[class = 'item-5']”）\n```\n\n语法解释：\n\n1：匹配数据类型为pyquery的指定标签【doc对象】的所有li标签，其中 result 的类型是  pyquery 类型\n\n\n\n2：匹配数据类型为pyquery的指定标签【doc对象】的class属性为“item-5”的所有li标签，其中 result 的类型是  pyquery 类型\n\n\n\n语法1\n\n![image-20211006190037183](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190037183.png)\n\n\n\n语法2：\n\n\n\n![image-20211006190055496](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190055496.png)\n\n\n\n\n\n2.通过css选择器语法匹配指定标签\n\n\n\n语法：result = doc（“.item-1”）   或者  result = doc（“#item-1”）    其中 . 代表class，#代表id 【参考bs4】\n\n\n解释：匹配doc对象中【html源码】的所有class属性为“item-1”的标签，其中 result 的类型是  pyquery 类型\n\n\n\n![image-20211006190114499](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190114499.png)\n\n\n\n3.查找某标签下的子标签\n\n\n\n语法：数据类型为pyquery的指定标签.find（“.item-1”）\n\n解释：在数据类型为pyquery的指定标签下通过 find 方法找到class属性为“item-1”的所有标签，并且返回为一个 pyquery类型的数据\n\n\n\n![image-20211006190129042](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190129042.png)\n\n\n\n\n\n4.查找某标签下的父【祖父】标签\n\n\n\n\n语法：\n```python\n数据类型为pyquery的指定标签.parent（）\n数据类型为pyquery的指定标签.parents（）\n```\n\n\n\n解释：\n\n\n\n1：通过数据类型为pyquery的指定标签的partent方法找到这个标签的父标签，并返回一个数据类型为 pyquery 的数据\n\n\n\n2：通过数据类型为pyquery的指定标签的partents方法找到这个标签的父与祖父标签，并返回一个数据类型为 pyquery 的数据\n\n\n\n![image-20211006190306526](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190306526.png)\n\n\n\n\n\n5.可遍历【迭代】的标签对象\n\n\n语法：数据类型为pyquery的指定标签（“.item-0”）.items（）\n\n\n解释：匹配数据类型为pyquery的指定标签里面的所有class属性为“item-0”的标签，并且将这些标签存放到一个可迭代对象里面而不是返回一个数据类型为 pyquery的数据\n\n注意：循环遍历出去的class属性为“item-0”的标签还是一个数据类型为pyquery的数据\n\n\n\n![image-20211006190321688](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190321688.png)\n\n\n\n6.获取数据类型为pyquery的指定标签内的属性\n\n\n\n语法：\n```python\n数据类型为pyquery的指定标签.attr（'href'）\n数据类型为pyquery的指定标签.attr.href\n```\n\n\n\n解释：匹配数据类型为 pyquery 的指定标签内的 href 属性的值\n\n\n\n![image-20211006190446228](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190446228.png)\n\n\n\n7.获取指定标签内的文本数据\n\n\n\n语法：数据类型为pyquery的指定标签.text（）\n\n语法解释：获取 数据类型为pyquery的指定标签 的文本数据值\n\n![image-20211006190505146](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190505146.png)\n\n\n\n8.获取指定标签下的html标签\n\n语法：数据类型为pyquery的指定标签.html（）\n\n语法解释：获取数据类型为pyquery的指定标签下一级的html标签\n\n\n\n![image-20211006190528353](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190528353.png)\n\n\n\n\n\n9.DOM操作【向数据类型为 pyquery 的指定标签内增加类和移除类】\n\n语法：\n```python\n数据类型为 pyquery 的指定标签.add_class（'love'）\n数据类型为 pyquery 的指定标签.remove_class（'love'）\n```\n\n\n\n语法解释：\n\n1：为数据类型为 pyquery 的指定标签增加一个值为“love”的class属性\n2：为数据类型为 pyquery 的指定标签移除一个值为“love”的class属性\n\n\n\n注意：移除和增加指定标签的属性都是浅的，不是永久的作用范围只是当前程序，程序结束回归原样【每增加没移除】\n\n\n\n语法1截图：\n\n\n\n![image-20211006190641127](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190641127.png)\n\n\n\n语法2截图：\n\n\n\n![image-20211006190652635](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190652635.png)\n\n\n\n\n\n持续更新中......","tags":["常用类库篇"],"categories":["常用类库篇"]},{"title":"爬虫常用解析类库——bs4","url":"/2021/10/06/爬虫常用解析类库——bs4/","content":"\n\n\n*本文主讲：bs4解析数据库的简答使用！*\n<!--more-->\n\n## 使用 bs4 库需要什么环境\n\n环境：\n\nbs4库：\n```\npip3 install bs4\n```\nlxml解释器：\n```\npip3 install lxml\n```\n\n\n## bs4 库匹配数据的具体步骤\n\n第一步：从 bs4 库内导入 BeautifulSoup 类\n\n```python\nfrom bs4 import BeautifulSoup\n```\n\n第二步：获取网页源代码文本数据\n\n```python\nhtml_data = requests.get(url = url,headers = headers).text\n```\n\n第三步：创建美味汤对象【soup】\n\n\n参数：\n\nhtml_data：网页源代码文本数据\nlxml：解释器，它是固定不变的\n\n```python\nsoup_obj = BeautifulSoup(html_data,\"lxml\")\n```\n\n\n第四步：利用美味汤对象的属性以及方法匹配自己想要的数据\n\n下面代码是利用美味汤对象的css选择器方法匹配 html 标签内容\n\n```python\ndd_tag_list = soup_obj.select(\".board-wrapper>dd\")\n```\n\n总体截图\n\n![image-20211006184753558](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006184753558.png)\n\n\n\n## bs4 库匹配标签的方法\n\n\n\n标签匹配：美味汤对象 . html标签名\n示例：soup . div  \n解释：匹配 html 源代码中第一个 div 标签\n注意：这样匹配的是整个标签，即数据加上标签符号, 例如 <div>啦啦啦</div>\n\n\n\n\n\n标签属性匹配：\n美味汤对象.find（html标签名，标签属性名 = 标签属性值）\n示例：soup.find（“div”，class_ = \"str\"）\n代码解释：查找 class 属性为 str 的 div 标签\n\n注意\n1：为什么 class 后面要加上下划线 _ , 因为 class 是关键字\n2：这样匹配的数据也是整个标签\n\t\t\t\t\n\t\t\t\t\n\n美味汤对象.find_all（html标签名，标签属性名 = 标签属性值）\n示例：soup.find_all（“div”，class_ = \"str\"）\n代码解释：查找所有 class 属性为 str 的 div 标签，并且将所有匹配的标签放在一个列表内\n\n\n\n\ncss选择器匹配【标签、类、id、层级匹配】：\n\n标签选择器匹配：美味汤对象.select（“div”）\n代码解释：匹配所有的div标签\n\t\n\n类选择器匹配：美味汤对象.select（“.title”）\n代码解释：匹配 class 属性为 title 的标签，并将标签存放至列表内！.符号 代表类选择器\n注意：选择器匹配数据标签后都将标签存放至列表内\n\t\n\nid选择器匹配：美味汤对象.select（“#title”）\n代码解释：匹配 id 属性为 title 的标签，并将标签存放至列表内！#符号 代表 id 选择器\n\t\t\n\n\n大于号层级选择器：美味汤对象.select（“.title  > li  > lv”）\n代码解释：匹配 class 属性为 title 的标签里面所有的的 li 标签内的所有 lv 标签，并将标签存放至列表内！> 符号表示lv标签在li标签内！也就是子标签\n\t\t\n\n\n空格号层级选择器：美味汤对象.select（“.title   lv”）\n代码解释：匹配 class 属性为 title 的标签里面的所有 lv 标签【多级匹配】，并将标签存放至列表内！空格符号表示lv标签不是class属性为title的标签的直系标签，可能是孙标签或者重孙标签\n\n\n\n\n\n## bs4 库匹配标签内数据的方法\n\n\n\n![image-20211006185005680](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006185005680.png)\n\n\n持续更新中.......\n\n\n\n\n","tags":["常用类库篇"],"categories":["常用类库篇"]},{"title":"爬虫主流框架分享--Pyspider","url":"/2021/10/06/爬虫主流框架分享-Pyspider/","content":"\n\n\n*本文主讲内容：pyspider框架的简单使用*\n<!--more-->\n\n注意：pyspider 框架主要在windows平台上使用！\n\n## 怎么 windows 安装 pyspider 框架\n\n安装指令：\n```\npip3 install pyspider\n```\n\n\n\n注意：\n\n1：如果以上指令安装出现错误请手动下载后缀为 whl 的 pyspider 文件手动安装即可，手动安装过成功出现错误上网查一查即可\n\t\n2：安装好 pyspider 框架后，一定要先关闭所有浏览器之后再从终端输入指令 ：pyspider all 运行这个框架\n\t\n3：安装好 pyspider 框架后终端输入 pyspider all 指令出现 SyntaxError: invalid syntax 错误请看下面这篇文章进行解决\n\t\n文章链接：https://blog.csdn.net/chenjiale_123/article/details/107730039\n\t\n4：通过指令 pyspider all 运行 pyspider 框架时如果出现 ImportError: cannot import name 'ContextVar' from 'werkzeug.local' 这样的错误请看下面的文章\n\t\n文章链接：https://blog.csdn.net/qq_46485161/article/details/118860024?ops_request_misc=&request_id=&biz_id=102&utm_term=pyspider%20all%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%E5%A6%82%E4%B8%8B%EF%BC%9AImportError&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-118860024.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187\n\n\n## pyspider 框架底层使用什么原理进行匹配解析数据\n\n\n答：pyspider 框架底层是利用 pyquery 库的语法进行数据匹配的\n\n![image-20211006183217929](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183217929.png)\n\n\n## 利用 pyspider 框架爬取数据的步骤\n\n第一步：终端输入下面指令开启 pyspider 框架，如果出现 webui running on 0.0.0.0:5000 代表框架运行成功\n\n指令：\n```\npyspider all\n```\n\n![image-20211006183439282](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183439282.png)\n\n\n\n第二步：浏览器输入 localhost:5000 即可查看 pyspider 框架的 WebUl\n\n![image-20211006183458802](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183458802.png)\n\n\n\n第三步：点击右下角的 Create 即可创建爬虫项目\n\n![image-20211006183516893](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183516893.png)\n\n\n\n创建爬虫项目\n\n![image-20211006183531484](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183531484.png)\n\n\n\n第四步：创建完爬虫项目后进入下面界面开始写爬虫程序\n\n\n\n![image-20211006183554155](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183554155.png)\n\n\n\n第五步：运行写好的爬虫程序\n\n\n\n![image-20211006183606706](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183606706.png)\n\n\n\n\n##  pyspider 界面代码处的代码都有什么作用！\n\n\n\n![image-20211006183622838](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183622838.png)\n\n\n\n## pyqpider 怎么将爬取的数据存储到 Mysql 数据库内\n\n\n\n![image-20211006183634642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183634642.png)\n\n\n\n## pyspider 框架怎么自动爬取全部数据并且保存为 json 格式或者 csv 文件\n\n\n\n![image-20211006183646906](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183646906.png)\n\n将数据保存为 json 格式或者 csv 文件\n\n![image-20211006183701810](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183701810.png)\n\n","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第七期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第七期】/","content":"\n\n\n*文章主讲内容：基于Scrapy框架的分布式爬虫实现原理【最后一期】*\n\n<!--more-->\n\n\n## 分布式爬虫的原理及基于scrapy怎么实现分布式爬虫\n\n\n### 分布式爬虫的原理\n\n\n分布式爬虫目的：多台服务器抓取一个爬虫项目，数据不重复，提高数据抓取速度和效率！\n\n原理：多台服务器共享一个 url 队列（redis集合），然后一起进行数据的抓取\n\n原理实现图：\n\n![image-20211006171332912](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171332912.png)\n\n\n\n注意：多台服务器共享爬取队列是通过 scrapy_redis 模块创建的 redis 集合\n\n\n\n你问我答：三台服务器都部署相同的爬虫项目，也就拥有相同数量的的爬虫url地址（假设500），当三台服务器将所有的url都经过自身调度器交给redis创建的集合（全局url队列）之后，集合里面有多少个url地址呢？\n\n\n\n答：有500个url地址，因为redis的集合有去重功能，三个相同的爬虫项目，那每台服务器上面的url都是一样的啊\n\n\n内部流程图：\n\n![image-20211006171350568](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171350568.png)\n\n注意：\n\n1：当url通过自身调度器进入到redis创建的集合中之后，redis会为这个url生成一个指纹（实现增量式爬虫以及url的去重机制）\n\t\n2：自身调度器将url从redis集合中取出来之后，全局url队列会记录哪台服务器取走了哪个url地址，这样多台服务器协同工作时就不会出现取走相同的url并且下载的情况，也就实现了分布式！\n\t\n3：假如公司有四台服务器，做分布式爬虫时，一般需要一台服务器进行url地址的管理！！\n\n4：负责管理url地址的那台服务器也可以进行数据的抓取！！！\n\n\n\n### 实现分布式爬虫：\n\n实现原理：因为 scrapy 自身的调度器不支持分布式爬虫，因此我们需要重写 scrapy 框架的调度器从而实现分布式爬虫\n\n\n\n具体实现：\n\n1：安装 scrapy_redis模块（用作分布式爬虫的 url 全局共享队列）→ 也就是重写scrapy的调度器\n\n安装指令：\n```\nsudo pip3 install scrapy_redis\n```\n\n\n\n须知：为什么要用redis的集合充当分布式爬虫的全局url共享队列呢？\n\t\n答：因为redis是基于内存存储的，url的进与出较快，另一个原因就是 redis的集合有去重功能\n\n\n\n2：创建非分布式的 scrapy 爬虫\n\n\n\n3：在 settings.py 文件内设置一些参数即可\n\n\n\n4：多台服务器同时运行一个爬虫项目实现分布式\n\n\n\n## 创建分布式爬虫的具体步骤\n\n\n\n第一步：按照非分布式爬虫的流程创建scrapy爬虫\n\n\n\n第二步：在settings.py文件内进行参数设置，将非分布式爬虫设置为分布式爬虫（具体参数设置看下面）\n\n\n\n第三步：在多台服务器上面同时运行相同的爬虫文件\n\n\n\n\n## 分布式爬虫在settings.py文件内怎么设置参数\n\n\n\n参数设置：\n\n重新指定调度器（重写调度器）：\n\n```python\nSCHEDULER = \"scrapy_redis.scheduler.Scheduler\"\n```\n\n\n\n重新指定去重机制：\n\n```python\nDUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"\n```\n\n\n\n是否清除url指纹（默认False是清除）：\n\n```python\nSCHEDULER_PERSIST = True     \n```\n\n\n\n解释：爬虫项目结束之后，是否将url指纹清空，不清空将url指纹存在redis数据库内\n这个参数很重要常常用作爬虫的暂停、回复、断点续爬，最重要是可以实现增量式爬虫！！！\n\n设置 redis 管道：ITEM_PIPELINES = { 'scrapy_redis.pipelines.RedisPipeline': 优先级系数,}\n解释：如果需要将爬取的数据存入到redis数据库内就直接设置这个项目管道即可存入，不存redis就不用设置\t\t\n\t\t\n指定当前服务器连接到哪台服务器上面的redis数据库（连接充当url地址管理的那台服务器上面的redis）：\n\nREDIS_HOST = \"IP地址\"    【充当 url 地址管理的那台服务器的IP地址】\nREDIS_PORT = 端口号   【redis 端口号是 6379】\n\n如果 redis 设置了密码就这样设置：  REDIS_URL = \"redis：//user：密码@用户名：PORT\"\n\n\n\n![image-20211006171459467](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171459467.png)\n\n\n## RedisDesktopManager的使用\n\n### RedisDesktopManager 怎么连接 redis 数据库\n\n![image-20211006171822068](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171822068.png)\n\n### RedisDesktopManager 怎么刷新 redis 数据库里面的数据\n\n![image-20211006171857400](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171857400.png)\n\n### RedisDesktopManager 怎么查看数据库里面的数据等操作\n\n![image-20211006171846421](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171846421.png)\n\n\n## 分布式爬虫的实现【实操】\n\n### 实现分布式爬虫前的准备\n\n\n\n\n1：准备多台服务器【每台服务器上都安装了 redis数据库以及 scrapy 框架】\n\n2：确保多台服务器都可以远程连接 url 地址管理的那台服务器的 redis 数据库\n\n3：在任意一台服务器上可安装 RedisDesktopManager 图形化远程查看 redis 数据库内数据的变化\n\n\n\n### 怎么远程连接 redis 数据库\n\n\n\n安装前注意事项：待连接数据库主机以及连接数据库主机上面都需要安装 redis 数据库\n\n远程连接指令： \n```\nredis-cli -h 待连接 redis 数据库的 IP 地址\n```\n\n图示：\n\n![image-20211006172332046](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172332046.png)\n\n\n\n### 怎么解决服务器不能远程连接另外一台服务器的 redis 数据库\n\n\n\n第一步：在待远程链接的服务器（ubuntu）上面打开 /etc/redis/redis.conf 这个文件【在主目录下打开】\n\n![image-20211006172346851](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172346851.png)\n\n\n第二步：将 bind 127.0.0.1这段代码注释\n\n![image-20211006172359181](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172359181.png)\n\n第三步：将保护模式关闭\n\n![image-20211006172410385](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172410385.png)\n\n\n\n第四步：重启 redis 服务\n\n![image-20211006172420826](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172420826.png)\n\n\n\n第五步：重新远程连接 redis 数据库\n\n![image-20211006172436073](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172436073.png)\n\n\n\n### 创建分布式爬虫的步骤\n\n第一步：利用 scrapy 创建非分布式爬虫\n\n\n\n第二步：更改 settings.py 文件内的数据将非分布式爬虫部署为分布式爬虫\n\n![image-20211006172504392](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172504392.png)\n\n\n\n第三步：将 scrapy 写好的爬虫项目复制到其他几台服务器上面（其他几台服务器必须都安装 scrapy 框架以及 redis 数据库和 scrapy_redis）\n\n\n\n注意：多台服务器上面还要保证 python 的版本都要一致\n\n![image-20211006172527373](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172527373.png)\n\n![image-20211006172539335](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172539335.png)\n\n\n\n第四步：其他几台服务器一起【同时】运行这个爬虫项目即可实现分布式\n\nUbuntu系统运行爬虫项目：\n\n![image-20211006172555705](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172555705.png)\n\n\n\n其他服务器【win】运行分布式爬虫文件\n\n\n\n第一步：进入爬虫项目文件夹\n\n![image-20211006172624833](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172624833.png)\n\n第二步：进入爬虫项目文件夹后进入终端\n\n![image-20211006172632486](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172632486.png)\n\n\n第三步：输入指令运行爬虫文件\n\n![image-20211006172640031](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172640031.png)\n\n\n\n注意：多台服务器实现分布式爬虫每台服务器都需要安装 redis 数据库\n\n\n\n### 当分布式爬虫运行 充当 url 地址管理的那台服务器上面的 redis 数据库内都存放了什么数据！\n\n1：数据存放在了那里？\n\n答：redis 数据库默认将数据存放至代号为 db0 那个数据库里面\n\n\n\n2：db0 数据库里面都存放了哪些数据？\n\n答：存放了 url 地址指纹、以及爬取的数据\n\n\n\n![image-20211006172701668](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172701668.png)\n\n\n\n### 如何实现分布式增量式爬虫\n\n\n实现原理：在分布式爬虫程序结束之后，不清除 url 指纹，下载再次运行这个分布式爬虫即可实现增量式爬虫\n\n不清除指纹设置：在 settings.py 文件内设置 SCHEDULER_PERSIST 的参数值为 True 即不清除 url 指纹\n\n\n\n![image-20211006172712393](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172712393.png)\n\n\n\n### 运行分布式爬虫出现的问题解决\n\n出现的问题：在多台服务器同时运行同一个爬虫项目，因为 python 版本的不同会出现 builtins.ValueError 这种错误！\n\n\n\n![image-20211006172837040](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172837040.png)\n\n\n\n问题解决：将所有爬虫服务器上面的 python 版本都设为一致【具体操作请看 python 怎么卸载和升级】\n\n\n\n## redis_key部署分布式爬虫\n\n\n\n### redis_key 部署分布式爬虫与上面正常部署分布式爬虫相比有哪些不同?\n\n\n\n不同点：正常分布式爬虫多台主机同时运行后就开始数据的抓取了，redis_key 部署的分布式爬虫多台主机同时运行后不开始数据的抓取而是同时监听 6023 端口 等待在 redis 数据库命令行内压入初始 url 地址多台主机才同时进行数据的抓取，这样更好的控制多台主机的同步性\n\n\n\n### redis_key 部署分布式爬虫的具体步骤\n\n\n\n第一步：正常创建一个分布式爬虫【非分布式爬虫 → 设置 settings.py文件变成分布式爬虫】\n\n![image-20211006173157977](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173157977.png)\n\n\n\n第二步：在真的爬虫文件内导入 RdeisSpider 类，并且真的爬虫类继承这个类后，注释掉 start_urls 这段代码并设置 redis_key 的参数值\n\n\n\n导入模块语法：\n\n```python\nfrom scrapy_redis.spiders import RedisSpider\n```\n\n\n\n![image-20211006173212638](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173212638.png)\n\n\n\n第三步：多台服务器同时运行部署的分布式爬虫\n\n\n\nwindows服务器运行redis_key创建好的爬虫\n\n\n\n![image-20211006173235228](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173235228.png)\n\n\n\nubuntu服务器运行redis_key创建好的爬虫\n\n![image-20211006173250361](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173250361.png)\n\n\n\n第四步：进入充当 url 地址管理的那台服务器的 redis 数据库内【命令行】并压入初始 url 地址实现多台主机同时抓取数据\n\n\n\n压入初始 url 指令：LPUSH  设置的redis_key值  初始的url地址\n\n\n\n注意：初始 url 地址就是注释的 start_urls 的 url 值\n\n\n\n![image-20211006173307161](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173307161.png)\n\n\n\n\n\n### redis_key 部署分布式爬虫的缺点以及怎么解决这个缺点\n\n\n缺点：redis_key 部署的分布式爬虫在数据抓取结束后程序不会终止\n\n解决办法：在 settings.py 文件内设置 CLOSESPIDER_TIMEOUT = 3600  【到了3600时间后程序会自动退出】\n\n\n\n持续更新中......","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第六期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第六期】/","content":"\n\n\n*文章主讲内容：Scrapy处理Post请求及其设置图片管道与文件管道！*\n\n<!--more-->\n\n## Scrapy 框架怎么发送 Get 以及 Post 请求\n\n**向网站服务器发送 Get 请求**：\n\n```python\nyield scrapy.Request（url=….，meta=….，callback=…，dont_filter = True）\n```\n\n流程详解：将目标 url 交给调度器入队列，并且出队列经过引擎交给下载器，下载器向网站服务器发送 Get 请求，获取响应的对象交给解析函数处理\n\ndont_filter参数功能：\n\n值为False：当一个 url 经过调度器入队列并出队列会为这个 url 生成一个指纹，相同的url再次经过调度器时，将不在交由下载器下载，并返回响应对象！\n\n值为True：当一个 url 经过调度器入队列并出队列会为这个 url 生成一个指纹，相同的url再次经过调度器时，将继续交由下载器下载，并返回响应对象！\n\n\n\n**向网站服务器发送 Post 请求**：\n\n```python\nyield scrapy.FormRequest（url=…，formdata=…，meta=…，callback=…. , dont_filter = True）\n```\n\n流程详解：将目标url交给调度器入队列，并出队列，经过引擎交给下载器，下载器带着表单数据（formdata）向服务器网站发送Post请求，获取响应对象交给解析函数处理\n\n\n## Scrapy 框架发送 Post请求的注意事项【很重要】\n\n注意事项：在真的爬虫文件内一定要重写 start_requests 方法，因为 start_requests 源码默认是以 Get 的方式发送请求\n\n![image-20211006160521721](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160521721.png)\n\n\n\n## scrapy 框架向网站服务器发送Post请求的步骤！\n\n第一步：创建爬虫项目            scrapy startproject  爬虫项目名称\n\n\n\n第二步：进入到爬虫文件项目文件夹内          cd 真爬虫文件项目\n\n\n\n第三步：创建真的爬虫文件          scrapy genspider 真的爬虫文件名  待爬取网站域名\n\n\n\n第四步：在 item.py 文件内定义待爬取数据的字段\n\n![image-20211006160601083](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160601083.png)\n\n第五步：在真的爬虫文件内重写 start_requests 方法向服务器网站发送 Post 请求，并由解析函数解析提取数据\n\n![image-20211006160608203](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160608203.png)\n\n第六步：在项目管道内对提取的数据进行处理\n\n![image-20211006160617022](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160617022.png)\n\n第七步：设置 settings.py 文件\n\n![image-20211006160623867](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160623867.png)\n\n第八步：启动爬虫\n\n![image-20211006160630269](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160630269.png)\n\n\n注意：\n\n1：想要用Scrapy框架发送post请求一定要在真的爬虫文件内重写 strat_requests方法\n\n2：表单数据的value值都是字符串，没有整形！！！！\n\n![image-20211006160636656](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160636656.png)\n\n\n\n## Scrapy图片管道\n\n###  Scrapy 保存图片的方法（图片管道）步骤\n\n\n\n第一步：创建爬虫项目\n\n第二步：进入到爬虫项目\n\n第三步：创建真的爬虫文件\n\n\n\n第四步：进入 items.py 文件内定义图片的链接以及名称字段（保存图片一般是这两个字段）\n\n![image-20211006161005076](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161005076.png)\n\n第五步：进入真的爬虫文件内，重写 srart_requests 方法实现多线程爬虫，获取到图片的链接以及名称之后通过 yield 交给项目管道\n\n![image-20211006161012804](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161012804.png)\n\n第六步：进入 pipelines.py 文件内，继承 Scrapy 的图片管道类，重写两个方法（如下图），实现批量图片的保存\n\n![image-20211006161020873](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161020873.png)\n\n第七步：进入 settings.py 文件内，设置图片保存的路径变量 IMAGES_STORE （文件夹路径）以及其他参数\n\n![image-20211006161028154](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161028154.png)\n\n第八步：运行爬虫文件！\n\n### Scrapy 图片管道（保存图片用）的几点注意事项\n\n\n\n1：在pipelines.py文件内 管道类需要继承Scrapy为我们写好的图片管道类（ImagesPipelin）！\n\n\n\n2：我们需要重写继承的类的两个方法可实现图片的保存，即get_media_requests方法（用于图片下载）以及file_path方法（用于设置图片保存的名称）\n\n\n\n## Scrapy文件管道\n\n### os.path.splitext（url）方法的功能\n\n\n功能：将文件的下载链接拆分为两部分，用来获取文件的后缀\n\n\n语法：\n```python\nimport os\n文件后缀 = os.path.splitext（文件下载链接）\n```\n\n注意：文件下载链接为 https：//123456kkk.aaa.jpg 也可以获取到文件的后缀为 .jpg\n\n![image-20211006161342007](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161342007.png)\n\n\n\n\n### 利用 Scrapy 框架的文件管道保存网站中的文件流程\n\n\n第一步：创建爬虫项目\n\n第二步：进入到爬虫项目\n\n第三步：创建真的爬虫文件\n\n第四步：进入 items.py 文件内定义文件的链接以及名称字段（保存文件一般是这两个字段）\n\n![image-20211006161403196](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161403196.png)\n\n第五步：进入真的爬虫文件内，看情况重写 srart_requests 方法（多线程），获取到文件的链接以及名称之后通过 yield 交给项目管道\n\n![image-20211006161433059](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161433059.png)\n\n第六步：进入 pipelines.py 文件内，继承 Scrapy 的文件管道类，重写两个方法（如下图），实现批量文件的保存\n\n![image-20211006161447695](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161447695.png)\n\n第七步：进入 settings.py 文件内，设置 FILES_STORE字段（设置文件保存的路径）以及其它参数\n\n![image-20211006161458031](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161458031.png)\n\n\n\n第八步：运行爬虫文件！\n\n\n\n\n### Scrapy 框架的文件管道与图片管道在保存数据上有什么不同！\n\n\n\n1：继承的类不一样，图片是ImagesPipline，文件是 FilesPipline\n\n2：文件在项目管道内重写的 file_path 方法与图片的方法略有不同（获取文件后缀名！）\n\n\n\n持续更新中......","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第五期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第五期】/","content":"\n\n\n*文章主讲内容：scrapy设置下载器中间件*\n\n<!--more-->\n\n\n## middlewares.py 的源代码解析\n\n![image-20211006155321356](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155321356.png)\n\n![image-20211006155353971](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155353971.png)\n\n注意：我们通过下载器中间件伪装请求的时候，不在下载器中间件的源码（类）内做设置，按照源码的格式在重写新的类在伪装即可！！\n\n\n\n##  middlewares.py 文件内怎么实现伪装User-Agent\n\n\n\n![image-20211006155418580](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155418580.png)\n\n\n\n## middlewares.py 文件内怎么实现用代理IP发送请求并且处理代理IP异常\n\n![image-20211006155437047](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155437047.png)\n\n\n\n## middlewares.py 文件内怎么实现设置cookies\n\n\n\n![image-20211006155507184](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155507184.png)\n\n\n\n## 设置为中间件之后，怎么开启中间件！\n\n\n\n![image-20211006155522221](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155522221.png)\n\n\n\n## settings.py 文件内有关于中间件参数的设置！\n\n\n\n![image-20211006155541841](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155541841.png)","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第四期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第四期】/","content":"\n这已经是Scrapy的第四期教程啦，本期教程分享如何使用Scrapy实现多级页面的抓取！\n\n\n## Scrapy 爬取多级页面（二级页面）的代码结构思路\n\n<!--more-->\n\n爬取要求：\n\n1：在瓜子二手车官网的一级页面内爬取车辆的名称、价格、链接\n\n\n2：在每辆车的界面（二级页面）爬取车辆的里程、排量、变速箱\n\n\n\n代码思路：\n\n\n\n前言：在爬取一级页面的基础上升级代码\n\n\n\n第一步：在 item.py 文件内定义二级页面需要抓取的数据字段！\n\n![image-20211006153538335](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153538335.png)\n\n第二步【重点】：在真的爬虫文件内写代码实现多级页面的数据抓取（如下）\n\n![image-20211006153551602](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153551602.png)\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153551602.png)\n\n第三步：将爬取的数据（一级页面和二级页面）交给 pipelines.py 文件对数据进行保存处理\n\n![image-20211006153614025](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153614025.png)\n\n第四步：编辑 settings.py 文件内信息\n\n![image-20211006153622660](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153622660.png)\n\n\n第五步：运行爬虫\n\n![image-20211006153630738](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153630738.png)\n\n\n\n## Scrapy 的爬虫文件内的不同解析函数如何传递数据实现共同处理数据的目的\n\n\n实现指令：\n\n1：dict1= {“key”：copy.deepcopy（待传递的参数）}\n\n2：yield scrapy.Request（url=…，meta=dict1，callback=func1）    把dict1参数交给func1函数进行处理\n\n\n\n注意：\n1：必须要用copy.deepcopy（）对待传递的参数进行拷贝，否则会造成一级页面抓取的数据重复\n\n2：yield scrapy.Request（url=二级地址，meta=dict1，callback=func1）代码详解：二级页面url地址通过调度器入队列，由下载器下载，把响应对象交给 func1 函数进行处理，meta参数作为响应对象的属性传给func1函数，在func1函数内获取meta参数，可以这么写：响应对象.meta 即可\n\n\n\n\n## Scrapy 爬取多级页面（三级页面或多级页面）的代码结构思路\n\n\n\n![image-20211006153431383](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153431383.png)","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第三期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第三期】/","content":"\n这是Scrapy教程的第三期，本期教程实现抓取数据的持久化存储！\n\n\n\n## 存储须知\n\n<!--more-->\n\n\n1：将数据持久化存储都在项目管道组件中实现，存储为json以及csv文件不需要（scrapy内置命令行存储）\n\n2：scrapy特点是遇到错误程序不停止，继续执行\n\n\n\n\n## 将爬虫文件提取的数据持久化存储为 .json 以及 .csv 文件\n\n终端指令：\n\n1：scrapy crawl 爬虫文件名 -o 文件名.csv\n\n2：scrapy crawl  爬虫文件名  -o 文件名.json\n\n\n\n\n注意：存储为 csv 以及 json 文件之后，每一列数据的字段就是在 items.py 中定义的字典的键值\n\n\n\n![image-20211006152223930](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152223930.png)\n\n\n\n## 将爬虫文件提取的数据持久化存储到 Mysql 数据库以及项目管道中 return item 的作用！！\n\n### 数据持久化存储到 Mysql \n\n\n\n\n第一步：在项目管道组件文件（pipelines.py）内新建一个管道类用于将数据存储到 mysql 数据库内\n\n![image-20211006152520900](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152520900.png)\n\n第二步：在settings.py内定义连接Mysql数据库用的主机名、用户名的变量参数等等\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152520900.png)\n\n第三步：在项目管道文件内导入.settings模块，并在类中创建 open_spider( )方法，注意方法名不能变，用于连接数据库\n\n![image-20211006152536990](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152536990.png)\n\n第四步：在类中创建 close_spider( ) 方法，注意方法名是固定的，用于断开数据库\n\n![image-20211006152547024](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152547024.png)\n\n第五步：在 process_item（）方法中将数据存储到 mysql 数据库内（不要忘记commit）\n\n![image-20211006152558631](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152558631.png)\n\n第六步：在 settings.py中设置管道以及其权重\n\n![image-20211006152606394](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152606394.png)\n\n第七步：运行爬虫文件，将数据存入！\n\n![image-20211006152612573](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152612573.png)\n\n\n\n### 项目管道中process_item函数中 return item 的作用\n\n\n当前管道（类）将数据处理结束后，将数据返回给其他管道接着对数据进行处理，例如先对数据打印，再将数据存到 mysql数据库内，具体谁先谁后看管道权重！！！\n\n![image-20211006152625279](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152625279.png)\n\n\n\n## settings.py 文件内设置的参数信息功能\n\n![image-20211006152448864](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152448864.png)","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享——Scrapy【第二期】","url":"/2021/10/06/爬虫主流框架分享——Scrapy【第二期】/","content":"\n咱么继续接着上一期的支持讲解Scrapy框架，这一期讲解Scrapy进行多线程抓取\n\n## Scrapy框架写爬虫项目（单线程）的一般具体流程\n\n第一步：在指定文件夹下创建爬虫项目文件夹  指令： scrapy startproject 爬虫项目文件名（第一个字母大写）\n\n<!--more-->\n\n第二步：进入到爬虫文件夹创建真的爬虫文件 → scrapy genspider 真的爬虫文件名  待爬取网站域名\n\n第三步：进入到 items.py 文件设置保存的数据字段名（字典的key值）\n\n\n\n![image-20211006151513805](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151513805.png)\n\n\n\n第四步：进入真的爬虫文件实现数据解析提取函数功能以及将处理好的数据传给管道文件及实现网站的继续跟进提取\n\n\n\n![image-20211006151527904](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151527904.png)\n\n\n\n注意：将地址交给调度器入队列【下载器下载】是 yield  scrapy.Request（）方法！！！\n\n\n\n第五步：配置 pipelins.py（项目管道） 文件（对提取的数据作何处理）\n\n\n\n![image-20211006151545070](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151545070.png)\n\n\n\n注意：一定要在每个项目管道后面加上 return 这样才能保证每个项目管道都可被执行\n\n\n\n第六步：配置 settings.py 文件\n\n![image-20211006151601378](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151601378.png)\n\n第七步：运行写好的爬虫文件\n\n![image-20211006151615702](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151615702.png)\n\n\n\n\n\n## 爬虫项目启动引擎从爬虫文件获取第一批 url 地址交给调度器入队列的底层原理（分析源代码）！！\n\n![image-20211006151714673](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151714673.png)\n\n\n\n## Scrapy框架写爬虫项目（多任务）的常用具体流程（效率高）\n\n\n\n注意：和单任务的步骤都一样，除了真的爬虫文件里面的代码不一样！！！\n\n\n\n真的爬虫文件代码演示：\n\n![image-20211006151812872](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151812872.png)\n","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享——Scrapy【第一期】","url":"/2021/10/06/爬虫主流框架分享——Scrapy【第一期】/","content":"\n这一期文章记录自己从接触 Scrapy 框架到了解框架基本五大组件再到最后利用 Scrapy + scrapy_redis 部署分布式的过程，同样也是一起 Scrapy 的教程，加深自己对 Scrapy 框架的理解！开始！\n\n<!--more-->\n\n## 什么是Scrapy\n\n\n\n答：scrapy框架是爬虫框架，它使用Twisted异步网络库来处理网络请求（多任务），使用scrapy可以高效（爬取效率和开发效率）的完成数据的爬取\n\n\n\n## 怎么安装Scrapy\n\n\n\nWindows：pip install Scrapy\nubuntu：pip3 install Scrapy\n\n\n\n## scrapy 框架的五大组件功能及 scrapy 框架的工作流程\n\n\n\n### 五大组件加上两大中间件\n\n\n\n**引擎组件（Scrapy Engine）**：Scrapy框架的核心，负责其他组件之间的通信等\n\n**爬虫组件（Spiders）**：负责目标数据的解析提取并将数据交给项目管道，如果提取的数据含有继续跟进的二级链接，就把二级链接交给引擎循环！\n\n**调度器组件（Scheduler）**：负责将待请求的url入队列，在出队列（交给引擎），出队列之前为这个url建立指纹，防止重复抓取\n\n**下载器组件（Downloader）**：负责向目标url发送请求，并且向引擎返回 responses（响应对象）\n\n**项目管道组件（Item Pipeline）**：负责处理在爬虫组件获得的数据！\n\n**下载器中间件（Downloader Middlewares）**：处在调度器组件与下载器组件中间，调度器将目标url出队列，还未送到下载器获取响应对象之前，被下载器中间件拦下，在下载器中间件你可以对请求进行包装（User-Agent等），然后再将包装好的传到下载器组件\n\n**爬虫中间件（Spiders  Middlewares）**：处在引擎组件以及爬虫组件之间，可以修改响应状态码等，一般不做修改\n\n\n\n### 工作流程\n\n\n\n文字描述：项目开始后，引擎先向爬虫文件索要第一批待爬取的请求地址，交给调度器入队列，调度器在将地址出队列交给引擎（已经建立好指纹），引擎将地址在交给下载器，下载器向网站服务器发送请求，获取响应对象再次给引擎，引擎将响应对象交给爬虫文件，爬虫文件开始进行数据的解析提取并将数据交给引擎，如果解析的数据中包含继续跟进的url地址，引擎就把地址再次交给调度器入队列，如果不包含就将数据交给项目管道对数据进行处理（保存等）\n\n图示：\n\n\n\n![Snipaste_2021-06-18_09-58-15](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-06-18_09-58-15.png)\n\n\n\n## scrapy 爬虫文件结构\n\n\n创建爬虫项目指令：scrapy startproject 爬虫项目文件名\n\n\n文件结构图示：\n\n![Snipaste_2021-07-02_09-59-41](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-07-02_09-59-41.png)\n\n\n\n注意：spiders是一个文件夹，不是py文件，里面存放爬虫组件相关的文件\n\n\n## 利用scrapy创建一个蜘蛛爬虫流程\n\n\n第一步（创建一个爬虫项目）：scrapy startproject  爬虫文件名\n\n第二步（进入到这个爬虫文件内）：cd 爬虫文件名\n\n第三步（在爬虫项目文件内创建一个真的蜘蛛爬虫）：scrapy genspider 蜘蛛爬虫名  蜘蛛爬虫待爬取网站域名\n\n注意：\n\t1：安装好scrapy后，在哪个文件夹下面都可以创建爬虫项目\n\t2：通过第三步创建真的蜘蛛爬虫文件，就是Scrapy五大组件中的爬虫组件\n\t3：爬虫待抓取的网站域名，是以 www. 开头的，也就是去掉协议以及资源路径的地址！\n\n示例：\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-07-02_10-07-50.png)\n\n\n## Scrapy文件详解\n\n\n### 真的爬虫文件（爬虫组件）中代码的含义\n\n\n\n![Snipaste_2021-07-02_11-26-07](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-07-02_11-26-07.png)\n\n\n\n### settings.py全局爬虫配置文件内参数详解\n\n\n\n![image-20211006150433785](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150433785.png)\n\n\n## 底层代码理解scrapy爬虫框架的运行流程\n\n\n\n![image-20211006150524420](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150524420.png)\n\n\n\n\n\n## 真的爬虫文件怎么解析提取目标数据\n\n\n\n![image-20211006150728811](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150728811.png)\n\n注意事项：\n\n1：response对象调用xapth方法获得的是列表内嵌套的选择器对象，不是目标字符串，想要获取字符串，就要在后面加上get（）方法\n\t\t\n\n2：在后面加上extract（）方法就是将所有选择器对象中的字符串存到列表内！\n\n\n3：选择器对象的get方法是获取列表内第一个选择器的文本内容！！！\n\n\n\n## 怎么在终端以及Pycharm中运行scrapy写好的爬虫\n\n\n\n终端运行指令：回到爬虫目录文件夹处，键入指令 scrapy crawl 真的爬虫文件名（不带py后缀）\n\n\n\n![image-20211006150924461](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150924461.png)\n\n\n\npycharm运行：在爬虫文件夹根目录新建一个 run.py 文件，文件内代码如下即可运行写好的爬虫！\n\n\n\n![image-20211006150953636](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150953636.png)\n\n","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫抓包工具分享【第一期】","url":"/2021/10/06/爬虫抓包工具分享【第一期】/","content":"\n在我们精进爬虫的过程中，肯定需要用到额外的抓包工具，今天就给大家带来几款电脑端常用的抓包工具！\n\n\n\n## Fiddler\n<!--more-->\n**支持平台：Windows\n抓包平台：Windows、手机端\n软件官网：https://www.telerik.com/download/fiddler\n软件插件下载网站：https://www.telerik.com/fiddler/add-ons\n缺点：麦金塔电脑不支持使用！**\n\n![image-20211006143239832](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006143239832.png)\n\n\n\n## Charles\n**支持平台：Windows、麦金塔、Linux\n抓包平台：Windows、苹果端、手机端\n软件官网【未激活】：https://www.charlesproxy.com/latest-release/download.do\n激活软件网站：https://www.zzzmode.com/mytools/charles/\n优点：支持反向代理、解析AFM协议等**\n\n![image-20211006143547241](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006143547241.png)\n\n\n\n## Mitmproxy\n**抓包平台：Windows、Linux\n官网：https://mitmproxy.org/\n安装指令【win】：pip3 install mitmproxy\n构成：mitmproxy【win不支持】、mitmdump、mitmweb\n注意：这个抓包工具以指令行形式工作，可以与Python无缝交互！**\n\n\n\n![image-20211006144033405](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006144033405.png)\n\n\n\n## HttpCanary\n**手机端抓包工具......**\n\n\n持续更新中.....","tags":["爬虫常用工具"],"categories":["爬虫常用工具"]},{"title":"Github热门的Python项目分享【第一期】","url":"/2021/10/06/Github热门的Python项目分享【第一期】/","content":"\n今天给大家带来了几个在 Github 上非常有热度的 Python 项目~\n\n## 100天成为Python高手\n**详细讲解Python的语法及其各种应用场景**\n\t\thttps://github.com/jackfrued/Python-100-Days\n\n<!--more-->\n\n\n\n![image-20211006104721349](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006104721349.png)\n\n## Python热门库\n\n**Python热门库大全分享**\n\t\thttps://github.com/vinta/awesome-python\n\n![image-20211006104746753](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006104746753.png)\n\n## Python各种API分享\n\n**API接口直接调用！**\n\t\thttps://github.com/public-apis/public-apis\n\n\n\n## Python基础课程\n\n**50节Python基础课程**\n\t\thttps://github.com/jackfrued/Python-Core-50-Courses\n\n\n\n## Python有趣的项目分享\n\n**各种Python项目**\n\t\thttps://github.com/521xueweihan/HelloGitHub\n\n\n\n## Python资源大全【力荐】\n\n**Web 框架、网络爬虫、网络内容提取、模板引擎、数据库应有尽有**\n\t\thttps://github.com/jobbole/awesome-python-cn\n\n\n\n持续更新中......","tags":["Github"],"categories":["Github"]},{"title":"Github查看热门项目排名第一期","url":"/2021/10/06/Github/","content":"\n在程序猿的工作中肯定少不了与全球最大的同性交友网站Github打交道，这个网站里面有很多优质的项目源码及其教程，今天就分享给大家如何查看 Github 的热门排名项目【通过网站查看】叭~\n\n## 爱资料工具\n*通过爬虫技术获取数据并且整理排名*\n\t\thttps://www.toolnb.com/tools/githubStarRanking.html\n\n<!--more-->\n\n![image-20211006103616686](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006103616686.png)\n\n## Github内部排名\n*这里只分享 python 项目的排名网站\n\t\thttps://github.com/trending/python\n\t\t\n## Github内部项目的排名\n*在Github内的可以查看项目排名仓库\n\t\t1：https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts\n\t\t2：https://github.com/osmboy/github-rank\n\n持续更新中......","tags":["Github"],"categories":["Github"]},{"title":"在线学习网站分享【第一期】","url":"/2021/10/06/在线学习爬虫网站分享【第一期】/","content":"\n记录一下自己经常使用的编程学习网站~\n\n## 网站类\n\n### 哔哩哔哩【首推】\n*自认为全网最全的学习网站，各种资源应有尽有*\n\t\thttps://www.bilibili.com/\n\n<!--more-->\n\n![image-20211006102400127](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006102400127.png)\n\n### 菜鸟教程\n\n*精简的各种教程，支持代码在线运行等*\n\t\thttps://www.runoob.com/\n\n![image-20211006102227365](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006102227365.png)\n\n### W3chool\n\n*前端教程的扛把子*\n\t\thttps://www.w3school.com.cn/\n\n\n\n## 社区类\n\n### CSND\n*找一些问题的解决办法还是可以的，但良莠不齐*\n\t\thttps://www.csdn.net/\n\n\n\n### 博客园\n\n*里面的教程文章也还可以*\n\t\thttps://www.cnblogs.com/\n\n\n\n### 掘金\n\n*用的不多单*\n\t\thttps://juejin.cn/frontend\n\n\n\n### V2EX\n\n*俗称程序员摸鱼社区*\n\t\thttps://www.v2ex.com/\n\n\n\n### Stack Overflow\n\n*全球最大的解决问题社区【需要翻墙因此放后面了】*\n\t\thttps://stackoverflow.com/\n\n\n\n### 程序员客栈\n\n*用的不多*\n\t\thttps://www.proginn.com/\n\n\n\n## 刷题与面经\n\n### 牛客网\n\n*中国很出名刷题平台/\n\t\thttps://www.nowcoder.com/\n\n\n\n持续更新中......","tags":["学习网站"],"categories":["学习网站"]},{"title":"学习爬虫的论坛分享【第一期】","url":"/2021/10/05/学习爬虫的论坛分享【第一期】/","content":"\n打卡记录一下自己经常在学习爬虫中用到学习论坛及各位大佬的私人博客~\n\n## 爬虫安全论坛【首推】\n\n\n\t\thttps://bbs.nightteam.cn/\n\n<!--more-->\n\n![image-20211006094119665](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094119665.png)\n\n\n\n\n## Github\n*Github内搜索爬虫关键字即可查看相关文档！*\n\n\t\thttps://github.com/\n\n![image-20211006094229026](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094229026.png)\n\n## 静觅大佬的博客\n\n*虫领域出名的大佬*\n\n\t\thttps://cuiqingcai.com/\n\n![image-20211006094253342](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094253342.png)\n\n## 猿人学\n*超级超级崇拜的大佬博客【王老师】\nJS逆向水平一流！*\n\n\t\thttps://www.yuanrenxue.com/\n\n![image-20211006094302066](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094302066.png)\n\n\n## Gitee\n*中国版的代码托管平台，里面也有很多优秀教程*\n\n\t\thttps://gitee.com/\n\n![image-20211006094326267](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094326267.png)\n\n## 廖雪峰的官方网站\n\n\t\thttps://www.liaoxuefeng.com/wiki/1016959663602400\n\n![image-20211006094352822](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094352822.png)\n\n## 精易论坛\n\n\t\thttps://bbs.125.la/\n\n![image-20211006100124522](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006100124522.png)\n\n\n\n持续更新中.....","tags":["爬虫论坛"],"categories":["爬虫论坛"]},{"title":"爬虫使用的在线工具网站分享【第一期】","url":"/2021/10/04/爬虫使用的在线工具网站分享【第一期】/","content":"\n大家好！我是一名非专业的爬虫攻城狮，因为热爱，所以坚持，今天将给大家带来几款超级实用的在线网站资源，这些网站将会在你编写爬虫程序时带来很大的遍历，分享给大家的通知自己也记录一下！\n\n\n\n# 网站分享\n\n## 在线User-Agent生成\n\n```\nhttps://www.toolnb.com/tools/createuseragent.html\n```\n\n<!--more-->\n\n## 在线构造Headers\n\n```\nhttps://curl.trillworks.com/\n```\n\n## Xpath测试\n\n```\nhttps://www.toolnb.com/tools/xpath.html\n```\n\n## 模拟请求\n\n```\nhttp://www.fly63.com/php/http/\n```\n\nurl格式化\n\n```\nhttps://tools.miku.ac/url_format/\n```\n\n## 正则大全\n\n```\nhttps://tools.miku.ac/any_rule/\n```\n\n## 测试正则\n\n```\nhttps://regex101.com/\n```\n\n## Linux指令查询\n\n```\nhttps://tools.miku.ac/linux_command/\n```\n\n## 获取网页源码\n\n```\nhttps://tools.miku.ac/get_html/\n\nhttps://www.toolnb.com/tools/getHttpData.html\n```\n\n## 解析User-Agent\n\n```\nhttps://tools.miku.ac/ua_parser/\n```\n\n## 时间戳转换\n\n```\nhttps://tools.miku.ac/timestamp/\n```\n\n## Query测试\n\n```\nhttps://www.toolnb.com/tools/querylist.html\n```\n\n## WebSocket测试\n\n```\nhttp://www.toolnb.com/tools/webSocketTools.html\n\nhttps://www.toolfk.com/tool-online-runwebsocket.html\n```\n\n## CSV格式转换\n\n```\nhttps://www.toolnb.com/tools/csvconvert.html\n\nhttps://www.toolfk.com/tool-convert-csv.html\n```\n\n## Http状态码含义\n\n```\nhttps://www.toolnb.com/tools/getHttpStatusCode.html\n```\n\n## 在线Scrapy项目\n\n```\nhttps://www.toolnb.com/dev/Scrapy.html\n```\n\n## 编码解码\n\n```\nhttp://tool.mkblog.cn/unicode/\n\nhttps://www.toolfk.com/tool-encdec-transform.html\n```\n\n## 文本对比\n\n```\nhttps://tool.oschina.net/diff\n\nhttps://text-compare.com/zh-hans/\n\nhttps://www.toolfk.com/tool-online-difftext.html\n```\n\n持续更新中........","tags":["爬虫在线工具网站"],"categories":["在线工具"]},{"title":"爬虫练习平台分享【第一期】","url":"/2021/09/30/爬虫练习平台分享【第一期】/","content":"\n大家好！今天给大家带来了两款在线练习爬虫的平台，一款是综合爬虫在线练习平台，包含Cookies模拟登录、简单反爬、IP池的构建，动态页面的抓取等，另外一款则偏向于JS逆向方面的练习，通过这两个平台的综合练习我相信小伙伴的爬虫技术会越来越精进的哦，希望大家喜欢~\n\n# Scrape Center\n\n<!--more-->\n\n*综合爬虫练习平台：*\n\thttps://scrape.center/\n\n![image-20211006100419568](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006100419568.png)\n\n\n# 猿人学WEB刷题\n*JS逆向练习平台*\n\thttps://match.yuanrenxue.com/list\n\n![image-20211006100441527](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006100441527.png)\n\n持续更新中.......","tags":["爬虫练习"],"categories":["爬虫练习"]}]