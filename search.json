[{"title":"redis数据库【第四期】","url":"/2021/10/06/redis数据库【第四期】/","content":"\n\n\n\n\n*本文主讲：数据持久化存储、redis数据库主从概念、设置redis主从集群等....*\n\n<!--more-->\n\n## redis数据持久化存储\n\n\n\n### 为什么要对 redis 数据进行持久化存储\n\n\n\n答：因为 redis 数据库是通过内存进行数据的增删改查的，如果遇到突然断电的情况，存放在redis数据库里面的数据将会消失，这时就不得不考虑数据持久化了\n\n\n\n### redis 进行数据持久化存储的两种方式\n\n\n\n\n第一种方式：快照存储\n\n存储指令：bgsave\n\n![image-20211006204550454](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204550454.png)\n\n\n\n关于快照存储的一些设置：\n\n![image-20211006204617006](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204617006.png)\n\n\n\n![image-20211006204629469](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204629469.png)\n\n\n\n\n\n注意：\n\n1：dump.rdb文件是通过保存数据的 key 和value 进行数据持久化存储的\n\n\n\n2：快照存储方式还是会造成一部分数据的丢失，因为如果在部分时间内没有超过快照持久化存储的条件，那么是不会快照存储数据的\n\n\n\n\n第二种方式：aof 持久化存储【实时存储】\n\n打开 aof 持久化存储\n\n\n\n![image-20211006204649334](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204649334.png)\n\n\n\n注意：\n\n1：aof 持久化存储数据是通过把 redis 命令存放到 appendonly.aof 文件内\n\n2：在 redis4.0 版本之前如果开启了 aof 持久化存储，那么快照持久化存储就会失效\n\n\n\n\n\n### redis 进行数据持久化存储的两种方式优缺点\n\n\n\n\n快照存储：\n\n优点：长期进行数据的持久化存储不会占用太多内存\n缺点：在特殊情况下还是会造成数据的缺失【更改key的数量未超过时间阈值时断电】\n\t\t\n\t\t\naof存储：\n\n优点：可以实时进行数据的存储\n缺点：长期进行数据的持久化存储占用太多内存\n\n\n\n\n\n## redis数据库主从概念\n\n\n\n### 单台 redis 主机数据库的优缺点\n\n\n\n\n优点：部署容易，数据的操作【增、删、改】也容易\n\n缺点：数据量特别大的时候，读取和写入数据压力特别大\n\n\n\n### 为什么要为 redis 数据库设置主从【集群】\n\n\n\n\n答：因为 redis 经常用作缓存【大量的读操作】，这样如果读取数据的压力很大的时候，单台 redis 服务器就不够看了，因此就要布置 redis 数据库的主从集群\n\n\n\n### redis 数据库主从的实现\n\n\n\n实现：准备多台用于部署 redis 集群的服务器，一般是单数，设置其中一台为主服务器，另外的其他服务器设置为从服务器\n\n\n\n注意：为什么设置 redis 集群，服务器的数量时是单数，因为当集群中有一半的服务器不能用的时候，整个集群系统就不能用了，设置双数那么不是浪费服务器资源吗！\n\n\n\nredis数据库集群优点：\n\n1：提高可用性，一台服务器宕机，其他服务器也可以完成这个操作\n\n2：分散 redis 数据库大量操作的压力！\n\n\n\n图示：\n\n\n\n![image-20211006204748492](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204748492.png)\n\n\n\n注意：从服务器也可以进行写操作，但是 Redis 做缓存的时候，从服务器只执行读操作是最理想的\n\n\n\n## 设置redis主从集群\n\n\n\n### 为多台 redis 服务器设置主从集群的步骤【主服务器与从服务器的设置】\n\n\n\n第一步：准备多台装了一个版本的 redis 的服务器\n\n\n\n第二步：主服务器的配置【修改主服务器的 redis.conf 文件】\n\n\n\n配置可以远程连接\n\n\n\n![image-20211006204923811](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204923811.png)\n\n\n\n设置主服务器的密码\n\n\n\n![image-20211006204938140](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204938140.png)\n\n\n\n开启redis-server后台启动\n\n\n\n![image-20211006204959531](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006204959531.png)\n\n\n\n\n\n配置完之后重启主服务器\n\n\n\n\n第三步：从服务器的配置【修改从服务器的 redis.conf 文件】\n\n配置可以远程连接\n\n\n\n![image-20211006205024844](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205024844.png)\n\n\n\n\n开启 redis-server 后台启动\n\n\n\n![image-20211006205047105](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205047105.png)\n\n\n\n设置从服务器连接哪台主服务器以及连接那台主服务器的密码\n\n\n\n![image-20211006205059238](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205059238.png)\n\n\n\n设置从服务器的读写权限\n\n\n\n![image-20211006205113157](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205113157.png)\n\n\n\n\n配置完之后重启所有的从服务器\n\n第四步：重新连接主服务器以及所有的从服务器\n\n\n\n![image-20211006205125160](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205125160.png)\n\n\n\n### 设置完 redis 主从集群之后，怎么查看当前服务器是主服务器还是从服务器\n\n\n\n第一步：连接待查看的 redis 数据库\n\n连接指令：redis-cli\n\n\n\n\n第二步：输入下面指令即可查看\n\n查看指令：info replications\n\n\n\n![image-20211006205216956](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006205216956.png)\n\n\n\n持续更新中......","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"redis数据库【第三期】","url":"/2021/10/06/redis数据库【第三期】/","content":"\n\n\n*本文主讲内容：数据的时效时间及其redis与python进行交互！*\n\n<!--more-->\n\n\n## 数据的失效时间\n\n\n\n### 什么是数据的失效时间\n\n\n\n\n答：为数据设置一个时限，超过这个时限，这个数据就会自动删除，应用场景：验证码！\n\n\n\n### 在 redis 数据库为 key【数据】 设置失效时间的两种方式\n\n\n\n第一种形式：创建数据时为指定 key 设置失效时间\n\n\n\n语法：\n\n\n\n1：set key value ex 30        为这个 key 设置失效时间，失效时间为 30 秒\n\n2：set key value px 300000      为这个 key 设置失效时间，失效时间为 300000 毫秒\n\n\n\n![image-20211006203218465](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203218465.png)\n\n\n\n第二种形式：为已经创建的 key 添加失效时间\n\n语法：expire 已经存在的key  30       【为这个 key 设置失效时间，失效时间为 30 秒】\n\n\n\n![image-20211006203231339](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203231339.png)\n\n\n\n\n### 如何在 redis 数据库内查询某个 key 的失效时间还剩多长\n\n\n\n语法：\n\n1：ttl 指定key    【查询指定key还剩多少时间失效，查询单位显示为秒】\n2：pttl 指定key     【查询指定key还剩多少时间失效，查询单位显示为毫秒】\n\n\n\n结果：\n\n正数：查询某个键还有多少时间失效，如果显示为正数就说明还有正数这些时间失效\n\t\n-1：查询某个键还有多少时间失效，如果显示为 -1 就说明这个键永远不失效\n\t\n-2：查询某个键还有多少时间失效，如果显示为 -2 就说明这个键已经永远不失效\n\t\n图示：\n\n\n\n![image-20211006203257034](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203257034.png)\n\n\n\n\n### 在 redis 数据库内创建数据时，nx 参数与 xx 参数的作用\n\n\n\n语法：\n\n1：set key value nx         【如果这个key在redis数据库内不存在那么创建这个 key 成功】\n\t\n2：set key value xx         【如果这个key在redis数据库内存在那么创建这个 key 成功】\n\t\n3：set key value ex 30  nx         【如果这个key在redis数据库内不存在那么创建这个 key 成功，并且在30秒后这个key失效】\n\t\n4：set key value ex 30  xx         【如果这个key在redis数据库内存在那么创建这个 key 成功，并且在30秒后这个key失效】\n\n\n\n图示：\n\n\n\n![image-20211006203313886](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203313886.png)\n\n\n\n应用场景：前两种语法用于加锁的机制上面，后两种情况用于锁机制避免出现死锁的情况\n\n\n\n\n\n## redis数据库与python交互【重点】\n\n\n\n### redis 与 python 进行交互的步骤\n\n\n\n第一步：安装 python 的 redis 第三方库    →  pip3 install redis\n\n\n\n第二步：导入 redis 第三方数据库             →        import redis\n\n\n\n第三步：创建 redis 连接数据库对象        →          red_obj = redis.Redis(host=主机，port=端口号，db=数据库号)\n\n\n\n注意：redis默认有16个数据库，也就是数据库号可以是  0-15，一般选择0   redis的端口号是6379（整形）\n\n\n\n第四步：利用创建的 redis 数据库对象对数据库进行操作      →  result = red_obj.sadd(\"name：age\" , \"21\")   向外键名为name的集合内插入键为age值为“21”的一条数据\n\n\n\n注意：redis内的集合数据类型具有数据唯一性以及无序性的特征，如果上述插入的数据在集合内存在返回0，不存在返回数据1\n\n\n\n截图：\n\n\n\n![image-20211006203447702](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203447702.png)\n\n\n\n\n\n### redis 与 python 交互后通过代码对redis数据库的操作\n\n\n\nps：确保对 redis 数据库操作之前已经成功通过代码连接上 redis 数据库\n\n操作截图【对redis数据库内的string数据类型进行操作】：\n\n\n\nps：下面代码中的 sr 是建立数据库连接的对象\n\n\n\n![image-20211006203133995](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203133995.png)\n\n![image-20211006203142675](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006203142675.png)\n\n持续更新中......","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"redis数据库【第二期】","url":"/2021/10/06/redis数据库【第二期】/","content":"\n\n本文主讲：连接redis数据库及其redis数据库的数据类型\n\n<!--more-->\n\n\n## 通过指令连接 redis 数据库\n\n\n第一步：开启 redis 服务器\n\n指令：redis-server\n注意：redis-server中的 - 两边没有空格\n\n\n\n\n第二步：开启 redis 客户端\n\n指令：redis-cli -a 设置的密码\n注意：如果设置了密码需要在 redis-cli 后面跟上 -a 设置的密码\n\n\n\n第三步：输入 ping 即可进入 redis 数据库\n\n\n\n![image-20211006201254018](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201254018.png)\n\n\n\n## redis-cli 的指令选项都是干什么的\n\n\n\n选项：\n\n\n\n-a：用于认证密码                 例如 redis-cli -a yhq256112\n\n-h：用于指定连接的 ip 地址  例如 redis-cli -h 192.168.1.8      【可用于远程连接数据库】\n\n-p：用于指定redis数据库监听的端口号        例如 redis-cli -p 6379     【注意端口号一般都指定为6379】\n\n\n\n![image-20211006201319023](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201319023.png)\n\n\n\n远程连接数据库\n\n\n\n![image-20211006201326357](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201326357.png)\n\n\n\n\n\n## redis数据库的数据类型\n\n\n### 如何向 redis 指定数据库添加数据\n\n答：在连接上数据库之后执行下面指令即可选择指定数据库存放数据【redis默认有16个逻辑数据库，第一个数据库索引编号为0】\n\n\n\n指令：select 2\n\n指令解析：选择索引编号为2的数据库【第三个数据库】存放数据\n\n\n\n![image-20211006201835213](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201835213.png)\n\n\n\n### redis 数据库中 String 数据类型的操作\n\n\n数据结构：{“key”：“value”}\n\n操作语法：\n\n\n\n添加单条数据：set key value\n\t\t\n取出单条数据：get key\n\t\t\n添加多条数据：mset key1 value1 key2 value2\n\t\t\n取出多条数据：mget key1 key2\n\n\n\n图示：\n\n\n\n![image-20211006201858412](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201858412.png)\n\n\n\n\n### redis 数据库中 Hashes【散列】 数据类型的操作\n\n\n\n数据结构：{“外key”：{ “key1”：“value1”，“key2”：“value2”}}       也就是字典的嵌套\n\n\n\n![image-20211006201915642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201915642.png)\n\n\n\n操作语法：\n\t\t\n添加单条数据：hset 外key key1 value1\n\t\t\t\n取出单条数据：hget 外key key1\n\n添加多条数据：hmset 外key key1 value1 key2 values\n\t\t\t\n取出多条数据：hmget 外key key1 key2\n\t\t\t\n取出外key对应的所有数据：hgetall 外key\n\t\t\t\n删除数据：hdel 外key key1 key2\n\t\t\t\n\n图示：\n\n\n\n![image-20211006201933622](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006201933622.png)\n\n\n\n### redis 数据库中 List【列表】 数据类型的操作\n\n\n\n数据结构：{“外键key”：“ [ 'value1','value2','value3' ] ”}\n\nPS：value的值可以重复，并且列表是有序的\n\n\n\n![image-20211006202005338](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202005338.png)\n\n\n\n操作语法：\n\t\t\n在列表的左侧插入数据【单条和多条】：lpush 外键 value1 value2…..\n\t\t\n在列表的右侧插入数据【单条和多条】：rpush 外键 value1 value2…..\n\t\t\n查找列表内指定索引的值：lrange 外键 开始索引 结束索引\n\t\t\n计算外键对应列表的长度：llen 外键\n\t\t\n删除指定数量的数据：lrem 外键 删除数量 待删除的value\n\n\n\n​\t\n\n图示：\n\n\n\n![image-20211006202021426](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202021426.png)\n\n\n\n注意事项：\n\n\n\n1：在列表内插入【两端插入】数据，新来的数据总是占两端端点处！\n\n\n\n![image-20211006202033646](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202033646.png)\n\n\n\n2：删除数据时，如果删除数据的数量大于现存数据量，那么这些数据全部删除，如果小于现存数据量，就从列表前面【左端】依次开始删除\n\n\n\n### redis 数据库中 Sets【集合】 数据类型的操作\n\n\n\n\n数据结构：{“外键key”：“ （ 'value1','value2','value3' ） ”}\n\nPS：value的值不可重复，并且set是没有顺序的\n\n![image-20211006202101239](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202101239.png)\n\n\n\n操作语法：\n\t\t\n向外键key内的集合添加数据【单条和多条】：sadd 外键 value1 value2 value3\n\t\t\n查找外键内集合的所有数据：smembers 外键\n\t\t\n计算外键内集合的长度：scard 外键\n\t\t\n删除外键内集合中指定数据：srem 外键 待删除的数据1  待删除的数据2\n\t\n\n图示：\n\n![image-20211006202115415](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202115415.png)\n\n\n\n注意：\n\n\n\n1：因为集合是无序的，索引不支持索引，因此不能用索引查询\n\n\n\n\n2：集合说是无序的【应用层】，其实底层系统也帮集合数据排好序了\n\n\n\n\n\n### redis 数据库中 Sorted Set【有序集合】 数据类型的操作\n\n\n\n数据结构：{“外键key”：“ （ 'value1','value2','value3' ） ”}\n\nPS：value的值不可重复，并且set是有顺序的【根据权重从小到大排序】\n\n\n\n![image-20211006202141528](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202141528.png)\n\n操作语法：\n\n\n向外键key所对应的有序集合内插入有序数据【单条和多条】：zadd 外键key  值1的权重  值1 值2的权重 值2\n\t\t\n查找外键所对应的有序集合内指定索引的数据：zrange 外键 开始索引 结束索引\n\t\t\n计算外键内有序集合的长度：zcard 外键\n\t\t\n删除外键内有序集合中指定数据：zrem 外键 待删除的数据1  待删除的数据2\t\t\n\n\n\n图示：\n\n\n\n![image-20211006202200317](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202200317.png)\n\n\n\n### redis 数据库中查找与删除的通用操作\n\n\n\n通用操作：指令作用域是五个数据类型，而不仅仅是指定一个\n\n\n\n查找所有键【字符串类型】与外键【哈希、列表、集合、有序集合】指令：keys *\n\n\n\n删除指定键【字符串类型】与外键【哈希、列表、集合、有序集合】指令：del 键1 键2 外键1….\n\n\n\n图示：\n\n\n\n![image-20211006202221048](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202221048.png)\n\n\n\n### reids 数据库中层级目录的操作\n\n\n\n什么是层级目录：在 redis 数据库内层级目录就类似于文件夹的分级结构！\n\n\n\n为什么要设置层级目录：方便同类型数据的查询\n\n\n\n图示：\n\n![image-20211006202238649](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202238649.png)\n\n\n\n\n层级目录文件结构：\n\n\n\n![image-20211006202248298](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006202248298.png)\n\n\n\n持续更新中.......\n\n\n\n\n\n\n\n","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"redis数据库【第一期】","url":"/2021/10/06/redis数据库【第一期】/","content":"\n\n*\n本文教程主讲：\n1：什么是redis\n2：怎么安装redis\n3：如何配置redis\n*\n<!--more-->\n\n## 什么是 redis 数据库\n\n注意：\n\n\n1：redis 是非关系型数据库（以键值对的形式存储数据）\n\n\n2：互联网三高：高并发、高性能、高可用\n\n\n\n![image-20211006195929959](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195929959.png)\n\n\n\n\n\n## redis的安装\n\n\n\nwindows安装方式：\n\n\n\n安装链接：https://blog.csdn.net/weixin_41996197/article/details/89427073?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162640227416780255259420%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162640227416780255259420&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89427073.pc_search_result_control_group&utm_term=WIN10%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85redis&spm=1018.2226.3001.4187\n\n\n\n\nlinux安装指令：\n\n```\nsudo apt-get install redis-server\n```\n\n\n\n## 配置redis\n\n*注意：修改完 redis.conf 文件参数后一定要重启 redis 数据库才能生效*\n\n\n\n\n### 如何配置reids完成redis的后台启动\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件 【windows系统是redis.windows-service.conf 文件】\n\n\n\n第二步：对文件内的 daemonize 的参数进行修改即可【windows系统不支持这个参数】\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195706202](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195706202.png)\n\n\n\n### 如何配置reids实现数据库可被远程连接\n\n\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件\n\n\n\n第二步：对下面两个参数进行修改即可\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195729062](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195729062.png)\n\n\n\n### 如何配置redis实现为数据库增加密码保护\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件\n\n\n\n第二步：修改 requirepass 参数即可\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195750992](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195750992.png)\n\n\n\n### 如何配置redis实现改变数据库的数量\n\n\n\n注意：redis内数据库只是逻辑数据库，并不是真实的数据库\n\n\n\n第一步：在linux系统主目录下找到并打开 /etc/redis/redis.conf 文件\n\n\n\n第二步：修改 database 参数即可\n\n\n\n第三步：通过指令重启 redis 数据库即可生效\n\n\n\n重启指令：\n```\nsudo /etc/init.d/redis-server restart\n```\n\n\n\n![image-20211006195812670](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195812670.png)\n\n\n\n配置生效：\n\n\n\n![image-20211006195829959](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006195829959.png)\n\n\n\n","tags":["数据存储篇"],"categories":["数据存储篇"]},{"title":"爬虫工程师查缺补漏大纲流程图","url":"/2021/10/06/爬虫工程师查缺补漏大纲流程图/","content":"\n\n\n目前距离爬虫工程师的道路还有很远，下面是我自己整理待学习的爬虫资源目录，砥砺前行！\n\n<!--more-->\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F.png)\n\n\n\n爬虫路漫漫........","tags":["爬虫练习"],"categories":["爬虫练习"]},{"title":"爬虫常用解析类库——pyquery","url":"/2021/10/06/爬虫常用解析类库——pyquery/","content":"\n本文主讲内容：爬虫解析数据的类库pyquery的简单使用\n\n<!--more-->\n\n\n## 怎么安装 pyquery\n\n\n安装指令：\n```\npip3 install pyquery\n```\n\n\n\n## 使用 pyquery 匹配数据的步骤\n\n\n\n第一步：导入模块\n\n语法：\n\n```python\nfrom pyquery import PyQuery as pq\n```\n\n\n第二步：通过 PyQuery 类实例化一个 PyQuery 对象\n\n\n语法：\n\n```python\ndoc = pq（网页源代码）\ndoc = pq（url = “网站”，encoding = “字符集”）\ndoc = pq（filename= html文件，encoding = “字符集”）\n```\n\n注意：第一种实例化 PyQuery 对象的方法最常用，因为像网站发送请求时可以更加灵活的控制请求头【headers】，第三种方法也挺常用的\n\n\n\n\n\n\n\n\n\n第三步：通过实例化对象的属性和方法匹配标签以及数据！\n\n其中一种匹配数据的语法示例：doc(\"li\")            表示匹配html源代码内的所有 li 标签并且返回一个 pyquery类型的对象\n\n\n\n![image-20211006185937139](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006185937139.png)\n\n\n\n## pyquery 匹配数据的几种方法\n\n\n\n1.匹配 PyQuery 对象中的指定标签\n\n\n\n语法：\n```python\nresult = doc（“li”）\nresult = doc（“li[class = 'item-5']”）\n```\n\n语法解释：\n\n1：匹配数据类型为pyquery的指定标签【doc对象】的所有li标签，其中 result 的类型是  pyquery 类型\n\n\n\n2：匹配数据类型为pyquery的指定标签【doc对象】的class属性为“item-5”的所有li标签，其中 result 的类型是  pyquery 类型\n\n\n\n语法1\n\n![image-20211006190037183](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190037183.png)\n\n\n\n语法2：\n\n\n\n![image-20211006190055496](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190055496.png)\n\n\n\n\n\n2.通过css选择器语法匹配指定标签\n\n\n\n语法：result = doc（“.item-1”）   或者  result = doc（“#item-1”）    其中 . 代表class，#代表id 【参考bs4】\n\n\n解释：匹配doc对象中【html源码】的所有class属性为“item-1”的标签，其中 result 的类型是  pyquery 类型\n\n\n\n![image-20211006190114499](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190114499.png)\n\n\n\n3.查找某标签下的子标签\n\n\n\n语法：数据类型为pyquery的指定标签.find（“.item-1”）\n\n解释：在数据类型为pyquery的指定标签下通过 find 方法找到class属性为“item-1”的所有标签，并且返回为一个 pyquery类型的数据\n\n\n\n![image-20211006190129042](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190129042.png)\n\n\n\n\n\n4.查找某标签下的父【祖父】标签\n\n\n\n\n语法：\n```python\n数据类型为pyquery的指定标签.parent（）\n数据类型为pyquery的指定标签.parents（）\n```\n\n\n\n解释：\n\n\n\n1：通过数据类型为pyquery的指定标签的partent方法找到这个标签的父标签，并返回一个数据类型为 pyquery 的数据\n\n\n\n2：通过数据类型为pyquery的指定标签的partents方法找到这个标签的父与祖父标签，并返回一个数据类型为 pyquery 的数据\n\n\n\n![image-20211006190306526](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190306526.png)\n\n\n\n\n\n5.可遍历【迭代】的标签对象\n\n\n语法：数据类型为pyquery的指定标签（“.item-0”）.items（）\n\n\n解释：匹配数据类型为pyquery的指定标签里面的所有class属性为“item-0”的标签，并且将这些标签存放到一个可迭代对象里面而不是返回一个数据类型为 pyquery的数据\n\n注意：循环遍历出去的class属性为“item-0”的标签还是一个数据类型为pyquery的数据\n\n\n\n![image-20211006190321688](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190321688.png)\n\n\n\n6.获取数据类型为pyquery的指定标签内的属性\n\n\n\n语法：\n```python\n数据类型为pyquery的指定标签.attr（'href'）\n数据类型为pyquery的指定标签.attr.href\n```\n\n\n\n解释：匹配数据类型为 pyquery 的指定标签内的 href 属性的值\n\n\n\n![image-20211006190446228](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190446228.png)\n\n\n\n7.获取指定标签内的文本数据\n\n\n\n语法：数据类型为pyquery的指定标签.text（）\n\n语法解释：获取 数据类型为pyquery的指定标签 的文本数据值\n\n![image-20211006190505146](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190505146.png)\n\n\n\n8.获取指定标签下的html标签\n\n语法：数据类型为pyquery的指定标签.html（）\n\n语法解释：获取数据类型为pyquery的指定标签下一级的html标签\n\n\n\n![image-20211006190528353](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190528353.png)\n\n\n\n\n\n9.DOM操作【向数据类型为 pyquery 的指定标签内增加类和移除类】\n\n语法：\n```python\n数据类型为 pyquery 的指定标签.add_class（'love'）\n数据类型为 pyquery 的指定标签.remove_class（'love'）\n```\n\n\n\n语法解释：\n\n1：为数据类型为 pyquery 的指定标签增加一个值为“love”的class属性\n2：为数据类型为 pyquery 的指定标签移除一个值为“love”的class属性\n\n\n\n注意：移除和增加指定标签的属性都是浅的，不是永久的作用范围只是当前程序，程序结束回归原样【每增加没移除】\n\n\n\n语法1截图：\n\n\n\n![image-20211006190641127](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190641127.png)\n\n\n\n语法2截图：\n\n\n\n![image-20211006190652635](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006190652635.png)\n\n\n\n\n\n持续更新中......","tags":["常用类库篇"],"categories":["常用类库篇"]},{"title":"爬虫常用解析类库——bs4","url":"/2021/10/06/爬虫常用解析类库——bs4/","content":"\n\n\n*本文主讲：bs4解析数据库的简答使用！*\n<!--more-->\n\n## 使用 bs4 库需要什么环境\n\n环境：\n\nbs4库：\n```\npip3 install bs4\n```\nlxml解释器：\n```\npip3 install lxml\n```\n\n\n## bs4 库匹配数据的具体步骤\n\n第一步：从 bs4 库内导入 BeautifulSoup 类\n\n```python\nfrom bs4 import BeautifulSoup\n```\n\n第二步：获取网页源代码文本数据\n\n```python\nhtml_data = requests.get(url = url,headers = headers).text\n```\n\n第三步：创建美味汤对象【soup】\n\n\n参数：\n\nhtml_data：网页源代码文本数据\nlxml：解释器，它是固定不变的\n\n```python\nsoup_obj = BeautifulSoup(html_data,\"lxml\")\n```\n\n\n第四步：利用美味汤对象的属性以及方法匹配自己想要的数据\n\n下面代码是利用美味汤对象的css选择器方法匹配 html 标签内容\n\n```python\ndd_tag_list = soup_obj.select(\".board-wrapper>dd\")\n```\n\n总体截图\n\n![image-20211006184753558](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006184753558.png)\n\n\n\n## bs4 库匹配标签的方法\n\n\n\n标签匹配：美味汤对象 . html标签名\n示例：soup . div  \n解释：匹配 html 源代码中第一个 div 标签\n注意：这样匹配的是整个标签，即数据加上标签符号, 例如 <div>啦啦啦</div>\n\n\n\n\n\n标签属性匹配：\n美味汤对象.find（html标签名，标签属性名 = 标签属性值）\n示例：soup.find（“div”，class_ = \"str\"）\n代码解释：查找 class 属性为 str 的 div 标签\n\n注意\n1：为什么 class 后面要加上下划线 _ , 因为 class 是关键字\n2：这样匹配的数据也是整个标签\n\t\t\t\t\n\t\t\t\t\n\n美味汤对象.find_all（html标签名，标签属性名 = 标签属性值）\n示例：soup.find_all（“div”，class_ = \"str\"）\n代码解释：查找所有 class 属性为 str 的 div 标签，并且将所有匹配的标签放在一个列表内\n\n\n\n\ncss选择器匹配【标签、类、id、层级匹配】：\n\n标签选择器匹配：美味汤对象.select（“div”）\n代码解释：匹配所有的div标签\n\t\n\n类选择器匹配：美味汤对象.select（“.title”）\n代码解释：匹配 class 属性为 title 的标签，并将标签存放至列表内！.符号 代表类选择器\n注意：选择器匹配数据标签后都将标签存放至列表内\n\t\n\nid选择器匹配：美味汤对象.select（“#title”）\n代码解释：匹配 id 属性为 title 的标签，并将标签存放至列表内！#符号 代表 id 选择器\n\t\t\n\n\n大于号层级选择器：美味汤对象.select（“.title  > li  > lv”）\n代码解释：匹配 class 属性为 title 的标签里面所有的的 li 标签内的所有 lv 标签，并将标签存放至列表内！> 符号表示lv标签在li标签内！也就是子标签\n\t\t\n\n\n空格号层级选择器：美味汤对象.select（“.title   lv”）\n代码解释：匹配 class 属性为 title 的标签里面的所有 lv 标签【多级匹配】，并将标签存放至列表内！空格符号表示lv标签不是class属性为title的标签的直系标签，可能是孙标签或者重孙标签\n\n\n\n\n\n## bs4 库匹配标签内数据的方法\n\n\n\n![image-20211006185005680](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006185005680.png)\n\n\n持续更新中.......\n\n\n\n\n","tags":["常用类库篇"],"categories":["常用类库篇"]},{"title":"爬虫主流框架分享--Pyspider","url":"/2021/10/06/爬虫主流框架分享-Pyspider/","content":"\n\n\n*本文主讲内容：pyspider框架的简单使用*\n<!--more-->\n\n注意：pyspider 框架主要在windows平台上使用！\n\n## 怎么 windows 安装 pyspider 框架\n\n安装指令：\n```\npip3 install pyspider\n```\n\n\n\n注意：\n\n1：如果以上指令安装出现错误请手动下载后缀为 whl 的 pyspider 文件手动安装即可，手动安装过成功出现错误上网查一查即可\n\t\n2：安装好 pyspider 框架后，一定要先关闭所有浏览器之后再从终端输入指令 ：pyspider all 运行这个框架\n\t\n3：安装好 pyspider 框架后终端输入 pyspider all 指令出现 SyntaxError: invalid syntax 错误请看下面这篇文章进行解决\n\t\n文章链接：https://blog.csdn.net/chenjiale_123/article/details/107730039\n\t\n4：通过指令 pyspider all 运行 pyspider 框架时如果出现 ImportError: cannot import name 'ContextVar' from 'werkzeug.local' 这样的错误请看下面的文章\n\t\n文章链接：https://blog.csdn.net/qq_46485161/article/details/118860024?ops_request_misc=&request_id=&biz_id=102&utm_term=pyspider%20all%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%E5%A6%82%E4%B8%8B%EF%BC%9AImportError&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-118860024.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187\n\n\n## pyspider 框架底层使用什么原理进行匹配解析数据\n\n\n答：pyspider 框架底层是利用 pyquery 库的语法进行数据匹配的\n\n![image-20211006183217929](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183217929.png)\n\n\n## 利用 pyspider 框架爬取数据的步骤\n\n第一步：终端输入下面指令开启 pyspider 框架，如果出现 webui running on 0.0.0.0:5000 代表框架运行成功\n\n指令：\n```\npyspider all\n```\n\n![image-20211006183439282](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183439282.png)\n\n\n\n第二步：浏览器输入 localhost:5000 即可查看 pyspider 框架的 WebUl\n\n![image-20211006183458802](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183458802.png)\n\n\n\n第三步：点击右下角的 Create 即可创建爬虫项目\n\n![image-20211006183516893](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183516893.png)\n\n\n\n创建爬虫项目\n\n![image-20211006183531484](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183531484.png)\n\n\n\n第四步：创建完爬虫项目后进入下面界面开始写爬虫程序\n\n\n\n![image-20211006183554155](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183554155.png)\n\n\n\n第五步：运行写好的爬虫程序\n\n\n\n![image-20211006183606706](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183606706.png)\n\n\n\n\n##  pyspider 界面代码处的代码都有什么作用！\n\n\n\n![image-20211006183622838](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183622838.png)\n\n\n\n## pyqpider 怎么将爬取的数据存储到 Mysql 数据库内\n\n\n\n![image-20211006183634642](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183634642.png)\n\n\n\n## pyspider 框架怎么自动爬取全部数据并且保存为 json 格式或者 csv 文件\n\n\n\n![image-20211006183646906](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183646906.png)\n\n将数据保存为 json 格式或者 csv 文件\n\n![image-20211006183701810](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006183701810.png)\n\n","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第七期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第七期】/","content":"\n\n\n*文章主讲内容：基于Scrapy框架的分布式爬虫实现原理【最后一期】*\n\n<!--more-->\n\n\n## 分布式爬虫的原理及基于scrapy怎么实现分布式爬虫\n\n\n### 分布式爬虫的原理\n\n\n分布式爬虫目的：多台服务器抓取一个爬虫项目，数据不重复，提高数据抓取速度和效率！\n\n原理：多台服务器共享一个 url 队列（redis集合），然后一起进行数据的抓取\n\n原理实现图：\n\n![image-20211006171332912](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171332912.png)\n\n\n\n注意：多台服务器共享爬取队列是通过 scrapy_redis 模块创建的 redis 集合\n\n\n\n你问我答：三台服务器都部署相同的爬虫项目，也就拥有相同数量的的爬虫url地址（假设500），当三台服务器将所有的url都经过自身调度器交给redis创建的集合（全局url队列）之后，集合里面有多少个url地址呢？\n\n\n\n答：有500个url地址，因为redis的集合有去重功能，三个相同的爬虫项目，那每台服务器上面的url都是一样的啊\n\n\n内部流程图：\n\n![image-20211006171350568](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171350568.png)\n\n注意：\n\n1：当url通过自身调度器进入到redis创建的集合中之后，redis会为这个url生成一个指纹（实现增量式爬虫以及url的去重机制）\n\t\n2：自身调度器将url从redis集合中取出来之后，全局url队列会记录哪台服务器取走了哪个url地址，这样多台服务器协同工作时就不会出现取走相同的url并且下载的情况，也就实现了分布式！\n\t\n3：假如公司有四台服务器，做分布式爬虫时，一般需要一台服务器进行url地址的管理！！\n\n4：负责管理url地址的那台服务器也可以进行数据的抓取！！！\n\n\n\n### 实现分布式爬虫：\n\n实现原理：因为 scrapy 自身的调度器不支持分布式爬虫，因此我们需要重写 scrapy 框架的调度器从而实现分布式爬虫\n\n\n\n具体实现：\n\n1：安装 scrapy_redis模块（用作分布式爬虫的 url 全局共享队列）→ 也就是重写scrapy的调度器\n\n安装指令：\n```\nsudo pip3 install scrapy_redis\n```\n\n\n\n须知：为什么要用redis的集合充当分布式爬虫的全局url共享队列呢？\n\t\n答：因为redis是基于内存存储的，url的进与出较快，另一个原因就是 redis的集合有去重功能\n\n\n\n2：创建非分布式的 scrapy 爬虫\n\n\n\n3：在 settings.py 文件内设置一些参数即可\n\n\n\n4：多台服务器同时运行一个爬虫项目实现分布式\n\n\n\n## 创建分布式爬虫的具体步骤\n\n\n\n第一步：按照非分布式爬虫的流程创建scrapy爬虫\n\n\n\n第二步：在settings.py文件内进行参数设置，将非分布式爬虫设置为分布式爬虫（具体参数设置看下面）\n\n\n\n第三步：在多台服务器上面同时运行相同的爬虫文件\n\n\n\n\n## 分布式爬虫在settings.py文件内怎么设置参数\n\n\n\n参数设置：\n\n重新指定调度器（重写调度器）：\n\n```python\nSCHEDULER = \"scrapy_redis.scheduler.Scheduler\"\n```\n\n\n\n重新指定去重机制：\n\n```python\nDUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"\n```\n\n\n\n是否清除url指纹（默认False是清除）：\n\n```python\nSCHEDULER_PERSIST = True     \n```\n\n\n\n解释：爬虫项目结束之后，是否将url指纹清空，不清空将url指纹存在redis数据库内\n这个参数很重要常常用作爬虫的暂停、回复、断点续爬，最重要是可以实现增量式爬虫！！！\n\n设置 redis 管道：ITEM_PIPELINES = { 'scrapy_redis.pipelines.RedisPipeline': 优先级系数,}\n解释：如果需要将爬取的数据存入到redis数据库内就直接设置这个项目管道即可存入，不存redis就不用设置\t\t\n\t\t\n指定当前服务器连接到哪台服务器上面的redis数据库（连接充当url地址管理的那台服务器上面的redis）：\n\nREDIS_HOST = \"IP地址\"    【充当 url 地址管理的那台服务器的IP地址】\nREDIS_PORT = 端口号   【redis 端口号是 6379】\n\n如果 redis 设置了密码就这样设置：  REDIS_URL = \"redis：//user：密码@用户名：PORT\"\n\n\n\n![image-20211006171459467](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171459467.png)\n\n\n## RedisDesktopManager的使用\n\n### RedisDesktopManager 怎么连接 redis 数据库\n\n![image-20211006171822068](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171822068.png)\n\n### RedisDesktopManager 怎么刷新 redis 数据库里面的数据\n\n![image-20211006171857400](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171857400.png)\n\n### RedisDesktopManager 怎么查看数据库里面的数据等操作\n\n![image-20211006171846421](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006171846421.png)\n\n\n## 分布式爬虫的实现【实操】\n\n### 实现分布式爬虫前的准备\n\n\n\n\n1：准备多台服务器【每台服务器上都安装了 redis数据库以及 scrapy 框架】\n\n2：确保多台服务器都可以远程连接 url 地址管理的那台服务器的 redis 数据库\n\n3：在任意一台服务器上可安装 RedisDesktopManager 图形化远程查看 redis 数据库内数据的变化\n\n\n\n### 怎么远程连接 redis 数据库\n\n\n\n安装前注意事项：待连接数据库主机以及连接数据库主机上面都需要安装 redis 数据库\n\n远程连接指令： \n```\nredis-cli -h 待连接 redis 数据库的 IP 地址\n```\n\n图示：\n\n![image-20211006172332046](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172332046.png)\n\n\n\n### 怎么解决服务器不能远程连接另外一台服务器的 redis 数据库\n\n\n\n第一步：在待远程链接的服务器（ubuntu）上面打开 /etc/redis/redis.conf 这个文件【在主目录下打开】\n\n![image-20211006172346851](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172346851.png)\n\n\n第二步：将 bind 127.0.0.1这段代码注释\n\n![image-20211006172359181](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172359181.png)\n\n第三步：将保护模式关闭\n\n![image-20211006172410385](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172410385.png)\n\n\n\n第四步：重启 redis 服务\n\n![image-20211006172420826](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172420826.png)\n\n\n\n第五步：重新远程连接 redis 数据库\n\n![image-20211006172436073](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172436073.png)\n\n\n\n### 创建分布式爬虫的步骤\n\n第一步：利用 scrapy 创建非分布式爬虫\n\n\n\n第二步：更改 settings.py 文件内的数据将非分布式爬虫部署为分布式爬虫\n\n![image-20211006172504392](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172504392.png)\n\n\n\n第三步：将 scrapy 写好的爬虫项目复制到其他几台服务器上面（其他几台服务器必须都安装 scrapy 框架以及 redis 数据库和 scrapy_redis）\n\n\n\n注意：多台服务器上面还要保证 python 的版本都要一致\n\n![image-20211006172527373](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172527373.png)\n\n![image-20211006172539335](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172539335.png)\n\n\n\n第四步：其他几台服务器一起【同时】运行这个爬虫项目即可实现分布式\n\nUbuntu系统运行爬虫项目：\n\n![image-20211006172555705](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172555705.png)\n\n\n\n其他服务器【win】运行分布式爬虫文件\n\n\n\n第一步：进入爬虫项目文件夹\n\n![image-20211006172624833](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172624833.png)\n\n第二步：进入爬虫项目文件夹后进入终端\n\n![image-20211006172632486](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172632486.png)\n\n\n第三步：输入指令运行爬虫文件\n\n![image-20211006172640031](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172640031.png)\n\n\n\n注意：多台服务器实现分布式爬虫每台服务器都需要安装 redis 数据库\n\n\n\n### 当分布式爬虫运行 充当 url 地址管理的那台服务器上面的 redis 数据库内都存放了什么数据！\n\n1：数据存放在了那里？\n\n答：redis 数据库默认将数据存放至代号为 db0 那个数据库里面\n\n\n\n2：db0 数据库里面都存放了哪些数据？\n\n答：存放了 url 地址指纹、以及爬取的数据\n\n\n\n![image-20211006172701668](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172701668.png)\n\n\n\n### 如何实现分布式增量式爬虫\n\n\n实现原理：在分布式爬虫程序结束之后，不清除 url 指纹，下载再次运行这个分布式爬虫即可实现增量式爬虫\n\n不清除指纹设置：在 settings.py 文件内设置 SCHEDULER_PERSIST 的参数值为 True 即不清除 url 指纹\n\n\n\n![image-20211006172712393](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172712393.png)\n\n\n\n### 运行分布式爬虫出现的问题解决\n\n出现的问题：在多台服务器同时运行同一个爬虫项目，因为 python 版本的不同会出现 builtins.ValueError 这种错误！\n\n\n\n![image-20211006172837040](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006172837040.png)\n\n\n\n问题解决：将所有爬虫服务器上面的 python 版本都设为一致【具体操作请看 python 怎么卸载和升级】\n\n\n\n## redis_key部署分布式爬虫\n\n\n\n### redis_key 部署分布式爬虫与上面正常部署分布式爬虫相比有哪些不同?\n\n\n\n不同点：正常分布式爬虫多台主机同时运行后就开始数据的抓取了，redis_key 部署的分布式爬虫多台主机同时运行后不开始数据的抓取而是同时监听 6023 端口 等待在 redis 数据库命令行内压入初始 url 地址多台主机才同时进行数据的抓取，这样更好的控制多台主机的同步性\n\n\n\n### redis_key 部署分布式爬虫的具体步骤\n\n\n\n第一步：正常创建一个分布式爬虫【非分布式爬虫 → 设置 settings.py文件变成分布式爬虫】\n\n![image-20211006173157977](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173157977.png)\n\n\n\n第二步：在真的爬虫文件内导入 RdeisSpider 类，并且真的爬虫类继承这个类后，注释掉 start_urls 这段代码并设置 redis_key 的参数值\n\n\n\n导入模块语法：\n\n```python\nfrom scrapy_redis.spiders import RedisSpider\n```\n\n\n\n![image-20211006173212638](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173212638.png)\n\n\n\n第三步：多台服务器同时运行部署的分布式爬虫\n\n\n\nwindows服务器运行redis_key创建好的爬虫\n\n\n\n![image-20211006173235228](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173235228.png)\n\n\n\nubuntu服务器运行redis_key创建好的爬虫\n\n![image-20211006173250361](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173250361.png)\n\n\n\n第四步：进入充当 url 地址管理的那台服务器的 redis 数据库内【命令行】并压入初始 url 地址实现多台主机同时抓取数据\n\n\n\n压入初始 url 指令：LPUSH  设置的redis_key值  初始的url地址\n\n\n\n注意：初始 url 地址就是注释的 start_urls 的 url 值\n\n\n\n![image-20211006173307161](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006173307161.png)\n\n\n\n\n\n### redis_key 部署分布式爬虫的缺点以及怎么解决这个缺点\n\n\n缺点：redis_key 部署的分布式爬虫在数据抓取结束后程序不会终止\n\n解决办法：在 settings.py 文件内设置 CLOSESPIDER_TIMEOUT = 3600  【到了3600时间后程序会自动退出】\n\n\n\n持续更新中......","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第六期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第六期】/","content":"\n\n\n*文章主讲内容：Scrapy处理Post请求及其设置图片管道与文件管道！*\n\n<!--more-->\n\n## Scrapy 框架怎么发送 Get 以及 Post 请求\n\n**向网站服务器发送 Get 请求**：\n\n```python\nyield scrapy.Request（url=….，meta=….，callback=…，dont_filter = True）\n```\n\n流程详解：将目标 url 交给调度器入队列，并且出队列经过引擎交给下载器，下载器向网站服务器发送 Get 请求，获取响应的对象交给解析函数处理\n\ndont_filter参数功能：\n\n值为False：当一个 url 经过调度器入队列并出队列会为这个 url 生成一个指纹，相同的url再次经过调度器时，将不在交由下载器下载，并返回响应对象！\n\n值为True：当一个 url 经过调度器入队列并出队列会为这个 url 生成一个指纹，相同的url再次经过调度器时，将继续交由下载器下载，并返回响应对象！\n\n\n\n**向网站服务器发送 Post 请求**：\n\n```python\nyield scrapy.FormRequest（url=…，formdata=…，meta=…，callback=…. , dont_filter = True）\n```\n\n流程详解：将目标url交给调度器入队列，并出队列，经过引擎交给下载器，下载器带着表单数据（formdata）向服务器网站发送Post请求，获取响应对象交给解析函数处理\n\n\n## Scrapy 框架发送 Post请求的注意事项【很重要】\n\n注意事项：在真的爬虫文件内一定要重写 start_requests 方法，因为 start_requests 源码默认是以 Get 的方式发送请求\n\n![image-20211006160521721](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160521721.png)\n\n\n\n## scrapy 框架向网站服务器发送Post请求的步骤！\n\n第一步：创建爬虫项目            scrapy startproject  爬虫项目名称\n\n\n\n第二步：进入到爬虫文件项目文件夹内          cd 真爬虫文件项目\n\n\n\n第三步：创建真的爬虫文件          scrapy genspider 真的爬虫文件名  待爬取网站域名\n\n\n\n第四步：在 item.py 文件内定义待爬取数据的字段\n\n![image-20211006160601083](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160601083.png)\n\n第五步：在真的爬虫文件内重写 start_requests 方法向服务器网站发送 Post 请求，并由解析函数解析提取数据\n\n![image-20211006160608203](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160608203.png)\n\n第六步：在项目管道内对提取的数据进行处理\n\n![image-20211006160617022](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160617022.png)\n\n第七步：设置 settings.py 文件\n\n![image-20211006160623867](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160623867.png)\n\n第八步：启动爬虫\n\n![image-20211006160630269](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160630269.png)\n\n\n注意：\n\n1：想要用Scrapy框架发送post请求一定要在真的爬虫文件内重写 strat_requests方法\n\n2：表单数据的value值都是字符串，没有整形！！！！\n\n![image-20211006160636656](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006160636656.png)\n\n\n\n## Scrapy图片管道\n\n###  Scrapy 保存图片的方法（图片管道）步骤\n\n\n\n第一步：创建爬虫项目\n\n第二步：进入到爬虫项目\n\n第三步：创建真的爬虫文件\n\n\n\n第四步：进入 items.py 文件内定义图片的链接以及名称字段（保存图片一般是这两个字段）\n\n![image-20211006161005076](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161005076.png)\n\n第五步：进入真的爬虫文件内，重写 srart_requests 方法实现多线程爬虫，获取到图片的链接以及名称之后通过 yield 交给项目管道\n\n![image-20211006161012804](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161012804.png)\n\n第六步：进入 pipelines.py 文件内，继承 Scrapy 的图片管道类，重写两个方法（如下图），实现批量图片的保存\n\n![image-20211006161020873](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161020873.png)\n\n第七步：进入 settings.py 文件内，设置图片保存的路径变量 IMAGES_STORE （文件夹路径）以及其他参数\n\n![image-20211006161028154](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161028154.png)\n\n第八步：运行爬虫文件！\n\n### Scrapy 图片管道（保存图片用）的几点注意事项\n\n\n\n1：在pipelines.py文件内 管道类需要继承Scrapy为我们写好的图片管道类（ImagesPipelin）！\n\n\n\n2：我们需要重写继承的类的两个方法可实现图片的保存，即get_media_requests方法（用于图片下载）以及file_path方法（用于设置图片保存的名称）\n\n\n\n## Scrapy文件管道\n\n### os.path.splitext（url）方法的功能\n\n\n功能：将文件的下载链接拆分为两部分，用来获取文件的后缀\n\n\n语法：\n```python\nimport os\n文件后缀 = os.path.splitext（文件下载链接）\n```\n\n注意：文件下载链接为 https：//123456kkk.aaa.jpg 也可以获取到文件的后缀为 .jpg\n\n![image-20211006161342007](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161342007.png)\n\n\n\n\n### 利用 Scrapy 框架的文件管道保存网站中的文件流程\n\n\n第一步：创建爬虫项目\n\n第二步：进入到爬虫项目\n\n第三步：创建真的爬虫文件\n\n第四步：进入 items.py 文件内定义文件的链接以及名称字段（保存文件一般是这两个字段）\n\n![image-20211006161403196](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161403196.png)\n\n第五步：进入真的爬虫文件内，看情况重写 srart_requests 方法（多线程），获取到文件的链接以及名称之后通过 yield 交给项目管道\n\n![image-20211006161433059](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161433059.png)\n\n第六步：进入 pipelines.py 文件内，继承 Scrapy 的文件管道类，重写两个方法（如下图），实现批量文件的保存\n\n![image-20211006161447695](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161447695.png)\n\n第七步：进入 settings.py 文件内，设置 FILES_STORE字段（设置文件保存的路径）以及其它参数\n\n![image-20211006161458031](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006161458031.png)\n\n\n\n第八步：运行爬虫文件！\n\n\n\n\n### Scrapy 框架的文件管道与图片管道在保存数据上有什么不同！\n\n\n\n1：继承的类不一样，图片是ImagesPipline，文件是 FilesPipline\n\n2：文件在项目管道内重写的 file_path 方法与图片的方法略有不同（获取文件后缀名！）\n\n\n\n持续更新中......","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第五期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第五期】/","content":"\n\n\n*文章主讲内容：scrapy设置下载器中间件*\n\n<!--more-->\n\n\n## middlewares.py 的源代码解析\n\n![image-20211006155321356](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155321356.png)\n\n![image-20211006155353971](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155353971.png)\n\n注意：我们通过下载器中间件伪装请求的时候，不在下载器中间件的源码（类）内做设置，按照源码的格式在重写新的类在伪装即可！！\n\n\n\n##  middlewares.py 文件内怎么实现伪装User-Agent\n\n\n\n![image-20211006155418580](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155418580.png)\n\n\n\n## middlewares.py 文件内怎么实现用代理IP发送请求并且处理代理IP异常\n\n![image-20211006155437047](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155437047.png)\n\n\n\n## middlewares.py 文件内怎么实现设置cookies\n\n\n\n![image-20211006155507184](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155507184.png)\n\n\n\n## 设置为中间件之后，怎么开启中间件！\n\n\n\n![image-20211006155522221](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155522221.png)\n\n\n\n## settings.py 文件内有关于中间件参数的设置！\n\n\n\n![image-20211006155541841](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006155541841.png)","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第四期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第四期】/","content":"\n这已经是Scrapy的第四期教程啦，本期教程分享如何使用Scrapy实现多级页面的抓取！\n\n\n## Scrapy 爬取多级页面（二级页面）的代码结构思路\n\n<!--more-->\n\n爬取要求：\n\n1：在瓜子二手车官网的一级页面内爬取车辆的名称、价格、链接\n\n\n2：在每辆车的界面（二级页面）爬取车辆的里程、排量、变速箱\n\n\n\n代码思路：\n\n\n\n前言：在爬取一级页面的基础上升级代码\n\n\n\n第一步：在 item.py 文件内定义二级页面需要抓取的数据字段！\n\n![image-20211006153538335](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153538335.png)\n\n第二步【重点】：在真的爬虫文件内写代码实现多级页面的数据抓取（如下）\n\n![image-20211006153551602](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153551602.png)\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153551602.png)\n\n第三步：将爬取的数据（一级页面和二级页面）交给 pipelines.py 文件对数据进行保存处理\n\n![image-20211006153614025](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153614025.png)\n\n第四步：编辑 settings.py 文件内信息\n\n![image-20211006153622660](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153622660.png)\n\n\n第五步：运行爬虫\n\n![image-20211006153630738](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153630738.png)\n\n\n\n## Scrapy 的爬虫文件内的不同解析函数如何传递数据实现共同处理数据的目的\n\n\n实现指令：\n\n1：dict1= {“key”：copy.deepcopy（待传递的参数）}\n\n2：yield scrapy.Request（url=…，meta=dict1，callback=func1）    把dict1参数交给func1函数进行处理\n\n\n\n注意：\n1：必须要用copy.deepcopy（）对待传递的参数进行拷贝，否则会造成一级页面抓取的数据重复\n\n2：yield scrapy.Request（url=二级地址，meta=dict1，callback=func1）代码详解：二级页面url地址通过调度器入队列，由下载器下载，把响应对象交给 func1 函数进行处理，meta参数作为响应对象的属性传给func1函数，在func1函数内获取meta参数，可以这么写：响应对象.meta 即可\n\n\n\n\n## Scrapy 爬取多级页面（三级页面或多级页面）的代码结构思路\n\n\n\n![image-20211006153431383](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006153431383.png)","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享--Scrapy【第三期】","url":"/2021/10/06/爬虫主流框架分享-Scrapy【第三期】/","content":"\n这是Scrapy教程的第三期，本期教程实现抓取数据的持久化存储！\n\n\n\n## 存储须知\n\n<!--more-->\n\n\n1：将数据持久化存储都在项目管道组件中实现，存储为json以及csv文件不需要（scrapy内置命令行存储）\n\n2：scrapy特点是遇到错误程序不停止，继续执行\n\n\n\n\n## 将爬虫文件提取的数据持久化存储为 .json 以及 .csv 文件\n\n终端指令：\n\n1：scrapy crawl 爬虫文件名 -o 文件名.csv\n\n2：scrapy crawl  爬虫文件名  -o 文件名.json\n\n\n\n\n注意：存储为 csv 以及 json 文件之后，每一列数据的字段就是在 items.py 中定义的字典的键值\n\n\n\n![image-20211006152223930](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152223930.png)\n\n\n\n## 将爬虫文件提取的数据持久化存储到 Mysql 数据库以及项目管道中 return item 的作用！！\n\n### 数据持久化存储到 Mysql \n\n\n\n\n第一步：在项目管道组件文件（pipelines.py）内新建一个管道类用于将数据存储到 mysql 数据库内\n\n![image-20211006152520900](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152520900.png)\n\n第二步：在settings.py内定义连接Mysql数据库用的主机名、用户名的变量参数等等\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152520900.png)\n\n第三步：在项目管道文件内导入.settings模块，并在类中创建 open_spider( )方法，注意方法名不能变，用于连接数据库\n\n![image-20211006152536990](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152536990.png)\n\n第四步：在类中创建 close_spider( ) 方法，注意方法名是固定的，用于断开数据库\n\n![image-20211006152547024](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152547024.png)\n\n第五步：在 process_item（）方法中将数据存储到 mysql 数据库内（不要忘记commit）\n\n![image-20211006152558631](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152558631.png)\n\n第六步：在 settings.py中设置管道以及其权重\n\n![image-20211006152606394](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152606394.png)\n\n第七步：运行爬虫文件，将数据存入！\n\n![image-20211006152612573](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152612573.png)\n\n\n\n### 项目管道中process_item函数中 return item 的作用\n\n\n当前管道（类）将数据处理结束后，将数据返回给其他管道接着对数据进行处理，例如先对数据打印，再将数据存到 mysql数据库内，具体谁先谁后看管道权重！！！\n\n![image-20211006152625279](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152625279.png)\n\n\n\n## settings.py 文件内设置的参数信息功能\n\n![image-20211006152448864](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006152448864.png)","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享——Scrapy【第二期】","url":"/2021/10/06/爬虫主流框架分享——Scrapy【第二期】/","content":"\n咱么继续接着上一期的支持讲解Scrapy框架，这一期讲解Scrapy进行多线程抓取\n\n## Scrapy框架写爬虫项目（单线程）的一般具体流程\n\n第一步：在指定文件夹下创建爬虫项目文件夹  指令： scrapy startproject 爬虫项目文件名（第一个字母大写）\n\n<!--more-->\n\n第二步：进入到爬虫文件夹创建真的爬虫文件 → scrapy genspider 真的爬虫文件名  待爬取网站域名\n\n第三步：进入到 items.py 文件设置保存的数据字段名（字典的key值）\n\n\n\n![image-20211006151513805](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151513805.png)\n\n\n\n第四步：进入真的爬虫文件实现数据解析提取函数功能以及将处理好的数据传给管道文件及实现网站的继续跟进提取\n\n\n\n![image-20211006151527904](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151527904.png)\n\n\n\n注意：将地址交给调度器入队列【下载器下载】是 yield  scrapy.Request（）方法！！！\n\n\n\n第五步：配置 pipelins.py（项目管道） 文件（对提取的数据作何处理）\n\n\n\n![image-20211006151545070](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151545070.png)\n\n\n\n注意：一定要在每个项目管道后面加上 return 这样才能保证每个项目管道都可被执行\n\n\n\n第六步：配置 settings.py 文件\n\n![image-20211006151601378](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151601378.png)\n\n第七步：运行写好的爬虫文件\n\n![image-20211006151615702](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151615702.png)\n\n\n\n\n\n## 爬虫项目启动引擎从爬虫文件获取第一批 url 地址交给调度器入队列的底层原理（分析源代码）！！\n\n![image-20211006151714673](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151714673.png)\n\n\n\n## Scrapy框架写爬虫项目（多任务）的常用具体流程（效率高）\n\n\n\n注意：和单任务的步骤都一样，除了真的爬虫文件里面的代码不一样！！！\n\n\n\n真的爬虫文件代码演示：\n\n![image-20211006151812872](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006151812872.png)\n","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫主流框架分享——Scrapy【第一期】","url":"/2021/10/06/爬虫主流框架分享——Scrapy【第一期】/","content":"\n这一期文章记录自己从接触 Scrapy 框架到了解框架基本五大组件再到最后利用 Scrapy + scrapy_redis 部署分布式的过程，同样也是一起 Scrapy 的教程，加深自己对 Scrapy 框架的理解！开始！\n\n<!--more-->\n\n## 什么是Scrapy\n\n\n\n答：scrapy框架是爬虫框架，它使用Twisted异步网络库来处理网络请求（多任务），使用scrapy可以高效（爬取效率和开发效率）的完成数据的爬取\n\n\n\n## 怎么安装Scrapy\n\n\n\nWindows：pip install Scrapy\nubuntu：pip3 install Scrapy\n\n\n\n## scrapy 框架的五大组件功能及 scrapy 框架的工作流程\n\n\n\n### 五大组件加上两大中间件\n\n\n\n**引擎组件（Scrapy Engine）**：Scrapy框架的核心，负责其他组件之间的通信等\n\n**爬虫组件（Spiders）**：负责目标数据的解析提取并将数据交给项目管道，如果提取的数据含有继续跟进的二级链接，就把二级链接交给引擎循环！\n\n**调度器组件（Scheduler）**：负责将待请求的url入队列，在出队列（交给引擎），出队列之前为这个url建立指纹，防止重复抓取\n\n**下载器组件（Downloader）**：负责向目标url发送请求，并且向引擎返回 responses（响应对象）\n\n**项目管道组件（Item Pipeline）**：负责处理在爬虫组件获得的数据！\n\n**下载器中间件（Downloader Middlewares）**：处在调度器组件与下载器组件中间，调度器将目标url出队列，还未送到下载器获取响应对象之前，被下载器中间件拦下，在下载器中间件你可以对请求进行包装（User-Agent等），然后再将包装好的传到下载器组件\n\n**爬虫中间件（Spiders  Middlewares）**：处在引擎组件以及爬虫组件之间，可以修改响应状态码等，一般不做修改\n\n\n\n### 工作流程\n\n\n\n文字描述：项目开始后，引擎先向爬虫文件索要第一批待爬取的请求地址，交给调度器入队列，调度器在将地址出队列交给引擎（已经建立好指纹），引擎将地址在交给下载器，下载器向网站服务器发送请求，获取响应对象再次给引擎，引擎将响应对象交给爬虫文件，爬虫文件开始进行数据的解析提取并将数据交给引擎，如果解析的数据中包含继续跟进的url地址，引擎就把地址再次交给调度器入队列，如果不包含就将数据交给项目管道对数据进行处理（保存等）\n\n图示：\n\n\n\n![Snipaste_2021-06-18_09-58-15](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-06-18_09-58-15.png)\n\n\n\n## scrapy 爬虫文件结构\n\n\n创建爬虫项目指令：scrapy startproject 爬虫项目文件名\n\n\n文件结构图示：\n\n![Snipaste_2021-07-02_09-59-41](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-07-02_09-59-41.png)\n\n\n\n注意：spiders是一个文件夹，不是py文件，里面存放爬虫组件相关的文件\n\n\n## 利用scrapy创建一个蜘蛛爬虫流程\n\n\n第一步（创建一个爬虫项目）：scrapy startproject  爬虫文件名\n\n第二步（进入到这个爬虫文件内）：cd 爬虫文件名\n\n第三步（在爬虫项目文件内创建一个真的蜘蛛爬虫）：scrapy genspider 蜘蛛爬虫名  蜘蛛爬虫待爬取网站域名\n\n注意：\n\t1：安装好scrapy后，在哪个文件夹下面都可以创建爬虫项目\n\t2：通过第三步创建真的蜘蛛爬虫文件，就是Scrapy五大组件中的爬虫组件\n\t3：爬虫待抓取的网站域名，是以 www. 开头的，也就是去掉协议以及资源路径的地址！\n\n示例：\n\n\n\n![](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-07-02_10-07-50.png)\n\n\n## Scrapy文件详解\n\n\n### 真的爬虫文件（爬虫组件）中代码的含义\n\n\n\n![Snipaste_2021-07-02_11-26-07](https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-07-02_11-26-07.png)\n\n\n\n### settings.py全局爬虫配置文件内参数详解\n\n\n\n![image-20211006150433785](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150433785.png)\n\n\n## 底层代码理解scrapy爬虫框架的运行流程\n\n\n\n![image-20211006150524420](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150524420.png)\n\n\n\n\n\n## 真的爬虫文件怎么解析提取目标数据\n\n\n\n![image-20211006150728811](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150728811.png)\n\n注意事项：\n\n1：response对象调用xapth方法获得的是列表内嵌套的选择器对象，不是目标字符串，想要获取字符串，就要在后面加上get（）方法\n\t\t\n\n2：在后面加上extract（）方法就是将所有选择器对象中的字符串存到列表内！\n\n\n3：选择器对象的get方法是获取列表内第一个选择器的文本内容！！！\n\n\n\n## 怎么在终端以及Pycharm中运行scrapy写好的爬虫\n\n\n\n终端运行指令：回到爬虫目录文件夹处，键入指令 scrapy crawl 真的爬虫文件名（不带py后缀）\n\n\n\n![image-20211006150924461](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150924461.png)\n\n\n\npycharm运行：在爬虫文件夹根目录新建一个 run.py 文件，文件内代码如下即可运行写好的爬虫！\n\n\n\n![image-20211006150953636](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006150953636.png)\n\n","tags":["爬虫主流框架"],"categories":["爬虫主流框架"]},{"title":"爬虫抓包工具分享【第一期】","url":"/2021/10/06/爬虫抓包工具分享【第一期】/","content":"\n在我们精进爬虫的过程中，肯定需要用到额外的抓包工具，今天就给大家带来几款电脑端常用的抓包工具！\n\n\n\n## Fiddler\n<!--more-->\n**支持平台：Windows\n抓包平台：Windows、手机端\n软件官网：https://www.telerik.com/download/fiddler\n软件插件下载网站：https://www.telerik.com/fiddler/add-ons\n缺点：麦金塔电脑不支持使用！**\n\n![image-20211006143239832](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006143239832.png)\n\n\n\n## Charles\n**支持平台：Windows、麦金塔、Linux\n抓包平台：Windows、苹果端、手机端\n软件官网【未激活】：https://www.charlesproxy.com/latest-release/download.do\n激活软件网站：https://www.zzzmode.com/mytools/charles/\n优点：支持反向代理、解析AFM协议等**\n\n![image-20211006143547241](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006143547241.png)\n\n\n\n## Mitmproxy\n**抓包平台：Windows、Linux\n官网：https://mitmproxy.org/\n安装指令【win】：pip3 install mitmproxy\n构成：mitmproxy【win不支持】、mitmdump、mitmweb\n注意：这个抓包工具以指令行形式工作，可以与Python无缝交互！**\n\n\n\n![image-20211006144033405](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006144033405.png)\n\n\n\n## HttpCanary\n**手机端抓包工具......**\n\n\n持续更新中.....","tags":["爬虫抓包常用工具"],"categories":["爬虫抓包常用工具"]},{"title":"Github热门的Python项目分享【第一期】","url":"/2021/10/06/Github热门的Python项目分享【第一期】/","content":"\n今天给大家带来了几个在 Github 上非常有热度的 Python 项目~\n\n## 100天成为Python高手\n**详细讲解Python的语法及其各种应用场景**\n\t\thttps://github.com/jackfrued/Python-100-Days\n\n<!--more-->\n\n\n\n![image-20211006104721349](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006104721349.png)\n\n## Python热门库\n\n**Python热门库大全分享**\n\t\thttps://github.com/vinta/awesome-python\n\n![image-20211006104746753](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006104746753.png)\n\n## Python各种API分享\n\n**API接口直接调用！**\n\t\thttps://github.com/public-apis/public-apis\n\n\n\n## Python基础课程\n\n**50节Python基础课程**\n\t\thttps://github.com/jackfrued/Python-Core-50-Courses\n\n\n\n## Python有趣的项目分享\n\n**各种Python项目**\n\t\thttps://github.com/521xueweihan/HelloGitHub\n\n\n\n## Python资源大全【力荐】\n\n**Web 框架、网络爬虫、网络内容提取、模板引擎、数据库应有尽有**\n\t\thttps://github.com/jobbole/awesome-python-cn\n\n\n\n持续更新中......","tags":["Github"],"categories":["Github"]},{"title":"Github查看热门项目排名第一期","url":"/2021/10/06/Github/","content":"\n在程序猿的工作中肯定少不了与全球最大的同性交友网站Github打交道，这个网站里面有很多优质的项目源码及其教程，今天就分享给大家如何查看 Github 的热门排名项目【通过网站查看】叭~\n\n## 爱资料工具\n*通过爬虫技术获取数据并且整理排名*\n\t\thttps://www.toolnb.com/tools/githubStarRanking.html\n\n<!--more-->\n\n![image-20211006103616686](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006103616686.png)\n\n## Github内部排名\n*这里只分享 python 项目的排名网站\n\t\thttps://github.com/trending/python\n\t\t\n## Github内部项目的排名\n*在Github内的可以查看项目排名仓库\n\t\t1：https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts\n\t\t2：https://github.com/osmboy/github-rank\n\n持续更新中......","tags":["Github"],"categories":["Github"]},{"title":"在线学习网站分享【第一期】","url":"/2021/10/06/在线学习爬虫网站分享【第一期】/","content":"\n记录一下自己经常使用的编程学习网站~\n\n## 网站类\n\n### 哔哩哔哩【首推】\n*自认为全网最全的学习网站，各种资源应有尽有*\n\t\thttps://www.bilibili.com/\n\n<!--more-->\n\n![image-20211006102400127](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006102400127.png)\n\n### 菜鸟教程\n\n*精简的各种教程，支持代码在线运行等*\n\t\thttps://www.runoob.com/\n\n![image-20211006102227365](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006102227365.png)\n\n### W3chool\n\n*前端教程的扛把子*\n\t\thttps://www.w3school.com.cn/\n\n\n\n## 社区类\n\n### CSND\n*找一些问题的解决办法还是可以的，但良莠不齐*\n\t\thttps://www.csdn.net/\n\n\n\n### 博客园\n\n*里面的教程文章也还可以*\n\t\thttps://www.cnblogs.com/\n\n\n\n### 掘金\n\n*用的不多单*\n\t\thttps://juejin.cn/frontend\n\n\n\n### V2EX\n\n*俗称程序员摸鱼社区*\n\t\thttps://www.v2ex.com/\n\n\n\n### Stack Overflow\n\n*全球最大的解决问题社区【需要翻墙因此放后面了】*\n\t\thttps://stackoverflow.com/\n\n\n\n### 程序员客栈\n\n*用的不多*\n\t\thttps://www.proginn.com/\n\n\n\n## 刷题与面经\n\n### 牛客网\n\n*中国很出名刷题平台/\n\t\thttps://www.nowcoder.com/\n\n\n\n持续更新中......","tags":["学习网站"],"categories":["学习网站"]},{"title":"学习爬虫的论坛分享【第一期】","url":"/2021/10/05/学习爬虫的论坛分享【第一期】/","content":"\n打卡记录一下自己经常在学习爬虫中用到学习论坛及各位大佬的私人博客~\n\n## 爬虫安全论坛【首推】\n\n\n\t\thttps://bbs.nightteam.cn/\n\n<!--more-->\n\n![image-20211006094119665](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094119665.png)\n\n\n\n\n## Github\n*Github内搜索爬虫关键字即可查看相关文档！*\n\n\t\thttps://github.com/\n\n![image-20211006094229026](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094229026.png)\n\n## 静觅大佬的博客\n\n*虫领域出名的大佬*\n\n\t\thttps://cuiqingcai.com/\n\n![image-20211006094253342](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094253342.png)\n\n## 猿人学\n*超级超级崇拜的大佬博客【王老师】\nJS逆向水平一流！*\n\n\t\thttps://www.yuanrenxue.com/\n\n![image-20211006094302066](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094302066.png)\n\n\n## Gitee\n*中国版的代码托管平台，里面也有很多优秀教程*\n\n\t\thttps://gitee.com/\n\n![image-20211006094326267](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094326267.png)\n\n## 廖雪峰的官方网站\n\n\t\thttps://www.liaoxuefeng.com/wiki/1016959663602400\n\n![image-20211006094352822](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006094352822.png)\n\n## 精易论坛\n\n\t\thttps://bbs.125.la/\n\n![image-20211006100124522](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006100124522.png)\n\n\n\n持续更新中.....","tags":["爬虫论坛"],"categories":["爬虫论坛"]},{"title":"爬虫使用的在线工具网站分享【第一期】","url":"/2021/10/04/爬虫使用的在线工具网站分享【第一期】/","content":"\n大家好！我是一名非专业的爬虫攻城狮，因为热爱，所以坚持，今天将给大家带来几款超级实用的在线网站资源，这些网站将会在你编写爬虫程序时带来很大的遍历，分享给大家的通知自己也记录一下！\n\n\n\n# 网站分享\n\n## 在线User-Agent生成\n\n```\nhttps://www.toolnb.com/tools/createuseragent.html\n```\n\n<!--more-->\n\n## 在线构造Headers\n\n```\nhttps://curl.trillworks.com/\n```\n\n## Xpath测试\n\n```\nhttps://www.toolnb.com/tools/xpath.html\n```\n\n## 模拟请求\n\n```\nhttp://www.fly63.com/php/http/\n```\n\nurl格式化\n\n```\nhttps://tools.miku.ac/url_format/\n```\n\n## 正则大全\n\n```\nhttps://tools.miku.ac/any_rule/\n```\n\n## 测试正则\n\n```\nhttps://regex101.com/\n```\n\n## Linux指令查询\n\n```\nhttps://tools.miku.ac/linux_command/\n```\n\n## 获取网页源码\n\n```\nhttps://tools.miku.ac/get_html/\n\nhttps://www.toolnb.com/tools/getHttpData.html\n```\n\n## 解析User-Agent\n\n```\nhttps://tools.miku.ac/ua_parser/\n```\n\n## 时间戳转换\n\n```\nhttps://tools.miku.ac/timestamp/\n```\n\n## Query测试\n\n```\nhttps://www.toolnb.com/tools/querylist.html\n```\n\n## WebSocket测试\n\n```\nhttp://www.toolnb.com/tools/webSocketTools.html\n\nhttps://www.toolfk.com/tool-online-runwebsocket.html\n```\n\n## CSV格式转换\n\n```\nhttps://www.toolnb.com/tools/csvconvert.html\n\nhttps://www.toolfk.com/tool-convert-csv.html\n```\n\n## Http状态码含义\n\n```\nhttps://www.toolnb.com/tools/getHttpStatusCode.html\n```\n\n## 在线Scrapy项目\n\n```\nhttps://www.toolnb.com/dev/Scrapy.html\n```\n\n## 编码解码\n\n```\nhttp://tool.mkblog.cn/unicode/\n\nhttps://www.toolfk.com/tool-encdec-transform.html\n```\n\n## 文本对比\n\n```\nhttps://tool.oschina.net/diff\n\nhttps://text-compare.com/zh-hans/\n\nhttps://www.toolfk.com/tool-online-difftext.html\n```\n\n持续更新中........","tags":["爬虫在线工具网站"],"categories":["在线工具"]},{"title":"爬虫练习平台分享【第一期】","url":"/2021/09/30/爬虫练习平台分享【第一期】/","content":"\n大家好！今天给大家带来了两款在线练习爬虫的平台，一款是综合爬虫在线练习平台，包含Cookies模拟登录、简单反爬、IP池的构建，动态页面的抓取等，另外一款则偏向于JS逆向方面的练习，通过这两个平台的综合练习我相信小伙伴的爬虫技术会越来越精进的哦，希望大家喜欢~\n\n# Scrape Center\n\n<!--more-->\n\n*综合爬虫练习平台：*\n\thttps://scrape.center/\n\n![image-20211006100419568](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006100419568.png)\n\n\n# 猿人学WEB刷题\n*JS逆向练习平台*\n\thttps://match.yuanrenxue.com/list\n\n![image-20211006100441527](https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211006100441527.png)\n\n持续更新中.......","tags":["爬虫练习"],"categories":["爬虫练习"]}]