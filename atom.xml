<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lamb Python Blog</title>
  
  <subtitle>登高必自卑 行远必自迩</subtitle>
  <link href="http://pythonlamb.github.io/atom.xml" rel="self"/>
  
  <link href="http://pythonlamb.github.io/"/>
  <updated>2021-10-13T07:28:40.291Z</updated>
  <id>http://pythonlamb.github.io/</id>
  
  <author>
    <name>CodeLamb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫基础——selenium的使用</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94selenium%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94selenium%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-10-13T07:07:05.000Z</published>
    <updated>2021-10-13T07:28:40.291Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：selenium的安装与使用等等…..</p><span id="more"></span>        <h2 id="selenium环境安装【重点】"   >          <a href="#selenium环境安装【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium环境安装【重点】" class="headerlink" title="selenium环境安装【重点】"></a>selenium环境安装【重点】</h2>              <h3 id="什么是selenium以及selenium怎么实现抓取网页数据"   >          <a href="#什么是selenium以及selenium怎么实现抓取网页数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是selenium以及selenium怎么实现抓取网页数据" class="headerlink" title="什么是selenium以及selenium怎么实现抓取网页数据"></a>什么是selenium以及selenium怎么实现抓取网页数据</h3>      <p>答：selenium是web自动化测试工具，不是浏览器，它常常配合浏览器来实现网站的自动化测试，也就是说selenium可以自动化操作留浏览器进行一些行为，selenium配合浏览器就可以实现数据的抓取（可见即可得）</p>        <h3 id="怎么查看python安装在哪个路径的指令（win与linux）"   >          <a href="#怎么查看python安装在哪个路径的指令（win与linux）" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查看python安装在哪个路径的指令（win与linux）" class="headerlink" title="怎么查看python安装在哪个路径的指令（win与linux）"></a>怎么查看python安装在哪个路径的指令（win与linux）</h3>      <p>window指令：<code>where python</code></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152832885.png"  alt="image-20211013152832885">      </p><p>linux指令：<code>whereis python</code></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152021640.png"  alt="image-20211013152021640">      </p>        <h3 id="怎么安装-selenium-工具（库）"   >          <a href="#怎么安装-selenium-工具（库）" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么安装-selenium-工具（库）" class="headerlink" title="怎么安装 selenium 工具（库）"></a>怎么安装 selenium 工具（库）</h3>      <p>Windows + linux指令：<code>pip3 install selenium</code></p>        <h3 id="安装-selenium-浏览器工具的环境步骤"   >          <a href="#安装-selenium-浏览器工具的环境步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装-selenium-浏览器工具的环境步骤" class="headerlink" title="安装 selenium + 浏览器工具的环境步骤"></a>安装 selenium + 浏览器工具的环境步骤</h3>      <p>使用selenium + 浏览器最常见的四种组合如下：</p><p>1：selenium + PhantomJS</p><p>2：selenium + Chrome + chromedriver</p><p>3：selenium + Firefox + geckodriver</p><p>4：selenium + Edge + </p><p>注意：其中后面带有driver就是浏览器驱动程序，PhantomJS是无头浏览器因此不需要驱动（行为都在内存中发生！）</p><p>安装步骤：</p><p>注意：下面常用的程序都可以在淘宝镜像网站中下载：   <span class="exturl"><a class="exturl__link"   href="https://npm.taobao.org/mirrors" >https://npm.taobao.org/mirrors</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>第一步：首先确保你的电脑（windows与linux）都安装了这四个浏览器以及 selenium 工具，剩下的就是安装对应的浏览器驱动</p><p>PhantomJS下载地址：<span class="exturl"><a class="exturl__link"   href="https://npm.taobao.org/mirrors/phantomjs/" >https://npm.taobao.org/mirrors/phantomjs/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>第二步：下载每个浏览器的驱动（下载windows以及linxu版本）</p><p>chromedriver下载地址（下载与chrome版本一致的驱动）：<span class="exturl"><a class="exturl__link"   href="https://npm.taobao.org/mirrors/chromedriver/" >https://npm.taobao.org/mirrors/chromedriver/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>注意：没有一致的版本就下载最接近的</p><p>geckodriver下载地址（下载版本最大的那个驱动）：<span class="exturl"><a class="exturl__link"   href="https://npm.taobao.org/mirrors/geckodriver/v0.29.1/" >https://npm.taobao.org/mirrors/geckodriver/v0.29.1/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152113696.png"  alt="image-20211013152113696">      </p><p>第三步：下载完成驱动后将驱动解压（所有压缩文件全部解压），剪切到对应文件夹下面</p><p>windows：python路径下面的Scripts文件夹下</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152123877.png"  alt="image-20211013152123877">      </p><p>linux：家目录下的usr文件夹下的bin文件夹放入成功后，将这个驱动程序权限更改为最高权限</p><p>注意：在linux下放入指定文件夹下的浏览器驱动程序是解压完成的程序，不是压缩文件！！</p><p>对应指令：</p><p><code>sudo cp 驱动文件名 /usr/bin  将驱动放入对应文件</code><br><code>sudo chmod  777  /use/bin/驱动文件名</code></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152123877.png" >      </p><p>第四步：进行测试，可以正常打开浏览器并且不闪退即可</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152144737.png"  alt="image-20211013152144737">      </p>        <h2 id="selenium应用【重点】"   >          <a href="#selenium应用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium应用【重点】" class="headerlink" title="selenium应用【重点】"></a>selenium应用【重点】</h2>              <h3 id="怎么利用selenium配合浏览器打开指定网页并且对网页进行一些操作"   >          <a href="#怎么利用selenium配合浏览器打开指定网页并且对网页进行一些操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么利用selenium配合浏览器打开指定网页并且对网页进行一些操作" class="headerlink" title="怎么利用selenium配合浏览器打开指定网页并且对网页进行一些操作"></a>怎么利用selenium配合浏览器打开指定网页并且对网页进行一些操作</h3>      <p>语法： </p><p><code>from selenium import webdriver</code>                导入模块</p><p><code>浏览器对象 = webdriver.Chrome( )</code>      打开Chrome浏览器（也可以是其他浏览器，前提是安装其他浏览器的驱动）</p><p><code>浏览器对象.get（“指定网站”）</code>           在Chrome浏览器内打开指定网站</p><p>​    </p>        <h3 id="浏览器对象的一些常用方法以及属性"   >          <a href="#浏览器对象的一些常用方法以及属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#浏览器对象的一些常用方法以及属性" class="headerlink" title="浏览器对象的一些常用方法以及属性"></a>浏览器对象的一些常用方法以及属性</h3>      <p>答：在获得浏览器对象之后，我们可以对浏览器对象执行以下方法  其中browser代指浏览器对象</p><p><code>browser.get（“指定网站”）</code> ：在浏览器内打开指定网站</p><p><code>browser.maximize_window( )</code>：将浏览器窗口最大化</p><p><code>browser.save_scrrenshot(&quot;图片名称&quot;)</code>：将浏览器当前所在的页面进行截图保存</p><p><code>browser.page_scurce</code>：获取浏览器当前页面的前端最终渲染的数据代码</p><p><code>browser.page_scurce.find（“字符串”）</code>：获取浏览器当前页面的前端最终渲染的数据代码，并在代码中查找执行字符串，查不到直接返回-1，常常用于网站最后一页的判断</p><p><code>browser.quit( )</code>：关闭浏览器</p><p><code>browser.close（）</code>：关闭当前网页</p><p><code>element_obj= browser.find_element_by_xpath(xpath语法)</code>：在浏览器内获取第一个符合xpath语法的结点对象</p><p><code>element_obj= browser.find_element_by_id (id属性值)</code>：在浏览器内获取第一个符合id属性值的结点对象</p><p><code>element_obj= browser.find_element_by_name (name属性值)</code>：在浏览器内获取第一个符合name属性值的结点对象</p><p><code>element_obj= browser.find_element_by_class_name (class属性值)</code>：在浏览器内获取第一个符合class属性值的结点对象</p><p><code>element_obj= browser.find_element_by_link_text (a标签文本)</code>：在浏览器内获取第一个符合a标签内文本的结点对象</p><p><code>element_obj_list = browser.find_elements_by_xpath(xpath语法)</code>：在浏览器内获取全部符合xpath语法的结点对象，并且返回存放所有对象的列表</p>        <h3 id="利用selenium-浏览器匹配数据的注意事项"   >          <a href="#利用selenium-浏览器匹配数据的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用selenium-浏览器匹配数据的注意事项" class="headerlink" title="利用selenium+浏览器匹配数据的注意事项"></a>利用selenium+浏览器匹配数据的注意事项</h3>      <p>1：浏览器对象在查找指定节点对象时，如果方法中的element不带s，那么就查找第一个符合规则的结点对象返回，如果带s，那就查找所有符合规则的结点对象，并且存放在指定列表中返回这个列表</p><p>2：浏览器对象根据xpath查找指定节点时，可以直接在前端的控制台找到指定节点，右键复制当前节点的xpath即可，这是为什么呢？因为利用selenium获得的数据是前端最终渲染出来的数据，而不是响应源代码，因此利用selenium匹配数据真正实现了可见即可得，管你是动态渲染还是什么，只有一句话，牛批！</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152221244.png"  alt="image-20211013152221244">      </p><p>四：浏览器对象在成功匹配指定节点后对这个结点的一些操作指令</p><p>指定节点对象 . send_keys(“待查找的数据”)：向这个结点对象发送指定数据，一般这样的结点都是搜索框结点</p><p><code>指定节点对象.click（）</code>：点击这个结点</p><p><code>指定节点对象.clear（）</code>：清空结点对象中的内容（常用于清空搜索框中的默认数据）</p><p><code>指定节点对象.get_attribute( )</code>：获取这个结点的属性值</p><p><code>指定节点对象.get_attribute( “title”)</code>：获取这个结点的 title 属性值</p><p><code>指定节点对象.text</code> ：获取这个结点对象的文本值（包括当前节点以及所有子节点的文本）！</p><p>注意事项：</p><p>1：获取结点以及子节点的文本内容，是利用结点对象的text属性，而不是text方法！！！！，切记切记！！！</p><p>2：浏览器对象.find_elements_by_xpath（xpath表达式）获取到所有符合xpath表达式的结点对象，这个结点对象与利用etree库的xpath表达式在响应源代码中提取的结点对象不一样！！！</p><p>总结截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152239461.png"  alt="image-20211013152239461">      </p>        <h2 id="selenium高级应用【重中之重】"   >          <a href="#selenium高级应用【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium高级应用【重中之重】" class="headerlink" title="selenium高级应用【重中之重】"></a>selenium高级应用【重中之重】</h2>              <h3 id="怎么把Chrome以及firefox浏览器设置为无头模式！"   >          <a href="#怎么把Chrome以及firefox浏览器设置为无头模式！" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么把Chrome以及firefox浏览器设置为无头模式！" class="headerlink" title="怎么把Chrome以及firefox浏览器设置为无头模式！"></a>怎么把Chrome以及firefox浏览器设置为无头模式！</h3>      <p>为什么要设置为无头浏览器？</p><p>答：无头浏览器性能更好一些，可以在不打开浏览器窗口的情况下进行数据的抓取</p><p>设置语法：</p><p><code>from selenium import webdriver </code>            导入模块</p><p><code>options = webdriver.ChromeOptions( )</code>     创建选项对象，注意ChromeOptions( ) 中的O是大写</p><p><code>options.add_argument(&quot;--headless&quot;) </code>        向这个选项对象中添加“headless”参数，代表无头</p><p><code>Browser = webdriver.Chrome(options = options) </code>    创建浏览器时，将设置好的options参数传入</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152255642.png"  alt="image-20211013152255642">      </p>        <h3 id="selenium打开的浏览器怎么执行javascript脚本"   >          <a href="#selenium打开的浏览器怎么执行javascript脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium打开的浏览器怎么执行javascript脚本" class="headerlink" title="selenium打开的浏览器怎么执行javascript脚本"></a>selenium打开的浏览器怎么执行javascript脚本</h3>      <p>语法：<code>浏览器对象.excute_script(&quot;javascript脚本代码)</code></p><p>实例：<code>browser.excute_script ( &quot; window.scrollTo (0,document.body.scrollHeight ）&quot; )</code></p><p>浏览器执行 window.scrollTo (0,document.body.scrollHeight）这段javascript代码，将滚动条滚到最下方</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152310256.png"  alt="image-20211013152310256">      </p>        <h3 id="selenium配合浏览器抓取数据的注意事项"   >          <a href="#selenium配合浏览器抓取数据的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium配合浏览器抓取数据的注意事项" class="headerlink" title="selenium配合浏览器抓取数据的注意事项"></a>selenium配合浏览器抓取数据的注意事项</h3>      <p>1：执行网站换页操作时，如果网站有输入第几页跳转，尽量用那个进行换页，因为如果程序在某一页报错，可以很容易知道在那一页报错</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152321863.png"  alt="image-20211013152321863">      </p><p>2：抓取动态网页时，浏览器对象需要执行javascript脚本代码（将滚轮滑到最底部！）</p><p>3：利用find_enements_by_xpath抓取的结点对象集合，然后再循环遍历，调用结点的text属性，获取当前节点以及后代节点的所有文本数据，如果数据不容易被处理，可以在当前节点下调用find_enement_by_xpath方法，在查找具体的数据结点，然后调用text属性获取数据！！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152405296.png"  alt="image-20211013152405296">      </p><p>4：如果在前端页面源码内复制结点的xpath查找不到数据！！！！，记得要自己在写一下xpath语句试一试</p>        <h3 id="怎么利用selenium操控键盘操作（不是特别重要）"   >          <a href="#怎么利用selenium操控键盘操作（不是特别重要）" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么利用selenium操控键盘操作（不是特别重要）" class="headerlink" title="怎么利用selenium操控键盘操作（不是特别重要）"></a>怎么利用selenium操控键盘操作（不是特别重要）</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152428259.png"  alt="image-20211013152428259">      </p>        <h3 id="怎么利用selenium操控鼠标操作"   >          <a href="#怎么利用selenium操控鼠标操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么利用selenium操控鼠标操作" class="headerlink" title="怎么利用selenium操控鼠标操作"></a>怎么利用selenium操控鼠标操作</h3>      <p>用selenium操作鼠标有什么用？</p><p>答：有的网站部分功能是动态加载的，你需要把鼠标放在一些元素结点上面，其他的元素结点才能被加载出来，这是我们就要用selenium模拟鼠标操作，将鼠标移动到元素节点上，这样才可以操作动态加载的其他元素结点</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152506145.png"  alt="image-20211013152506145">      </p><p>操作语法：</p><p><code>from selenium.webdriver import ActionChains</code>            导入模块</p><p><code>ActionsChains（浏览器对象）.move_to_element(to_element = 指定节点). perform（）</code>   将鼠标移动到指定目标结点处！</p><p>注意事项：必须要执行 perform方法才能真正将鼠标移动到目标结点处！</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152526149.png"  alt="image-20211013152526149">      </p><p>代码截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152534553.png"  alt="image-20211013152534553">      </p>        <h3 id="怎么利用selenium切换句柄（切换浏览器窗口）"   >          <a href="#怎么利用selenium切换句柄（切换浏览器窗口）" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么利用selenium切换句柄（切换浏览器窗口）" class="headerlink" title="怎么利用selenium切换句柄（切换浏览器窗口）"></a>怎么利用selenium切换句柄（切换浏览器窗口）</h3>      <p>切换句柄的使用场景：利用selenium创建浏览器对象，打开指定网站，在网站内点击一个链接后，又打开了一个新的窗口，但是我们的浏览器对象还是处在第一个网站的结点源代码中，想要对新窗口中的网站进行一些操作就要将浏览器对象切换到后打开网站的那个结点源代码中（句柄）</p><p>语法：</p><p><code>from selenium  import webdriver</code>                                 导入模块</p><p><code>浏览器对象 = webdriver.Chrome( )</code>                  创建浏览器对象</p><p><code>all_handles = 浏览器对象.window_handles</code>            获取当前浏览器对象所有打开的窗口对象，并存放到列表内（左边第一个窗口列表下标为0）</p><p><code>浏览器对象.switch_to.windows(指定窗口对象)</code>      将浏览器切换到指定窗口</p><p>注意事项：</p><p>1：window_headles 方法功能是获取当前浏览器的所有窗口对象，并存放在一个列表内，最左面的窗口列表下标为0</p><p>2：切换窗口中的窗口不是正常浏览器中的窗口，这里指代浏览器所处在的那个结点源代码中！</p><p>代码截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152555406.png"  alt="image-20211013152555406">      </p>        <h2 id="selenium高级操作【重中之重】"   >          <a href="#selenium高级操作【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium高级操作【重中之重】" class="headerlink" title="selenium高级操作【重中之重】"></a>selenium高级操作【重中之重】</h2>      <p>须知：如果在前端页面源码内复制结点的xpath查找不到数据！！！！，记得要自己在写一下xpath语句试一试</p>        <h3 id="selenium-控制浏览器对象切换iframe（内嵌框架）的背景"   >          <a href="#selenium-控制浏览器对象切换iframe（内嵌框架）的背景" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium-控制浏览器对象切换iframe（内嵌框架）的背景" class="headerlink" title="selenium 控制浏览器对象切换iframe（内嵌框架）的背景"></a>selenium 控制浏览器对象切换iframe（内嵌框架）的背景</h3>      <p>答：有的网站前端渲染后的html代码是嵌套类型的，就是一个网页html代码中有一个或者多个iframe结点，其中一个iframe结点就代表一个全新的网页（一般网站的登录功能都是一个iframe结点），当利用 selenium 获取 iframe 结点下面子节点并对其操作时，是不能成功的，因为 selenium 只能从 iframe 结点外面的其他结点数据中查找其他的元素，对于这种情况就要用 selenium 控制浏览器切换 iframe了，这样就可以定位到 iframe 结点中的其他结点并对其操作啦！！</p><p>注意：一般登录功能区都在iframe结点下面哦！！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152716642.png" >      </p>        <h3 id="selenium-怎么切换-iframe"   >          <a href="#selenium-怎么切换-iframe" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium-怎么切换-iframe" class="headerlink" title="selenium 怎么切换 iframe"></a>selenium 怎么切换 iframe</h3>      <p>语法1：</p><p><code>from selenium import webdriver    </code></p><p>导入模块</p><p><code>iframe_node = 浏览器对象.find_element_by_xpath( &quot;xpath语法&quot; )</code>          查找待切换的iframe结点对象</p><p><code>浏览器对象.switch_to.frame(查找到的iframe结点对象)</code>                利用switch方法进行切换，切换成功后即可定位iframe结点下的子节点并对其操作</p><p>语法2：<br><code>from selenium import webdriver  </code>        </p><p>导入模块<br><code>浏览器对象.switch_to.frame ( iframe结点的 id|name 属性值 ) </code>                              通过目标 iframe 结点的 id、name属性值可直接定位iframe结点切换</p><p>注意事项：</p><p>1：浏览器对象.switch_to.frame(查找到的iframe结点对象)  中的frame没有I</p><p>2：如果目标 iframe 结点中有 id 以及 name 属性，那么直接通过第二种语法定位iframe结点</p><p>代码截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013152746826.png"  alt="image-20211013152746826">      </p>        <h3 id="selenium-切换到iframe结点后怎么切换回来（其他的层）"   >          <a href="#selenium-切换到iframe结点后怎么切换回来（其他的层）" class="heading-link"><i class="fas fa-link"></i></a><a href="#selenium-切换到iframe结点后怎么切换回来（其他的层）" class="headerlink" title="selenium 切换到iframe结点后怎么切换回来（其他的层）"></a>selenium 切换到iframe结点后怎么切换回来（其他的层）</h3>      <p>语法：</p><p><code>浏览器对象.switch_to.parent_frame( )</code>：切换到当前iframe结点的上一级处！</p><p><code>浏览器对象.switch_to.default_content( )</code>：切换到主界面（刚打开浏览器所在的界面）</p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：selenium的安装与使用等等…..&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/tags/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>爬虫基础——爬取动态网页与Cookie模拟登录</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E7%88%AC%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E4%B8%8ECookie%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E7%88%AC%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E4%B8%8ECookie%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</id>
    <published>2021-10-13T03:04:01.000Z</published>
    <updated>2021-10-13T03:16:59.067Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：怎么爬取动态加载的页面及其Cookie模拟登录等等…..</p><span id="more"></span>        <h2 id="爬取动态网页的操作流程！【重中之重】"   >          <a href="#爬取动态网页的操作流程！【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬取动态网页的操作流程！【重中之重】" class="headerlink" title="爬取动态网页的操作流程！【重中之重】"></a>爬取动态网页的操作流程！【重中之重】</h2>      <p>目标：掌握爬取动态网页的操作流程</p>        <h3 id="爬取动态网页的操作流程（浏览器控制台流程）"   >          <a href="#爬取动态网页的操作流程（浏览器控制台流程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬取动态网页的操作流程（浏览器控制台流程）" class="headerlink" title="爬取动态网页的操作流程（浏览器控制台流程）"></a>爬取动态网页的操作流程（浏览器控制台流程）</h3>      <p>第一步：打开动态加载的网页</p><p>第二步：按下F12进行检查找到网络选项内的XHR栏等待抓包</p><p>第三步：刷新动态网页</p><p>第四步：对动态网页进行一些操作使异步加载的数据包加载出来（动态数据包也就是XHR内的数据包）</p><p>第五步：分析动态加载的数据包</p><p>第六步：利用python模拟发送请求！</p>        <h2 id="爬取动态网页【重中之重】"   >          <a href="#爬取动态网页【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬取动态网页【重中之重】" class="headerlink" title="爬取动态网页【重中之重】"></a>爬取动态网页【重中之重】</h2>      <p>目标：<br>1：掌握什么是动态网页<br>2：掌握抓取动态网页的步骤以及方法<br>3：掌握抓取动态网页的注意事项</p>        <h3 id="什么是动态网页"   >          <a href="#什么是动态网页" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是动态网页" class="headerlink" title="什么是动态网页"></a>什么是动态网页</h3>      <p>答：动态网页应该具备下面其中一个特点</p><p>特点1：网页的数据在源代码中查不到（网页源代码内没有你要找的数据）（比如腾讯招聘）</p><p>特点2：当你在网页中点击下一页或者其他操作时，网页局部刷新（比如小米应用网）</p><p>特点3：当你在网页中进行一些操作时（滑动滑轮等），数据才加载出来（比如豆瓣电影）</p><p>动态网站：腾讯招聘、小米应用网、豆瓣电影、有道翻译等等</p>        <h3 id="抓取动态网页的步骤以及方法（小米应用网为例——局部刷新的url网站）"   >          <a href="#抓取动态网页的步骤以及方法（小米应用网为例——局部刷新的url网站）" class="heading-link"><i class="fas fa-link"></i></a><a href="#抓取动态网页的步骤以及方法（小米应用网为例——局部刷新的url网站）" class="headerlink" title="抓取动态网页的步骤以及方法（小米应用网为例——局部刷新的url网站）"></a>抓取动态网页的步骤以及方法（小米应用网为例——局部刷新的url网站）</h3>      <p>第一步：按下F12进入检查，找到网络选项开始进行抓包</p><p>第二步：动态加载的数据包一般都是json格式的，对动态网页进行操作让数据加载出来，然后直接筛选XHR格式的数据包即可</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111214877.png"  alt="image-20211013111214877">      </p><p>第三步：分析XHR选项内的数据包，找到真正要抓取的那个数据包（包含数据的数据包）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111224434.png"  alt="image-20211013111224434">      </p><p>第四步：分析请求的url以及请求方式，如果是get请求，着重分析查询参数，post请求着重分析Form_data，找到所有动态加载的数据包其中的规律</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111231314.png"  alt="image-20211013111231314">      </p><p>第五步：利用 python 程序模拟浏览器向上面的 url 发送请求即可（构建查询参数）</p>        <h3 id="抓取动态网页的注意事项"   >          <a href="#抓取动态网页的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#抓取动态网页的注意事项" class="headerlink" title="抓取动态网页的注意事项"></a>抓取动态网页的注意事项</h3>      <p>1：动态加载的网页其中动态加载的数据包一般都是json格式（python中的字典格式）的字符串</p><p>2：requests模块向目标url发送请求获取对象的 json 方法可以将 json 格式的字符串转换为 Python 格式的字典！</p>        <h2 id="json解析模块的使用【重中之重】"   >          <a href="#json解析模块的使用【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#json解析模块的使用【重中之重】" class="headerlink" title="json解析模块的使用【重中之重】"></a>json解析模块的使用【重中之重】</h2>      <p>目标：<br>1：掌握 json 标准库模块的使用场景<br>2：掌握 json 标准库模块的loads方法以及dump方法功能</p>        <h3 id="json-标准库模块的使用场景"   >          <a href="#json-标准库模块的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#json-标准库模块的使用场景" class="headerlink" title="json 标准库模块的使用场景"></a>json 标准库模块的使用场景</h3>      <p>答：在抓取动态网页的异步加载的数据包时（XHR），网页服务器返回的数据包源代码是 json 格式的字符串，这时我们就要用到json解析模块来对这些json格式的字符串进行处理！！</p>        <h3 id="json-标准库模块的-loads-方法以及-dump-方法功能"   >          <a href="#json-标准库模块的-loads-方法以及-dump-方法功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#json-标准库模块的-loads-方法以及-dump-方法功能" class="headerlink" title="json 标准库模块的 loads 方法以及 dump 方法功能"></a>json 标准库模块的 loads 方法以及 dump 方法功能</h3>      <p><code>json.loads（json格式字符串）</code>方法</p><p>功能：将 json 格式的字符串转换为 Python 格式的字典</p><p>参数：json格式的字符串（动态加载的数据包网页源代码）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111231314.png" >      </p><p><code>json.dump（python，file，ensure_ascii = False）</code></p><p>功能：将Python格式的字典、列表 转换为 json 格式的字符串并且保存到 file 文件内（一般都是json后缀的文件）！</p><p>参数：</p><p>参数1：Python格式的列表、字典</p><p>参数2：待保存数据的文件名，一般是json后缀的文件</p><p>参数3（ensure_ascii）：默认值为True，我们要给改为False，否则 json 格式的字符串包含中文保存到文件中，在文件内不会正常显示！</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>（“info.json”，“w”） <span class="keyword">as</span> f：</span><br><span class="line">json.dump（Python格式的字典、列表， f ，ensure_ascii = <span class="literal">False</span>）</span><br></pre></td></tr></table></div></figure><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111312698.png"  alt="image-20211013111312698">      </p><p>注意事项：<br>1：loads方法有s，dump方法没有s<br>2：只要对文件进行操作就要利用with open打开文件</p>        <h2 id="多线程爬虫【重中之重重】"   >          <a href="#多线程爬虫【重中之重重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程爬虫【重中之重重】" class="headerlink" title="多线程爬虫【重中之重重】"></a>多线程爬虫【重中之重重】</h2>      <p>目标：<br>1：掌握多进程以及多线程的适用场景<br>2：掌握创建多线程的步骤以及常用语法<br>3：掌握多线程爬虫的工作原理<br>4：掌握Python中队列的一些操作！<br>5：掌握多线程对全局变量加线程锁的目的</p>        <h3 id="多进程以及多线程的适用场景"   >          <a href="#多进程以及多线程的适用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#多进程以及多线程的适用场景" class="headerlink" title="多进程以及多线程的适用场景"></a>多进程以及多线程的适用场景</h3>      <p>多进程适用场景：计算机密集型的操作（CPU密集型），比如说计算大量数据时，多进程可以保证同一时间多个进程同时工作，就是比较消耗内存</p><p>多线程适用场景：I/O密集型操作，比如说网络I/O、本地磁盘I/O，爬虫就是网络I/O与本地磁盘I/O（存储数据）结合体，多线程因为GIL的存在同一时间只能保证有一个线程在工作，但是也能保证同意时间肯定有一个线程在工作</p>        <h3 id="创建多线程的步骤以及常用语法"   >          <a href="#创建多线程的步骤以及常用语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建多线程的步骤以及常用语法" class="headerlink" title="创建多线程的步骤以及常用语法"></a>创建多线程的步骤以及常用语法</h3>      <p>步骤：</p><p>第一步：<code>from threading import Thread</code>   导入模块</p><p>第二步：<code>t = Thread（target=任务函数名，args=（））</code>  创建线程对象     args = （），是元组给任务函数传参，相当于位置传参</p><p>第三步：<code>t.start（）</code>    启动线程</p><p>第四步：<code>time.sleep（1）</code>  等待线程任务执行完毕</p><p>第五步：<code>t.join（）</code>  当 t 线程任务执行结束后 回收 t 这个线程（防止死线程的产生）</p><p>注意事项：</p><p>1：join（）方法功能是等待创建的某线程执行任务函数结束后进行线程的回收</p><p>2：利用 join 方法时程序会进入阻塞状态，回收完执行任务完毕的线程后才解除阻塞！</p><p>常用建立多线程语法截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111344803.png"  alt="image-20211013111344803">      </p>        <h3 id="多线程爬虫的工作原理"   >          <a href="#多线程爬虫的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程爬虫的工作原理" class="headerlink" title="多线程爬虫的工作原理"></a>多线程爬虫的工作原理</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111354627.png"  alt="image-20211013111354627">      </p>        <h3 id="Python中队列的一些操作【数据存入、取出、取数据阻塞等问题】！"   >          <a href="#Python中队列的一些操作【数据存入、取出、取数据阻塞等问题】！" class="heading-link"><i class="fas fa-link"></i></a><a href="#Python中队列的一些操作【数据存入、取出、取数据阻塞等问题】！" class="headerlink" title="Python中队列的一些操作【数据存入、取出、取数据阻塞等问题】！"></a>Python中队列的一些操作【数据存入、取出、取数据阻塞等问题】！</h3>      <p>队列存入数据的优先级：队列中的数据是先进先出，从队尾进入，队首取出</p><p>操作队列的步骤：</p><p>第一步：<code>from queue import Queue</code>     导入队列模块</p><p>第二步：<code>q = Queue（）</code>     创建q这个队列</p><p>第三步：<code>q.put</code>（存入队列的数据）    向q这个队列存入数据</p><p>第四步：<code>q.get（）</code>   从q这个队列中取出存入的数据</p><p>第五步：<code>q.empty（）</code>  判断队列中数据是否为空，是返回True，不是返回False</p><p>队列取数据出现的问题：当利用 get 方法从队列中取数据时，队列数据为空，那么程序就会进入阻塞状态，有什么办法让程序不阻塞嘛？</p><p>解决办法：<br>1：<code>q.get（timeout=2</code>）   设置阻塞时间，当超过两秒钟还未从队列中取得数据，程序直接报错</p><p>2：<code>q.get（block=False）</code> 在队列取不到数据直接报错，block默认值为True，也就是取不到数据程序一直处于阻塞状态</p><p>3：<code>q.get_nowait（）</code>  利用get_nowait方法取数据，队列内没有数据直接报错！！</p><p>4:</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  <span class="keyword">not</span> q.empty( ):     </span><br><span class="line">q.get( ) </span><br></pre></td></tr></table></div></figure><p>判断队列内是否有数据，有数据才取，没数据不取</p>        <h3 id="多线程对全局变量加线程锁的目的以及加锁步骤"   >          <a href="#多线程对全局变量加线程锁的目的以及加锁步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程对全局变量加线程锁的目的以及加锁步骤" class="headerlink" title="多线程对全局变量加线程锁的目的以及加锁步骤"></a>多线程对全局变量加线程锁的目的以及加锁步骤</h3>      <p>加线程锁目的：多个线程共享（共同操作）一个全局变量时（全局文件变量、全局变量、全局队列变量），可能会产生资源竞争问题，这时就要对全局变量进行加线程锁，等一个线程对全局变量操作完全结束后，在进行线程锁的释放！，可避免多线程间资源的竞争</p><p>加线程锁步骤：</p><p>第一步： <code>from threading import Lock</code>  导入线程锁模块</p><p>第二步：<code>l_obj = Lock（）</code> 创建一个线程锁</p><p>第三步：<code>l_obj.acquire( )</code>     某一个线程在对全局变量操作之前进行加锁 </p><p>第四步：<code>l_obj.release（） </code> 某一个线程在对全局变量操作完全结束后进行开锁 </p><p>注意事项：对某个全局变量上线程锁，在线程锁未开锁之前，又给这个全局变量上了一把锁，这是程序会进入阻塞状态</p><p>图示：</p><p>不加线程锁造成的多线程间资源竞争问题</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111448726.png"  alt="image-20211013111448726">      </p><p>加线程锁解决多线程之间的资源竞争’</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111459472.png"  alt="image-20211013111459472">      </p><p>多线程爬虫共同操作全局变量【同一个资源】（文件变量、队列变量等）的注意事项：只要是线程对全局变量（同一个资源）进行了操作都要加上一把线程锁！！！</p><p>注意事项：全局变量（全局队列等）有几个，那么就要创建几把线程锁</p>        <h2 id="单级页面的多线程爬虫框架【重中之重】"   >          <a href="#单级页面的多线程爬虫框架【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#单级页面的多线程爬虫框架【重中之重】" class="headerlink" title="单级页面的多线程爬虫框架【重中之重】"></a>单级页面的多线程爬虫框架【重中之重】</h2>      <p>目标：掌握单级页面的多线程爬虫框架（各种函数）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%8D%95%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB.png" >      </p>        <h2 id="多级页面的多线程爬虫框架【重中之重】"   >          <a href="#多级页面的多线程爬虫框架【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#多级页面的多线程爬虫框架【重中之重】" class="headerlink" title="多级页面的多线程爬虫框架【重中之重】"></a>多级页面的多线程爬虫框架【重中之重】</h2>      <p>目标：掌握多级页面的多线程爬虫框架</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB.png" >      </p>        <h2 id="Cookie模拟登陆【重点】"   >          <a href="#Cookie模拟登陆【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cookie模拟登陆【重点】" class="headerlink" title="Cookie模拟登陆【重点】"></a>Cookie模拟登陆【重点】</h2>      <p>目标：<br>1：掌握Cookie是什么并且有什么用<br>2：掌握怎么用 Python程序实现Cookie模拟登陆（好几种方法）</p>        <h3 id="Cookie是什么并且有什么用"   >          <a href="#Cookie是什么并且有什么用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cookie是什么并且有什么用" class="headerlink" title="Cookie是什么并且有什么用"></a>Cookie是什么并且有什么用</h3>      <p>Cookie适用场景：抓取需要登录才能获取数据的网站</p><p>答：当客户端向需要登录的网站服务器发送请求时，当登录成功后，服务器会给浏览器分发一段不超过4k大小的Cookie文本（浏览器将Cookie保存起来），服务器自身保存一段session文本，浏览器保存的Cookie相当于一个身份证，当你在向这个网站的其他页面发送请求时，会携带保存的Cookie，服务器会将浏览器发送请求时携带的Cookie与自身的session进行比对，比对成功后，放行（可以访问这个网站的其他页面），比对失败不放行（需要重新登录！）</p>        <h3 id="怎么用-Python程序实现Cookie模拟登陆（好几种方法）"   >          <a href="#怎么用-Python程序实现Cookie模拟登陆（好几种方法）" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么用-Python程序实现Cookie模拟登陆（好几种方法）" class="headerlink" title="怎么用 Python程序实现Cookie模拟登陆（好几种方法）"></a>怎么用 Python程序实现Cookie模拟登陆（好几种方法）</h3>      <p>第一种方法：暴力模拟登录——手动查找 Cookie，将 Cookie 充当请求标头内 headers 的一个参数</p><p>第一步：浏览器打开需要登录的网站，先登录一次</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111559051.png"  alt="image-20211013111559051">      </p><p>第二步：登录成功后进入到待抓取数据的页面</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111605707.png"  alt="image-20211013111605707">      </p><p>第三步：按下F12找到网络选项，刷新页面，找到所有包里面的第一个包（一般是第一个包，主要是看这个包请求的url与目标url是否相同）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111613690.png"  alt="image-20211013111613690">      </p><p>第四步：找到这个包里面请求信息（请求标头）的Cookie，复制</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111620460.png"  alt="image-20211013111620460">      </p><p>第五步：打开 pycharm 写程序发送请求</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111627910.png"  alt="image-20211013111627910">      </p><p>模拟Cookie登录的第二种方法——Cookies参数方式</p><p>方法：将手动抓取登录后的 Cookie 作为 requests 模块发送get请求的 cookies 参数传入</p><p>参数类型：字典     需要将抓取的cookie字符串处理为字典才能传参</p><p>语法：<code>requests.get（url=url，headers=headers，cookies=cookies）</code>    其中 cookies 就是处理好的 cookie字典</p><p>注意事项：手动抓取登录后的cookie和第一种方法抓取的一样！</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111641474.png"  alt="image-20211013111641474">      </p><p>将cookie字符串处理为cookies参数</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013111650257.png"  alt="image-20211013111650257">      </p><p>第三种方法：requests模块的session类实现Cookie模拟登录</p><p>语法：</p><p><code>s = requests.session（）创建session对象</code></p><p><code>s.post(url = url,headers = headers,data = data)</code>   向登录网站的接口发送请求（get或者是post请求具体分析），进行登录网站</p><p><code>html = s.get(url = url,headers = headers).text</code>   </p><p>上一步成功实现后，s 对象就是已经携带了登录成功的Cookie并保持会话，我们这是就可以向登录成功的任何页面发送请求获取数据了</p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：怎么爬取动态加载的页面及其Cookie模拟登录等等…..&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/tags/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>爬虫基础——requests模块与xpath语法</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94requests%E6%A8%A1%E5%9D%97%E4%B8%8Expath%E8%AF%AD%E6%B3%95/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94requests%E6%A8%A1%E5%9D%97%E4%B8%8Expath%E8%AF%AD%E6%B3%95/</id>
    <published>2021-10-13T01:56:17.000Z</published>
    <updated>2021-10-13T03:01:53.282Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：爬虫请求库requests的使用与xpath语法解析数据、User-agent随机生成库、代理IP、搭建代理IP池、关于js加密那些事等等…..</p><span id="more"></span>        <h2 id="requests模块的使用【重点】"   >          <a href="#requests模块的使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests模块的使用【重点】" class="headerlink" title="requests模块的使用【重点】"></a>requests模块的使用【重点】</h2>      <p>须知：一个网页右键检查（F12）所看到的代码是浏览器最终渲染完成的代码，它和网站服务器给你相应的源代码不一定相同，抓取数据的时候一定要以源代码为主，检查可以帮助你快速查找数据！！！</p><p>目标：</p><p>1：掌握 requests 模块的基本使用（获取url响应数据）</p><p>2：掌握 requests 模块响应对象一些基本属性</p><p>3：掌握 requests 模块响应对象的 json（）方法作用</p><p>​<br>​    </p>        <h3 id="requests-模块的基本使用（获取url响应数据）"   >          <a href="#requests-模块的基本使用（获取url响应数据）" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests-模块的基本使用（获取url响应数据）" class="headerlink" title="requests 模块的基本使用（获取url响应数据）"></a>requests 模块的基本使用（获取url响应数据）</h3>      <p>实现功能：向指定url发送请求（User-Agent经过包装）获取响应数据</p><p>语法：</p><p>1：res_obj = requests.get（url = url，headers = headers）          →向目标url发送get请求，返回响应对象</p><p>html_data = res_obj.text                                                           →利用响应对象的text属性获取响应源代码</p><p>2：html_data = requests.get（url = url，headers = headers，timeout=3）.text            → 向目标url发送get请求，获取响应源代码</p><p>参数：</p><p>1.url：请求的目标url</p><p>2.headers：包装的请求标头信息</p><p>3.timeout：设置请求时间，如果向指定网站发送请求，等待的响应时间超过3秒，则抛出异常（可捕获用！）</p><p>注意事项：</p><p>1：在 requests 模块内的响应对象没有方法，全都是属性，例如 text 属性</p><p>2：requests 模块是第三方模块安装语法 pip3 install requests</p><p>3：响应对象的text属性获取的是字符串响应数据</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211013105030475.png"  alt="image-20211013105030475">      </p><p>设置timeout参数抛出异常截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105037895.png"  alt="image-20211013105037895">      </p>        <h3 id="requests-模块响应对象一些基本属性"   >          <a href="#requests-模块响应对象一些基本属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests-模块响应对象一些基本属性" class="headerlink" title="requests 模块响应对象一些基本属性"></a>requests 模块响应对象一些基本属性</h3>      <p>res_obj = requests.get(url = url,headers = headers)          →创建指定url服务器的响应对象</p><p>下面是响应对象的一些常用属性</p><p>res_obj.text：获取指定url的响应源代码（字符串类型的）</p><p>res_obj.content：获取指定url的响应源代码（bytes类型的，也就是二进制的响应源代码）</p><p>res_obj.url：获取服务器响应数据的真实url地址</p><p>res_obj.status_code：获取客户端与服务端进行http通信的状态码</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105054440.png"  alt="image-20211013105054440">      </p>        <h3 id="requests-模块响应对象的-json（）方法作用"   >          <a href="#requests-模块响应对象的-json（）方法作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests-模块响应对象的-json（）方法作用" class="headerlink" title="requests 模块响应对象的 json（）方法作用"></a>requests 模块响应对象的 json（）方法作用</h3>      <p>方法名：json（）</p><p>语法：requests响应对象.json（）</p><p>功能：将 json 格式的字符串【字典格式的字符串】转换为python格式的字典！</p><p>代码演示</p><p>不使用json（）方法返回的数据类型</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105105938.png"  alt="image-20211013105105938">      </p><p>使用json（）方法返回的数据类型</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105112398.png"  alt="image-20211013105112398">      </p>        <h2 id="requests模块抓取图片、视频等【重点】"   >          <a href="#requests模块抓取图片、视频等【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests模块抓取图片、视频等【重点】" class="headerlink" title="requests模块抓取图片、视频等【重点】"></a>requests模块抓取图片、视频等【重点】</h2>      <p>须知：一个网页右键检查（F12）所看到的代码是浏览器最终渲染完成的代码，它和网站服务器给你相应的源代码不一定相同，抓取数据的时候一定要以源代码为主，检查可以帮助你快速查找数据！！！</p><p>目标：</p><p>1：掌握抓取网站图片、视频的一些注意事项</p><p>2：掌握怎么利用 os 标准库判断一个路径是否存在以及怎么创建文件夹！</p><p>2：掌握利用 requests 模块抓取网站图片的步骤</p><p>​    </p>        <h3 id="抓取网站图片、视频的一些注意事项"   >          <a href="#抓取网站图片、视频的一些注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#抓取网站图片、视频的一些注意事项" class="headerlink" title="抓取网站图片、视频的一些注意事项"></a>抓取网站图片、视频的一些注意事项</h3>      <p>图片、视频在计算机内的存储方式：图片、视频、音频均以二进制（bytes）数据的方式进行存储</p><p>图片、视频等的 url 地址：图片、视频等文件的源url地址不是浏览器最上方的地址，而是在图片上右击选择复制图片源地址的地址</p><p>抓取注意事项：</p><p>1：因此在向图片、视频等 url 源地址发送请求获取源代码数据时，应该获取二进制（bytes）网页源代码</p><p>2：获取到二进制网页源代码后，保存文件时，只要是图片、视频等，都要以二进制的方式打开指定文件！！</p><p>​            </p>        <h3 id="怎么利用-os-标准库判断一个路径是否存在以及怎么创建文件夹！"   >          <a href="#怎么利用-os-标准库判断一个路径是否存在以及怎么创建文件夹！" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么利用-os-标准库判断一个路径是否存在以及怎么创建文件夹！" class="headerlink" title="怎么利用 os 标准库判断一个路径是否存在以及怎么创建文件夹！"></a>怎么利用 os 标准库判断一个路径是否存在以及怎么创建文件夹！</h3>      <p>判断路径是否存在功能语法实现：</p><p>1.<code>import os</code>              →导入模块<br>2.<code>is_no = os.path.exists（指定路径文件夹或文件） </code>    →判断指定路径文件夹（文件）是否在计算机存在，是返回True，不在返回False</p><p>创建文件夹语法实现：</p><p>1.<code>import os</code>              →导入模块<br>2.<code>os.mkdir（文件夹名）</code>              →文件夹名可以是指定路径（绝对路径、相对路径）下的文件夹</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105138508.png"  alt="image-20211013105138508">      </p>        <h3 id="三：利用-requests-模块抓取网站图片的步骤"   >          <a href="#三：利用-requests-模块抓取网站图片的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#三：利用-requests-模块抓取网站图片的步骤" class="headerlink" title="三：利用 requests 模块抓取网站图片的步骤"></a>三：利用 requests 模块抓取网站图片的步骤</h3>      <p>第一步：找到图片的源地址（不是浏览器最上方的url）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105157588.png"  alt="image-20211013105157588">      </p><p>第二步：利用 requests 模块向图片源地址发送请求，获取二进制（bytes）类型的网页源代码</p><p>实现语法：</p><p>res_obj = requests.get(url=图片源地址，headers=包装的请求头)          →创建图片源地址响应对象<br>html_b_data = res_obj.content                                                     →利用对象的content获取网页二进制源代码</p><p>第三步：利用 os 模块判断图片待保存的路径（文件夹）是否存在，不存在创建这个路径文件夹</p><p>实现语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  os.path.exists（图片待保存文件夹路径）：</span><br><span class="line"><span class="built_in">print</span>（“路径存在”）</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line"><span class="built_in">print</span>（“路径不存在即将创建”）</span><br><span class="line">os.mkdir（图片待保存的文件夹路径）</span><br></pre></td></tr></table></div></figure><p>第四步：根据自己的想法创建图片待保存的文件名，并且拼接图片待保存路径以及文件名</p><p>创建图片名实现语法：</p><p>1.根据图片源地址创建图片保存名称（源地址后缀必须是.jpg或者.png等）：  图片源地址字符串 [ -10 : ]                  →获取图片源地址的最后10个字符串作为文件名</p><p>2：根据抓取的图片标题创建图片保存名称</p><p>3：单纯的遍历某个数字区间命名</p><p>拼接图片待保存路径以及文件名语法：带保存路径 + 图片带保存名</p><p>第五步：以二进制读写方法打开已经拼接好的的路径文件（不是路径文件夹）</p><p>实现语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> （拼装好的路径文件，“wb”）<span class="keyword">as</span> f ：</span><br><span class="line">f.wither（向图片源地址请求的二进制源代码）</span><br></pre></td></tr></table></div></figure><p>实现代码截图（部分）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105224121.png"  alt="image-20211013105224121">      </p>        <h2 id="User-Agent库随机生成用户代理【重点】"   >          <a href="#User-Agent库随机生成用户代理【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#User-Agent库随机生成用户代理【重点】" class="headerlink" title="User-Agent库随机生成用户代理【重点】"></a>User-Agent库随机生成用户代理【重点】</h2>      <p>目标：掌握怎么用 Python 库 fake_useragent（非标准库） 生成随机的用户代理</p>        <h3 id="Python-库-fake-useragent（非标准库）生成随机的用户代理"   >          <a href="#Python-库-fake-useragent（非标准库）生成随机的用户代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Python-库-fake-useragent（非标准库）生成随机的用户代理" class="headerlink" title="Python 库 fake_useragent（非标准库）生成随机的用户代理"></a>Python 库 fake_useragent（非标准库）生成随机的用户代理</h3>      <p>安装：<code>pip3 install fake_useragent</code></p><p>功能：随机生成用户代理（User-Agent）</p><p>语法：<br>导入模块：<code>from fake_useragent import UserAgent</code><br>生成随机代理：<code>UserAgent（）.random</code></p><p>爬虫用法：</p><p>导入模块：<code>from fake_useragent import UserAgent</code></p><p>生成随机代理：<code>headers = &#123;“User-Agent”：UserAgent（）.random&#125;</code></p><p>注意事项：生成随机用户代理时，利用的是UserAgent方法，不是random方法，random只是属性！！！</p><p>截图演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105241914.png"  alt="image-20211013105241914">      </p>        <h2 id="安装爬虫相关的浏览器插件【重点】"   >          <a href="#安装爬虫相关的浏览器插件【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装爬虫相关的浏览器插件【重点】" class="headerlink" title="安装爬虫相关的浏览器插件【重点】"></a>安装爬虫相关的浏览器插件【重点】</h2>      <p>目标：<br>1：掌握安装插件的两种方式<br>2：掌握与爬虫相关的插件都有哪些以及其功能</p>        <h3 id="的两种方式"   >          <a href="#的两种方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#的两种方式" class="headerlink" title="的两种方式"></a>的两种方式</h3>      <p>第一种方式：直接在浏览器对应的扩展商店里面搜索安装即可</p><p>第二种方式：如果浏览器里面的扩展商店没有目标插件，可去第三方插件网站将插件下载至计算机内，在进行离线安装<br>推荐第三方插件网：极简插件_Chrome扩展插件商店_优质crx应用 (zzzmh.cn)</p>        <h3 id="关的插件都有哪些以及其功能"   >          <a href="#关的插件都有哪些以及其功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#关的插件都有哪些以及其功能" class="headerlink" title="关的插件都有哪些以及其功能"></a>关的插件都有哪些以及其功能</h3>      <p>插件1：xpath helper    （解析网页源代码中的html（xml）代码，提取相应数据）</p><p>插件2：JSONView         （解析网页源代码中的json文档）</p><p>插件3：Proxy SwitchyOmega  （轻松切换代理）</p><p>插件截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105329439.png"  alt="image-20211013105329439">      </p>        <h2 id="xpath语法详解【重点】"   >          <a href="#xpath语法详解【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#xpath语法详解【重点】" class="headerlink" title="xpath语法详解【重点】"></a>xpath语法详解【重点】</h2>      <p>目标：<br>1：掌握什么是 xpath<br>2：掌握 xpath 匹配数据的几种语法格式<br>3：使用 xpath 的一些注意事项</p>        <h3 id="xpath"   >          <a href="#xpath" class="heading-link"><i class="fas fa-link"></i></a><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3>      <p>答：xpath 是在 xml 文档中匹配数据的一种查询语言（俗称xml路径语言），因为 xml 文档与 html 文档结构非常类似，所以 xpath 也可以用在匹配 html 文档数据中（爬虫提取数据）</p>        <h3 id="xpath匹配数据的几种语法格式"   >          <a href="#xpath匹配数据的几种语法格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#xpath匹配数据的几种语法格式" class="headerlink" title="xpath匹配数据的几种语法格式"></a>xpath匹配数据的几种语法格式</h3>      <p><code>/div</code>匹配文档中所有的 div 标签，返回匹配的内容对象</p><p><code>/div/p</code>匹配文档中所有的div标签下的一级 p 标签，返回 p 标签下（包括p标签子标签）的所有的文本内容对象（是文本结点对象，不是字符串类型的文本）</p><p><code>/div//p</code>匹配文档中所有 div 标签下的所有级别 p 标签（包含在div标签内其他标签下p标签），返回 p 标签下（包括p标签内子标签）的所有的文本内容对象（是文本结点对象，不是字符串类型的文本）</p><p><code>/div/p[1]</code>匹配文档中所有div标签内的第一个 p 标签，返回这个 p 标签下的所有文本内容对象</p><p><code>/div[@class=&quot;name&quot;]</code>匹配文档中属性包含 class=”name”的所有div标签，返回这个div标签下的所有文本内容对象</p><p><code>/div/p@src</code>匹配文档内所有div标签下的p标签，获取p标签中src属性的值（是字符串类型不是文本对象类型）</p><p><code>/div[@class=&quot;byd&quot;] | //div[@class=&quot;bm&quot;]</code>匹配文档内class属性为“byd”或者“bm”的所有div标签，返回下面所有标签的文本内容对象（不是字符串类型）</p><p><code>/li[ contains(@class,&quot;car_&quot;)]</code>匹配class属性中包含“car_”内容的所有 li 标签，返回下面所有标签的文本内容对象（不是字符串类型）</p><p><code>/li[@class=&quot;name&quot;]/text（）</code>匹配 class 属性值为“name’”的所有 li 标签，并且返回 li 标签中（不包括li子标签）的文本内容（字符串类型）</p><p>整体图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105409947.png"  alt="image-20211013105409947">      </p>        <h3 id="path-的一些注意事项"   >          <a href="#path-的一些注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#path-的一些注意事项" class="headerlink" title="path 的一些注意事项"></a>path 的一些注意事项</h3>      <p>最重要一条：xpath语法的开头查找标签必须要加两条//，一条/不能成功匹配</p><p>1.xpath语法中只要与条件有关，就要在条件两侧加上 [ ]</p><p>2.xpath语法内只要与标签属性有关，就要在属性前面加上@</p><p>3.xpath语法中末尾是 /text（）或者 /@属性值，那么获取的值就是字符串类型的文本内容，除此之外获取的全部都是文本内容对象（不是字符串）</p><p>4.xpath语法是 //div/p/text（），只匹配所有div标签下p标签中的文本内容（字符串），不能匹配p标签下其他子标签的文本内容！！！</p><p>5.xpath语法是 //div/p，匹配所有div标签下p标签中（包含p标签下的其他子标签）的文本内容对象（不是字符串）</p><p>6.html一段文档是 &lt;p class=”name”, id=6&gt; 姓名 </p>，其中class与id都是属性，匹配的文本内容是姓名，不是其他的！</p>        <h2 id="lxml库搭配xpath语法实现数据提取【重点】"   >          <a href="#lxml库搭配xpath语法实现数据提取【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#lxml库搭配xpath语法实现数据提取【重点】" class="headerlink" title="lxml库搭配xpath语法实现数据提取【重点】"></a>lxml库搭配xpath语法实现数据提取【重点】</h2>      <p>目标：<br>1：掌握 python 的第三方库 lxml 搭配 xpath 语法在 html 文档内提取数据的使用方法！<br>2：掌握 for 循环的另外一种用法以及怎么将列表内元素拼接为一个字符串</p>        <h3 id="on-的第三方库-lxml-搭配-xpath-语法在-html-文档内提取数据的使用方法！"   >          <a href="#on-的第三方库-lxml-搭配-xpath-语法在-html-文档内提取数据的使用方法！" class="heading-link"><i class="fas fa-link"></i></a><a href="#on-的第三方库-lxml-搭配-xpath-语法在-html-文档内提取数据的使用方法！" class="headerlink" title="on 的第三方库 lxml 搭配 xpath 语法在 html 文档内提取数据的使用方法！"></a>on 的第三方库 lxml 搭配 xpath 语法在 html 文档内提取数据的使用方法！</h3>      <p>lxml库功能：与 xpath 语法搭配使用从而在 html 或者 xml 文档中提取出自己想要的数据</p><p>lxml库安装（unubtu）：pip3 install lxml</p><p>lxml库在html文档代码内提取数据使用步骤：</p><p>from lxml import etree                                                导入模块<br>lxml_obj = etree.HTML( 网页的html源代码 )               创建 lxml 对象用于提取数据</p><p>data_list = lxml_obj.xpath（xpath语法）              利用 xpath 语法从网页的html源代码中提取数据</p><p>lxml库搭配xpath语法在html文档中提取数据（电影、汽车等）最常用法如下：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree                                                导入模块</span><br><span class="line">lxml_obj = etree.HTML( 网页的html源代码 )               创建 lxml 对象用于提取数据</span><br><span class="line">lable_obj_list = lxml_obj.xpath（xpath语法）           利用 xpath 语法从网页的 html 源代码中 提取 数据存在的 标签结点对象</span><br><span class="line"><span class="keyword">for</span>  lable <span class="keyword">in</span> data_list:                                          <span class="keyword">for</span>循环遍历这个标签结点对象</span><br><span class="line">data_list = lable.xpath(xpath语法)           调用这个标签结点对象的xpath方法，在当前路径下匹配数据</span><br><span class="line"><span class="built_in">print</span>(data_list)                                     打印数据</span><br></pre></td></tr></table></div></figure><p>注意事项：</p><p>1：只要 lxml 对象调用了 xpath 方法，那么获取的数据类型一定是列表！！！！</p><p>2：在 html 文档中提取数据最常用法中通过 for 循环遍历数据结点对象里面那个xpath语法（第二个xpath）开头要以 . 开头，表示在当前标签结点下查找标签数据！</p><p>代码体验（提取数据使用步骤）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105447337.png"  alt="image-20211013105447337">      </p><p>最常用法截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105454198.png"  alt="image-20211013105454198">      </p>        <h2 id="requests模块的高级参数【重点】"   >          <a href="#requests模块的高级参数【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests模块的高级参数【重点】" class="headerlink" title="requests模块的高级参数【重点】"></a>requests模块的高级参数【重点】</h2>      <p>目标：<br>1：掌握 requests 模块 params 参数的功能<br>2：掌握 http与https有什么不同<br>3掌握 requests 模块 verify 参数的功能</p>        <h3 id="requests-模块-params-参数的功能"   >          <a href="#requests-模块-params-参数的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests-模块-params-参数的功能" class="headerlink" title="requests 模块 params 参数的功能"></a>requests 模块 params 参数的功能</h3>      <p>参数名：params</p><p>参数类型：字典</p><p>功能：对目标 url 的查询参数（中文或英文）进行编码然后拼接整体 url</p><p>语法：requests对象.get（url=基准url，headers=headers，params={“查询参数名1”：“查询参数值1”，查询参数名2”：“查询参数值2”}）</p><p>注意事项：利用 requests 库加上 params 参数向目标url发送请求时，url是基准url，也就是不包含查询参数的url，但是要包含最后的 ？</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105520303.png"  alt="image-20211013105520303">      </p>        <h3 id="http与https有什么不同以及http怎么变为https"   >          <a href="#http与https有什么不同以及http怎么变为https" class="heading-link"><i class="fas fa-link"></i></a><a href="#http与https有什么不同以及http怎么变为https" class="headerlink" title="http与https有什么不同以及http怎么变为https"></a>http与https有什么不同以及http怎么变为https</h3>      <p>第一：http端口号是80，https端口号是443</p><p>第二：https就是在http基础加上了安全套接层（ssl），就是客户端向https协议的网站服务器发送请求，请求报文会被加密，目标url服务器响应的报文也就进行加密</p><p>http怎么升级为https：http协议网站向第三方数字证书认证机构进行ssl认证即可，注意必须是要经过第三方数字证书认证机构认证，个人做的ssl证书，浏览器是不信任的！</p>        <h3 id="requests-模块-verify-参数的功能"   >          <a href="#requests-模块-verify-参数的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests-模块-verify-参数的功能" class="headerlink" title="requests 模块 verify 参数的功能"></a>requests 模块 verify 参数的功能</h3>      <p>参数名称：verify</p><p>参数类型：bool 类型（ True【默认】 |  False ）</p><p>功能：是否对目标 url （https协议的）进行 ssl 检查，默认检查，如果目标 https协议的url 没有经过第三方数字证书认证机构认证，会抛出 SSLError错误</p><p>适用场景：向未经过第三方数字证书认证机构的https网站发送请求时，如果出现SSLError异常，可将verify参数值设置为False</p><p>语法：requests对象.get（url=基准url，headers=headers，verify=False）</p>        <h2 id="代理IP的使用【重点】"   >          <a href="#代理IP的使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#代理IP的使用【重点】" class="headerlink" title="代理IP的使用【重点】"></a>代理IP的使用【重点】</h2>      <p>目标：<br>1：掌握为什么要用代理IP访问web服务器<br>2：掌握本机IP与出口IP的区别<br>3：掌握代理IP分类以及代理IP的网站<br>4：掌握利用requests库如何实现代理IP请求web服务器</p>        <h3 id="为什么要用代理IP访问web服务器"   >          <a href="#为什么要用代理IP访问web服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要用代理IP访问web服务器" class="headerlink" title="为什么要用代理IP访问web服务器"></a>为什么要用代理IP访问web服务器</h3>      <p>答：如果利用自身IP频率过高的访问web服务器，网站一般都有反爬措施，会将自身的IP（出口IP）封掉，这是我们就提现出代理IP的重要性了</p><p>利用代理IP访问web服务器图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105558759.png"  alt="image-20211013105558759">      </p>        <h3 id="本机IP与出口IP的区别"   >          <a href="#本机IP与出口IP的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#本机IP与出口IP的区别" class="headerlink" title="本机IP与出口IP的区别"></a>本机IP与出口IP的区别</h3>      <p>本机IP：局域网内的IP地址，只能在局域网中使用（内网IP），在windows终端内通过 ipconfig 指令查看的 IP 即本机IP，需要上网的话会通过NET出口，分配出口IP进行上网</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105617724.png"  alt="image-20211013105617724">      </p><p>出口IP：外网IP，是你的计算机真正的IP地址（可以显示IP的具体地理位置）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105647739.png"  alt="image-20211013105647739">      </p>        <h3 id="代理IP分类以及代理IP的网站"   >          <a href="#代理IP分类以及代理IP的网站" class="heading-link"><i class="fas fa-link"></i></a><a href="#代理IP分类以及代理IP的网站" class="headerlink" title="代理IP分类以及代理IP的网站"></a>代理IP分类以及代理IP的网站</h3>      <p>高匿代理IP：通过高匿代理IP访问网站服务器，服务器不知道这是用户通过代理IP访问的（知道代理IP地址），不知道真实用户的IP</p><p>普通代理IP：通过普通代理IP访问网站服务器，服务器知道这是用户通过这个代理IP进行访问的（知道代理IP地址），但是不知道用户的真实IP</p><p>透明代理IP：通过透明代理IP访问网站服务器，服务器知道代理IP地址以及用户的真实IP地址</p><p>常用的免费代理IP网站：</p><p>快代理：快代理 - 企业级代理云服务提供商 (kuaidaili.com)</p><p>66代理：免费代理ip_服务器http代理_最新ip代理_免费ip提取网站_国内外代理_66免费代理ip (66ip.cn)</p><p>​                </p>        <h3 id="利用requests库如何实现代理IP请求web服务器"   >          <a href="#利用requests库如何实现代理IP请求web服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用requests库如何实现代理IP请求web服务器" class="headerlink" title="利用requests库如何实现代理IP请求web服务器"></a>利用requests库如何实现代理IP请求web服务器</h3>      <p>实现参数：proxies</p><p>参数类型：字典     </p><p>参数设置：</p><p>设置基本代理IP                           →  proxies =   {“协议类型”，“协议类型：//代理IP地址：代理IP端口号”}</p><p>设置专享 | 私密 代理IP                →  proxies = {“协议类型”，“协议类型：//用户名：密码@代理IP地址：代理IP端口号”}</p><p>实例（基本代理IP）：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;“http”：“http：//<span class="number">123.51</span><span class="number">.56</span><span class="number">.124</span>：<span class="number">8695</span>”，</span><br><span class="line">      “https”：“https：//<span class="number">123.51</span><span class="number">.56</span><span class="number">.124</span>：<span class="number">8695</span>”&#125;</span><br></pre></td></tr></table></div></figure><p>实例（独享 | 私密 代理IP）：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;“http”：“http：//xxx：……@<span class="number">256.36</span><span class="number">.125</span><span class="number">.35</span>：<span class="number">8695</span>”，</span><br><span class="line">     “https”：“https：//xxx：……@<span class="number">256.36</span><span class="number">.125</span><span class="number">.35</span>：<span class="number">8695</span>”&#125;</span><br></pre></td></tr></table></div></figure><p>实现语法：</p><p><code>html_data = requests.get(url=url , headers=headers ,  params=params , proxies=proxies )</code></p><p>注意事项：</p><p>1：为什么设置代理IP时要设置两个协议的（http|https），当访问网站类型为http时，就用http协议的代理IP进行访问！</p><p>2：私密代理以及独享代理或者基本代理都是可以花钱买的，私密代理以及独享代理使用时需要验证用户名和密码！</p><p>3：爬虫最常用的是私密代理！！</p><p>代码演示：</p><p>没设置代理IP</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105737207.png"  alt="image-20211013105737207">      </p><p>设置了代理IP</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105743874.png"  alt="image-20211013105743874">      </p>        <h2 id="搭建IP代理池【重点】"   >          <a href="#搭建IP代理池【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#搭建IP代理池【重点】" class="headerlink" title="搭建IP代理池【重点】"></a>搭建IP代理池【重点】</h2>      <p>注意：再利用xpath语法提取数据时，右键检查发现数据所在的标签在 tbody下面这时就要小心了，因为很有可能网页源代码内没有这个tbody标签！！</p><p>目标：掌握搭建代理IP池的步骤（免费代理ip网站）</p>        <h3 id="搭建代理IP池的步骤"   >          <a href="#搭建代理IP池的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#搭建代理IP池的步骤" class="headerlink" title="搭建代理IP池的步骤"></a>搭建代理IP池的步骤</h3>      <p>第一步：从免费代理IP网站提取出代理IP以及端口号（xpath提取目标ip以及端口号）</p><p>第二步：通过代理ip向测试网站发送请求（设置timeout）如果超过timeout设置的时间则认为当前代理IP不可用！</p><p>第三步：将可用的代理IP以及端口号保存到列表内或者txt文件内！</p><p>代码截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105800933.png"  alt="image-20211013105800933">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105809267.png"  alt="image-20211013105809267">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105819657.png"  alt="image-20211013105819657">      </p>        <h2 id="requests的post请求【重中之重】"   >          <a href="#requests的post请求【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#requests的post请求【重中之重】" class="headerlink" title="requests的post请求【重中之重】"></a>requests的post请求【重中之重】</h2>      <p>目标：<br>1：掌握控制台抓包的具体步骤以及参数功能</p><p>2：掌握什么是post请求</p><p>3：掌握利用requests模块向目标url发送post请求的语法</p><p>4：掌握利用pycharm正则批量处理字符串的步骤</p><p>​    </p>        <h3 id="控制台抓包的具体步骤以及参数功能"   >          <a href="#控制台抓包的具体步骤以及参数功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#控制台抓包的具体步骤以及参数功能" class="headerlink" title="控制台抓包的具体步骤以及参数功能"></a>控制台抓包的具体步骤以及参数功能</h3>      <p>第一步：打开网站按下F12打开控制台</p><p>第二步：刷新网站，对网站进行一些操作后进行二次刷新（动态显示的网站无需二次刷新，数据包已经加载，比如有道翻译网站）</p><p>第三步：根据一些规则（响应数据）找到自己需要的数据包</p><p>第四步：分析请求的目标URL以及请求方式</p><p>注意事项：</p><p>1：如果待抓取的数据在网页源代码内没有，基本都是异步（动态）加载的，我们可以考虑抓取XHR的包</p><p>2：多多利用好数据包信息栏里面的Preview选项（对服务器响应数据的预览），可以根据这个快速找到我们待抓取的包</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105858633.png"  alt="image-20211013105858633">      </p>        <h3 id="什么是post请求"   >          <a href="#什么是post请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是post请求" class="headerlink" title="什么是post请求"></a>什么是post请求</h3>      <p>答：post请求就是客户端带着Form data 表单数据（字典）向服务器发送的请求</p>        <h3 id="利用requests模块向目标url发送post请求的语法"   >          <a href="#利用requests模块向目标url发送post请求的语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用requests模块向目标url发送post请求的语法" class="headerlink" title="利用requests模块向目标url发送post请求的语法"></a>利用requests模块向目标url发送post请求的语法</h3>      <p>语法：requests.post（url=…….，headers={}，data={}）.text</p><p>重要参数：data          data 参数就是客户端需要带着的Form data 表单数据</p><p>参数类型：字典</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105908065.png"  alt="image-20211013105908065">      </p>        <h3 id="利用pycharm正则批量处理字符串的步骤（一般是将字符串变为字典形式）"   >          <a href="#利用pycharm正则批量处理字符串的步骤（一般是将字符串变为字典形式）" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用pycharm正则批量处理字符串的步骤（一般是将字符串变为字典形式）" class="headerlink" title="利用pycharm正则批量处理字符串的步骤（一般是将字符串变为字典形式）"></a>利用pycharm正则批量处理字符串的步骤（一般是将字符串变为字典形式）</h3>      <p>第一步：在pycharm内新建txt文件</p><p>第二步：将待批量处理的字符串复制进来</p><p>第三步：按下快捷键 Ctrl + r</p><p>第四步：利用 pycharm 自己的正则对字符串进行批量处理</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013105922519.png"  alt="image-20211013105922519">      </p>        <h2 id="关于js加密【重中之重】"   >          <a href="#关于js加密【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于js加密【重中之重】" class="headerlink" title="关于js加密【重中之重】"></a>关于js加密【重中之重】</h2>      <p>目标：<br>1：掌握 分析 js 加密的过程（打断点、控制台等）<br>2：掌握抓取有道翻译的注意事项</p>        <h3 id="分析-js-加密的过程（打断点、控制台等）"   >          <a href="#分析-js-加密的过程（打断点、控制台等）" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析-js-加密的过程（打断点、控制台等）" class="headerlink" title="分析 js 加密的过程（打断点、控制台等）"></a>分析 js 加密的过程（打断点、控制台等）</h3>      <p>分析背景：</p><p>答：在发送post请求时，要带着Form_data表单数据向目标服务器发送请求，因为网站反爬的原因，有的Form_data表单数据是经过js加密的，因此就要分析js加密的原理从而进行破解利用python实现</p><p>分析js加密过程示例：</p><p>第一步：查看post请求中哪几个表单数据是经过 js 加密的</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110011885.png"  alt="image-20211013110011885">      </p><p>第二步：在全部包中搜索表单数据的变量名（salt、sign、lts）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110021162.png"  alt="image-20211013110021162">      </p><p>第三步：将一行代码进行格式化（多行代码）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110030164.png"  alt="image-20211013110030164">      </p><p>第四步：在包含表单数据变量名的代码中搜索表单变量名，分析js加密原理</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110038526.png"  alt="image-20211013110038526">      </p><p>第五步：分析经过js加密后的表单数据变量（打断点、控制台）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110047499.png"  alt="image-20211013110047499">      </p><p>控制台输出代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110054831.png"  alt="image-20211013110054831">      </p><p>对程序打断点</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110103415.png"  alt="image-20211013110103415">      </p><p>分析完成利用python实现这个几个字段的加密然后向目标url发送post请求即可</p>        <h3 id="二：抓取有道翻译的注意事项"   >          <a href="#二：抓取有道翻译的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#二：抓取有道翻译的注意事项" class="headerlink" title="二：抓取有道翻译的注意事项"></a>二：抓取有道翻译的注意事项</h3>      <p>因为有道翻译反爬严重，请求标头要道带上所有的请求标头去发送请求</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110114786.png"  alt="image-20211013110114786">      </p>        <h2 id="爬取民政部行政区号遇到的反爬【目标】"   >          <a href="#爬取民政部行政区号遇到的反爬【目标】" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬取民政部行政区号遇到的反爬【目标】" class="headerlink" title="爬取民政部行政区号遇到的反爬【目标】"></a>爬取民政部行政区号遇到的反爬【目标】</h2>      <p>重点：掌握在爬取民政部行政区号遇到的反爬怎么解决</p>        <h3 id="爬取民政部行政区号遇到了怎样的反爬"   >          <a href="#爬取民政部行政区号遇到了怎样的反爬" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬取民政部行政区号遇到了怎样的反爬" class="headerlink" title="爬取民政部行政区号遇到了怎样的反爬"></a>爬取民政部行政区号遇到了怎样的反爬</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110131351.png"  alt="image-20211013110131351">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110139384.png"  alt="image-20211013110139384">      </p><p>检查发现还他娘真有这段js跳转脚本代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013110149295.png"  alt="image-20211013110149295">      </p><p>未完待续…….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：爬虫请求库requests的使用与xpath语法解析数据、User-agent随机生成库、代理IP、搭建代理IP池、关于js加密那些事等等…..&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/tags/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>数据存储——Mysql与redis存储</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94Mysql%E4%B8%8Eredis%E5%AD%98%E5%82%A8/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94Mysql%E4%B8%8Eredis%E5%AD%98%E5%82%A8/</id>
    <published>2021-10-13T01:45:01.000Z</published>
    <updated>2021-10-13T01:54:36.730Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：如何将爬取下来的数据存储到Mysql数据库内及其redis数据库内…..</p><span id="more"></span>        <h2 id="MySQL实现增量式爬虫（md5加密）【重点】"   >          <a href="#MySQL实现增量式爬虫（md5加密）【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL实现增量式爬虫（md5加密）【重点】" class="headerlink" title="MySQL实现增量式爬虫（md5加密）【重点】"></a>MySQL实现增量式爬虫（md5加密）【重点】</h2>              <h3 id="python-怎么对-url-字符串进行-MD5-加密"   >          <a href="#python-怎么对-url-字符串进行-MD5-加密" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-怎么对-url-字符串进行-MD5-加密" class="headerlink" title="python 怎么对 url 字符串进行 MD5 加密"></a>python 怎么对 url 字符串进行 MD5 加密</h3>      <p>什么是MD5加密：就是将一串字符重新加密为定长32的唯一字符串（常常用作 url 加密）</p><p>为什么要对 url 进行MD5加密：因为有的 url 长度太长在实现增量式爬虫时的mysql  url指纹库不好控制，所以进行MD5加密</p><p>实现语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5               →  导入md5模块（标准库模块）</span><br><span class="line">s = md5（）                                →  创建一个md5对象</span><br><span class="line">s.update( url.edcode（）)                 → 对 url 进行md5加密</span><br><span class="line">加密结果 = s.hexdigest（）       → 获取加密后的十六进制url字符串</span><br></pre></td></tr></table></div></figure><p>注意事项：一段字符经过md5加密之后结果是16进制字符串，那么相同的这段字符在经过md5加密，形成的16进制字符串是不变的</p><p>代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095105307.png"  alt="image-20211013095105307">      </p>        <h3 id="MySQL-增量式爬虫的实现逻辑"   >          <a href="#MySQL-增量式爬虫的实现逻辑" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL-增量式爬虫的实现逻辑" class="headerlink" title="MySQL 增量式爬虫的实现逻辑"></a>MySQL 增量式爬虫的实现逻辑</h3>      <p>增量式爬虫的背景：假设爬取新闻网站资源，今天把所有的新闻全部爬取下来了，第二天网站又更新了几条新闻，这时我们只需要爬取更新的新闻即可，这就是做增量式爬虫的目的</p><p>增量式实现逻辑：创建一个 mysql 网站指纹数据表，将爬取过的 url（看情况确定是一级url 还是二级url） 经过 md5 加密之后保存进数据表，以后在爬取数据时先将待爬取的 url 与指纹数据表里面的加密url进行比对，如果url已经存在指纹数据表内，那么就停止爬取，没有则继续爬取</p>        <h3 id="MySQL-增量式爬虫的具体实现思路"   >          <a href="#MySQL-增量式爬虫的具体实现思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL-增量式爬虫的具体实现思路" class="headerlink" title="MySQL 增量式爬虫的具体实现思路"></a>MySQL 增量式爬虫的具体实现思路</h3>      <p>第一步：创建 mysql 指纹数据表</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名 charset=utf8；</span><br><span class="line">create table 数据表名（ 字段名 char（<span class="number">32</span>） <span class="keyword">not</span> null ）charset=utf8；</span><br></pre></td></tr></table></div></figure><p>第二步：在向指定 url 服务器发送请求之前，先将url与mysql数据指纹库里面的url进行比对，没有一样的在发送请求</p><p>部分语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">游标对象.execute（select * <span class="keyword">from</span> 指纹数据表名）</span><br><span class="line">url_tuple = 游标对象.fetchall（）</span><br><span class="line"><span class="keyword">if</span>  url <span class="keyword">in</span> url_tuple：</span><br><span class="line">退出程序</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">继续爬取</span><br></pre></td></tr></table></div></figure><p>注意事项：url_tuple = 游标对象.fetchall（）  语法获取的数据是元组嵌套，但是没关系，不管是元组还是元组的嵌套 in 关键字都可以判断指定数据是否在里面！！</p><p>第三步：如果判断 url 不在 url数据指纹库内，则爬取数据完成后，将这个url经过md5加密后写入到数据指纹库里面！！</p>        <h2 id="MySQL增量式爬虫框架【重点】"   >          <a href="#MySQL增量式爬虫框架【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL增量式爬虫框架【重点】" class="headerlink" title="MySQL增量式爬虫框架【重点】"></a>MySQL增量式爬虫框架【重点】</h2>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/python%E4%BA%8C%E7%BA%A7%E7%88%AC%E8%99%AB%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%A1%86%E6%9E%B6%E3%80%90%E7%BE%94%E7%BE%8A%E6%80%BB%E7%BB%93%E3%80%91.png" >      </p>        <h2 id="redis数据库基本操作【重点】"   >          <a href="#redis数据库基本操作【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis数据库基本操作【重点】" class="headerlink" title="redis数据库基本操作【重点】"></a>redis数据库基本操作【重点】</h2>              <h3 id="什么是-redis-数据库"   >          <a href="#什么是-redis-数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是-redis-数据库" class="headerlink" title="什么是 redis 数据库"></a>什么是 redis 数据库</h3>      <p>类型：非关系型数据库</p><p>数据存储类型：字符串（键值对）、列表，集合（去重），zset（有序集合），哈希（2的32次方减1个键值对）</p><p>数据存储位置：内存</p><p>优点：读取大量数据速度快</p><p>注意事项：redis的字符串其最基本的数据类型也是二进制类型的，你可以理解为redis内的字符串数据可以是任何类型的数据，比如说图片、音频等，其中redis的字符串类型最大可存储512mb的数据</p>        <h3 id="怎么安装-redis-数据库"   >          <a href="#怎么安装-redis-数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么安装-redis-数据库" class="headerlink" title="怎么安装 redis 数据库"></a>怎么安装 redis 数据库</h3>      <p>ubuntu安装指令：<code>sudo apt-get install redis-server</code></p><p>ubuntu终端启动redis指令：<code>redis-server</code></p><p>终端查看是否启动redis指令（常用）：<code>redis-cli</code>      如果启动成功出现这串字符：redis 127.0.0.1:6379&gt;</p><p>进入redis数据库指令：在 redis 127.0.0.1:6379&gt; 基础上输入 <code>ping</code> 即可</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095217759.png"  alt="image-20211013095217759">      </p>        <h3 id="redis-数据库的五大数据类型"   >          <a href="#redis-数据库的五大数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis-数据库的五大数据类型" class="headerlink" title="redis 数据库的五大数据类型"></a>redis 数据库的五大数据类型</h3>      <p>1.字符串（键值对）：redis 最基础的数据类型，其中字符串是二进制的，可以理解为redis的字符串可以存储任何数据，图片、音频等，但是redis的字符串（值）最大可存储512mb大小的数据</p><p>插入数据：<code>SET 键名  值</code></p><p>获取数据：<code>GET 键名</code></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095228423.png"  alt="image-20211013095228423">      </p><p>2.hash（哈希）：哈希数据类型可以理解为键值对的集合，一个哈希最多可以存储232 -1 键值对（40多亿）</p><p>省略……..</p><p>3.列表：列表是redis最简单的数据类型，数据元素按照插入顺序排序（先插在后）</p><p>插入数据：<code>lpush 键名  值</code></p><p>获取数据：<code>lrange 键名 数据在列表开始下标 数据在列表结束下标</code></p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095241914.png"  alt="image-20211013095241914">      </p><p>4.集合：redis的集合是字符串无序集合，元素不能重复，通过哈希表实现，因此添加、查找、删除的复杂度都是O（1）</p><p>插入数据：<code>sadd 键名 数据</code></p><p>查询数据：<code>smembers 键名</code></p><p>注意：添加一个数据到集合键里面，如果这个数据在集合存在则不能插入返回0，不在插入成功返回1</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095257113.png"  alt="image-20211013095257113">      </p><p>zset（无序集合）：Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复</p><p>插入数据到集合内：<code>zadd key score member</code></p><p>省略……</p>        <h2 id="redis数据库的常用指令【重点】"   >          <a href="#redis数据库的常用指令【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis数据库的常用指令【重点】" class="headerlink" title="redis数据库的常用指令【重点】"></a>redis数据库的常用指令【重点】</h2>              <h3 id="怎么在redis数据库删除指定键"   >          <a href="#怎么在redis数据库删除指定键" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么在redis数据库删除指定键" class="headerlink" title="怎么在redis数据库删除指定键"></a>怎么在redis数据库删除指定键</h3>      <p>语法：<code>del 键名</code></p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095317287.png"  alt="image-20211013095317287">      </p><p>全部键指令截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095329179.png"  alt="image-20211013095329179">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095343346.png"  alt="image-20211013095343346">      </p>        <h3 id="redis-数据库一些关于字符串的操作"   >          <a href="#redis-数据库一些关于字符串的操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis-数据库一些关于字符串的操作" class="headerlink" title="redis 数据库一些关于字符串的操作"></a>redis 数据库一些关于字符串的操作</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095357083.png"  alt="image-20211013095357083">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095405396.png"  alt="image-20211013095405396">      </p>        <h2 id="redis数据库与python交互【重点】"   >          <a href="#redis数据库与python交互【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis数据库与python交互【重点】" class="headerlink" title="redis数据库与python交互【重点】"></a>redis数据库与python交互【重点】</h2>              <h3 id="怎么安装-redis-数据库与-python-交互的第三方库"   >          <a href="#怎么安装-redis-数据库与-python-交互的第三方库" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么安装-redis-数据库与-python-交互的第三方库" class="headerlink" title="怎么安装 redis 数据库与 python 交互的第三方库"></a>怎么安装 redis 数据库与 python 交互的第三方库</h3>      <p>安装指令：<code>pip3 install redis</code></p>        <h3 id="redis-数据库与-python-交互的步骤"   >          <a href="#redis-数据库与-python-交互的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis-数据库与-python-交互的步骤" class="headerlink" title="redis 数据库与 python 交互的步骤"></a>redis 数据库与 python 交互的步骤</h3>      <p>第一步：导入 redis 第三方数据库             →       <code> import redis</code> </p><p>第二步：创建 redis 连接数据库对象        →        <code>  red_obj = redis.Redis(host=主机，port=端口号，db=数据库号)</code><br>注意：redis默认有16个数据库，也就是数据库号可以是  0-15，一般选择0   redis的端口号是6379（整形）</p><p>第三步：利用创建的 redis 数据库对象对数据库进行操作      → <code>result = red_obj.sadd(&quot;name：age&quot; , &quot;21&quot;)</code>  向外键名为name的集合内插入键为age值为“21”的一条数据</p><p>注意：redis内的集合数据类型具有数据唯一性以及无序性的特征，如果上述插入的数据在集合内存在返回0，不存在返回数据1</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013095424043.png"  alt="image-20211013095424043">      </p>        <h2 id="redis实现增量爬虫【重点】"   >          <a href="#redis实现增量爬虫【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#redis实现增量爬虫【重点】" class="headerlink" title="redis实现增量爬虫【重点】"></a>redis实现增量爬虫【重点】</h2>              <h3 id="怎么利用-redis-实现增量式爬虫"   >          <a href="#怎么利用-redis-实现增量式爬虫" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么利用-redis-实现增量式爬虫" class="headerlink" title="怎么利用 redis 实现增量式爬虫"></a>怎么利用 redis 实现增量式爬虫</h3>      <p>实现重要方法：</p><p>第一步：在进行爬取指定url数据时，先将指定 url 写入到 redis 数据库集合内，获取返回值！<br>写入redis集合方法：连接数据库对象.sadd（键名，键名所对应的值）</p><p>第二步：如果返回值是1，就说明这个url还未加入到url指纹数据库内（未爬取），可进一步爬取当前url数据，如果返回值为 0 说明当前经过md5加密后的url已经加入到url指纹数据库内，无需爬取，退出程序（只适用于电商新闻类网站！）</p><p>实现原理：因为 redis 数据库的集合具有无序性以及数据唯一性！，当数据在redis集合内存在时，插入数据失败返回值为o</p><p>未完待续…..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：如何将爬取下来的数据存储到Mysql数据库内及其redis数据库内…..&lt;/p&gt;</summary>
    
    
    
    <category term="数据存储篇" scheme="http://pythonlamb.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AF%87/"/>
    
    
    <category term="数据存储篇" scheme="http://pythonlamb.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>数据存储——CSV文件与mongoDB</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94CSV%E6%96%87%E4%BB%B6%E4%B8%8EmongoDB/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94CSV%E6%96%87%E4%BB%B6%E4%B8%8EmongoDB/</id>
    <published>2021-10-13T01:30:56.000Z</published>
    <updated>2021-10-13T01:43:56.392Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：将爬取下来的数据持久化存储到CSV文件内或存到mongoDB数据库内、Mysql数据库内，简单的二级爬虫框架等</p><span id="more"></span>        <h2 id="爬取数据持久化存储（csv）【重点】"   >          <a href="#爬取数据持久化存储（csv）【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬取数据持久化存储（csv）【重点】" class="headerlink" title="爬取数据持久化存储（csv）【重点】"></a>爬取数据持久化存储（csv）【重点】</h2>              <h3 id="python-标准库模块-csv-的使用方法及功能"   >          <a href="#python-标准库模块-csv-的使用方法及功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-标准库模块-csv-的使用方法及功能" class="headerlink" title="python 标准库模块 csv 的使用方法及功能"></a>python 标准库模块 csv 的使用方法及功能</h3>      <p>功能：将数据写入到 csv 文件的模块<br>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> （“文件名.csv”，“打开方式”） <span class="keyword">as</span>  文件别名：</span><br><span class="line">写作对象 = csv.writer（文件别名）</span><br><span class="line">写作对象.writerow（列表）    →→→→→→→→→→ 单行数据写入 csv 文件</span><br><span class="line">写作对象.writerows（列表内嵌套元组）   →→→→→→→→→→ 多行数据写入 csv 文件，其中一个元组代表一行数据！</span><br></pre></td></tr></table></div></figure><p>两种写入方法：</p><p>写作对象.writerow（列表）：这是将数据单行写入到 csv 文件内，一个列表元素是一个字段</p><p>写作对象.writerows（列表内嵌套元组）：这是将数据多行写入到 csv 文件内，一个列表内元组是一行记录</p><p>图示：</p><p>单行数据写入</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093811033.png"  alt="image-20211013093811033">      </p><p>多行数据写入</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093818574.png"  alt="image-20211013093818574">      </p>        <h3 id="将数据保存至-csv-文件的一些问题处理方法"   >          <a href="#将数据保存至-csv-文件的一些问题处理方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#将数据保存至-csv-文件的一些问题处理方法" class="headerlink" title="将数据保存至 csv 文件的一些问题处理方法"></a>将数据保存至 csv 文件的一些问题处理方法</h3>      <p>出现什么问题？ </p><p>答：多行数据保存时，每行数据下面会多出一行空行（windows专属，linux没有这种问题），这该怎么解决呢</p><p>怎么解决？</p><p>答：打开文件时加上参数 newline = “” 即可解决！！！</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093837101.png"  alt="image-20211013093837101">      </p>        <h2 id="数据持久化存储（mysql）【重点】"   >          <a href="#数据持久化存储（mysql）【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据持久化存储（mysql）【重点】" class="headerlink" title="数据持久化存储（mysql）【重点】"></a>数据持久化存储（mysql）【重点】</h2>              <h3 id="python-与-mysql-数据库交互的步骤"   >          <a href="#python-与-mysql-数据库交互的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-与-mysql-数据库交互的步骤" class="headerlink" title="python 与 mysql 数据库交互的步骤"></a>python 与 mysql 数据库交互的步骤</h3>      <p>第一步：导入 pymysql 模块</p><p>第二步：创建铁路对象 way_obj = pymysql.connect(host = 主机，user = 用户名，password = 数据库密码，database = 交互数据库名)</p><p>第三步：在铁路对象上创建游标对象 cursor_obj = way_obj.cursor（）</p><p>第四步：将数据插入到数据库内（两种方法）</p><p>1（单行数据插入）： cursor_obj.execute（SQL语句，数据列表）</p><p>2（多行数据插入）：cursor_obj.executemany(SQL语句，列表内嵌套元组数据)</p><p>第五步：将更改提交到数据库 way_obj.commit( )   注意是铁道对象提交，针对mysql数据库的事务特性！</p><p>第六步：关闭游标对象 cursor_obj.close（）</p><p>第七步：关闭铁道对象 way_obj.close( )</p><p>截图演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093857877.png"  alt="image-20211013093857877">      </p>        <h3 id="将数据存储到数据库的两种方法（单记录插入、多记录插入）"   >          <a href="#将数据存储到数据库的两种方法（单记录插入、多记录插入）" class="heading-link"><i class="fas fa-link"></i></a><a href="#将数据存储到数据库的两种方法（单记录插入、多记录插入）" class="headerlink" title="将数据存储到数据库的两种方法（单记录插入、多记录插入）"></a>将数据存储到数据库的两种方法（单记录插入、多记录插入）</h3>      <p>单行数据插入方法—— execute（）</p><p>功能：将单行数据（列表）插入到数据库内！</p><p>语法：游标对象.execute（参数1，参数2）</p><p>参数1：SQL语句<br>参数2：列表数据，所有列表数据就是一行记录</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093910839.png"  alt="image-20211013093910839">      </p><p>多行数据插入方法—— executemany（）</p><p>功能：将多行数据（列表内嵌套元组）插入到数据库内</p><p>语法：游标对象.executemany（参数1，参数2）</p><p>参数1：SQL语句<br>参数2：列表内嵌套元组，一个元组内所有数据就是数据库内的一行数据！</p><p>注意事项：列表内嵌套元组，其中一个元组内的数据就是一行记录</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013093938395.png"  alt="image-20211013093938395">      </p><p>注意事项：多行数据插入方法（executemany）比单行数据插入方法（execute）效率要快的多，因为计算机 i/o次数减少很多！！！</p>        <h2 id="mongoDB数据库基本操作【重点】"   >          <a href="#mongoDB数据库基本操作【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#mongoDB数据库基本操作【重点】" class="headerlink" title="mongoDB数据库基本操作【重点】"></a>mongoDB数据库基本操作【重点】</h2>              <h3 id="mysql、mongoDB、redis数据库的端口号"   >          <a href="#mysql、mongoDB、redis数据库的端口号" class="heading-link"><i class="fas fa-link"></i></a><a href="#mysql、mongoDB、redis数据库的端口号" class="headerlink" title="mysql、mongoDB、redis数据库的端口号"></a>mysql、mongoDB、redis数据库的端口号</h3>      <p>mysql：3306</p><p>mongoDB：27017</p><p>redis：6379</p>        <h3 id="mongoDB-数据库的详解"   >          <a href="#mongoDB-数据库的详解" class="heading-link"><i class="fas fa-link"></i></a><a href="#mongoDB-数据库的详解" class="headerlink" title="mongoDB 数据库的详解"></a>mongoDB 数据库的详解</h3>      <p>特征：mongoDB数据库是非关系型数据库（开源、免费），以键值对的形式存储数据，存放数据的数据类型为 json 文档，且mongoDB是基于磁盘存储数据（redis基于内存存储数据）</p><p>mongoDB数据库与mysql数据库的对比分析：</p><p>mysql数据库：</p><p>定义：关系型数据库</p><p>结构：数据库→数据表→数据表记录</p><p>基于存储：不同引擎不同存储方式</p><p>存储数据时是否需要提前建表：是</p><p>存储模式：静态模式</p><p>查询语言：SQL语言</p><p>​            </p><p>mongoDB数据库：</p><p>定义：非关系型数据库</p><p>结构：数据库→数据集合→json文档（字典）</p><p>基于存储：基于磁盘存储（虚拟内存+持久化）</p><p>存储数据时是否需要提前建集合：否</p><p>存储模式：动态模式（不需要提前建数据集合以及字段什么的）</p><p>查询语言：独特的mongoDB语言</p><p>优势：分布式集群</p><p>缺点：不支持事务！</p><p>​                </p><p>注意事项：</p><p>1：mongoDB 数据库内的数据集合里面可以存放好多条 json文档（字典）</p><p>2：每一个 json 文档就是一个字典！</p>        <h3 id="mongoDB数据库的基本操作（安装、查看数据库、删除数据库等等）"   >          <a href="#mongoDB数据库的基本操作（安装、查看数据库、删除数据库等等）" class="heading-link"><i class="fas fa-link"></i></a><a href="#mongoDB数据库的基本操作（安装、查看数据库、删除数据库等等）" class="headerlink" title="mongoDB数据库的基本操作（安装、查看数据库、删除数据库等等）"></a>mongoDB数据库的基本操作（安装、查看数据库、删除数据库等等）</h3>      <p>1.mongoDB数据库安装步骤（linux-ubuntu系统）：</p><p>安装指令：sudo apt-get install mongdb</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094020403.png"  alt="image-20211013094020403">      </p><p>2.查看mongoDB数据库内的所有数据表</p><p>指令：show dbs</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094043171.png"  alt="image-20211013094043171">      </p><p>3 . 进入（切换）数据库<br>指令：use 数据库名<br>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094055168.png"  alt="image-20211013094055168">      </p><p>4 . 查看当前所在的数据库内所有集合<br>指令：show collections<br>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094105537.png"  alt="image-20211013094105537">      </p><ol start="5"><li>查看当前数据库内的数据集合里面有哪些文档</li></ol><p>  语法：<br>  正常查询输出：db.集合名.find（）<br>  格式化查询输出：db.集合名.find（）.pretty（）</p><p>  截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094118675.png"  alt="image-20211013094118675">      </p><ol start="6"><li>查看当前数据库内的数据集合里面的文档数量<br>语法：db.数据集合名.count（）<br>截图：</li></ol><p>          <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094127336.png"  alt="image-20211013094127336">      </p><p>7.删除数据库内的指定集合<br>语法：db.指定数据集合名.drop（）<br>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094138284.png"  alt="image-20211013094138284">      </p><p>8.删除指定数据表<br>语法：db.dropDatabase( )<br>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094144723.png"  alt="image-20211013094144723">      </p><p>9.查看当前所在数据库名<br>语法：db.getName（）<br>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094153128.png"  alt="image-20211013094153128">      </p>        <h3 id="python-怎么与mongoDB数据库进行交互？"   >          <a href="#python-怎么与mongoDB数据库进行交互？" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-怎么与mongoDB数据库进行交互？" class="headerlink" title="python 怎么与mongoDB数据库进行交互？"></a>python 怎么与mongoDB数据库进行交互？</h3>      <p>交互步骤：</p><p>第一步：导入模块 import pymongo </p><p>注意：pymongo不是标准库需要安装</p><p>linux终端安装指令：sudu pip3 install pymongo</p><p>第二步：创建mongo数据库连接客户对象     con_obj = pymongo.MongoClient(host = 当前主机，port = 端口号)</p><p>注意：</p><p>1：主机一般都是 127.0.0.1</p><p>2：mongoDB数据库的端口号是 27017</p><p>3：参数MongoClient方法的port参数数据类型是数字，不是字符串</p><p>第三步：创建数据库对象     db_obj = 连接对象[“数据库名”]</p><p>注意：数据库名可以是在mongoDB数据库内存在的，也可以是不存在的，存在则直接进行操作，不存在则先创建这个数据库在操作</p><p>第四步：创建数据集合对象  set_obj = 数据库对象[“数据集合名”]</p><p>第五步：向数据集合内插入文档</p><p>插入单条文档数据方法：数据库集合对象.insert_one(字典)</p><p>插入多条文档数据方法：数据库集合对象.insert_many(列表内嵌套字典)</p><p>注意事项：插入单条文档数据时一个字典就是一条文档数据，插入多条文档数据也是如此（一个字典是一个文档数据）</p><p>总体注意：在利用 python 与 mongoDB 数据库进行交互时，不需要提前建好数据库以及数据集合，这是与mysql数据库交互的不同之处！</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094223862.png"  alt="image-20211013094223862">      </p>        <h2 id="数据持久化存储（mongodb）【重点】"   >          <a href="#数据持久化存储（mongodb）【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据持久化存储（mongodb）【重点】" class="headerlink" title="数据持久化存储（mongodb）【重点】"></a>数据持久化存储（mongodb）【重点】</h2>              <h3 id="将数据持久化存储到mongoDB数据库的两种方法"   >          <a href="#将数据持久化存储到mongoDB数据库的两种方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#将数据持久化存储到mongoDB数据库的两种方法" class="headerlink" title="将数据持久化存储到mongoDB数据库的两种方法"></a>将数据持久化存储到mongoDB数据库的两种方法</h3>      <p>1.单条数据文档插入存储方法——数据集合对象.insert_one({})</p><p>功能：将单条文档数据（字典）插入到建好的mongoDB数据库的数据集合内</p><p>语法：数据集合对象.insert_one({})</p><p>注意：insert_one（{}）方法里面的参数是字典，一个字典就代表一个文档数据</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094245938.png"  alt="image-20211013094245938">      </p><p>2.多条数据文档插入存储方法——数据集合对象.insert_many( [ {}，{}，{}，{} ] )</p><p>功能：将多条文档数据（列表内嵌套字典）插入到建好的mongoDB数据库的数据集合内</p><p>语法：数据集合对象.insert_many( [ {}，{}，{}，{} ] )</p><p>注意：insert_one（{}）方法里面的参数是列表内嵌套字典，一个字典就代表一个文档数据</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094301571.png"  alt="image-20211013094301571">      </p>        <h2 id="random模块的uniform方法【重点】"   >          <a href="#random模块的uniform方法【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#random模块的uniform方法【重点】" class="headerlink" title="random模块的uniform方法【重点】"></a>random模块的uniform方法【重点】</h2>              <h3 id="random-模块的-uniform-方法的使用"   >          <a href="#random-模块的-uniform-方法的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#random-模块的-uniform-方法的使用" class="headerlink" title="random 模块的 uniform 方法的使用"></a>random 模块的 uniform 方法的使用</h3>      <p>功能：随机生成指定区间的浮点数</p><p>语法：random.uniform（1，6）    随机生成1到6的浮点数</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013094313020.png"  alt="image-20211013094313020">      </p>        <h2 id="简单的二级爬虫框架【重点】"   >          <a href="#简单的二级爬虫框架【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单的二级爬虫框架【重点】" class="headerlink" title="简单的二级爬虫框架【重点】"></a>简单的二级爬虫框架【重点】</h2>      <p>注意：字太小先保存到计算机内在方法观看‘</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/python%E4%BA%8C%E7%BA%A7%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E3%80%90%E7%BE%94%E7%BE%8A%E6%80%BB%E7%BB%93%E3%80%91.png" >      </p><p>未完待续…..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：将爬取下来的数据持久化存储到CSV文件内或存到mongoDB数据库内、Mysql数据库内，简单的二级爬虫框架等&lt;/p&gt;</summary>
    
    
    
    <category term="数据存储篇" scheme="http://pythonlamb.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AF%87/"/>
    
    
    <category term="数据存储篇" scheme="http://pythonlamb.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>爬虫基础——urllib库与正则表达式</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94urllib%E5%BA%93%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94urllib%E5%BA%93%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-10-13T01:15:05.000Z</published>
    <updated>2021-10-13T01:29:42.645Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：了解什么是爬虫、urllib请求库的使用、正则表达式的使用等…..</p><span id="more"></span>        <h2 id="什么是爬虫及其分类！"   >          <a href="#什么是爬虫及其分类！" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是爬虫及其分类！" class="headerlink" title="什么是爬虫及其分类！"></a>什么是爬虫及其分类！</h2>              <h3 id="什么是网络爬虫？"   >          <a href="#什么是网络爬虫？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是网络爬虫？" class="headerlink" title="什么是网络爬虫？"></a>什么是网络爬虫？</h3>      <p>答：网络爬虫就是利用一段程序模拟人操作浏览器获取数据的过程，且模拟人操作浏览器越逼真越好！</p>        <h3 id="网络爬虫的分类"   >          <a href="#网络爬虫的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络爬虫的分类" class="headerlink" title="网络爬虫的分类"></a>网络爬虫的分类</h3>      <p>通用爬虫：浏览器所用的爬虫，需要遵守 robots 君子协议</p><p>聚焦爬虫：针对一些特定网页获取数据</p><p>功能爬虫：利用爬虫实现一些功能，如自动投票、自动抢票等</p><p>数据爬虫：利用爬虫获取一些指定网页的数据！</p><p>注意事项：在网站的根目录下输入 /robots.txt 可查看网站的 robots 协议</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092323280.png"  alt="image-20211013092323280">      </p>        <h2 id="爬虫爬取数据的步骤！"   >          <a href="#爬虫爬取数据的步骤！" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬虫爬取数据的步骤！" class="headerlink" title="爬虫爬取数据的步骤！"></a>爬虫爬取数据的步骤！</h2>              <h3 id="爬虫获取数据的步骤！"   >          <a href="#爬虫获取数据的步骤！" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬虫获取数据的步骤！" class="headerlink" title="爬虫获取数据的步骤！"></a>爬虫获取数据的步骤！</h3>      <p>第一：找到需要爬取数据的 url 地址</p><p>第二：（包装请求头）向这个 url 地址发起请求</p><p>第三：获取这个 url 服务器发来的响应数据（网页源代码）</p><p>第四：利用 python 数据解析库在源码中获得想要的数据！</p><p>第五：将数据进行清洗保存（csv、数据库、Excel）！</p><p>第六：是否需要在原网页内进行链接跳转再抓取数据！</p>        <h2 id="urllib-request库的方法及功能【重点】"   >          <a href="#urllib-request库的方法及功能【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-request库的方法及功能【重点】" class="headerlink" title="urllib.request库的方法及功能【重点】"></a>urllib.request库的方法及功能【重点】</h2>              <h3 id="urllib-request-库内的-urlopen（）方法功能"   >          <a href="#urllib-request-库内的-urlopen（）方法功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-request-库内的-urlopen（）方法功能" class="headerlink" title="urllib.request 库内的 urlopen（）方法功能"></a>urllib.request 库内的 urlopen（）方法功能</h3>      <p>功能：向目标 url 发送一个请求，并返回一个相应对象</p><p>方法参数：</p><p>url：发送请求的目标网站（网站一定要写全 例如 <span class="exturl"><a class="exturl__link"   href="http://www.baidu.com/" >http://www.baidu.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，http不能忘以及最后的/）</p><p>timeout：设置请求时间，超过设置的请求时间将抛出异常</p><p>语法：<code>res_obj = urllib.request.urlopen（url）</code></p><p>注意：res_obj 只是网站响应的对象，不是网站相应的数据！！！</p>        <h3 id="urllib-request-urlopen（）方法返回的响应对象的方法"   >          <a href="#urllib-request-urlopen（）方法返回的响应对象的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-request-urlopen（）方法返回的响应对象的方法" class="headerlink" title="urllib.request.urlopen（）方法返回的响应对象的方法"></a>urllib.request.urlopen（）方法返回的响应对象的方法</h3>      <p>响应对象.read（）：获取网站响应的源代码（bytes数据格式）【字节串数据格式】</p><p>响应对象.read.decode（编码格式）：获取网站响应的源代码（string数据格式）【字符串数据格式】</p><p>响应对象.geturl（）：获取实际返回响应数据的网站url（考虑到重定向问题）</p><p>响应对象.getcode（）：获取网站的http响应状态码</p><p>注意：    bytes数据与string数据不一样，bytes是以字节为单位，string是以字符为单位， string通过encode（）编码可转换为bytes，bytes可通过decode（）解码转换为string，bytes数据格式为 b“数据”，string数据格式为 “数据”</p><p>图示：</p><p>响应对象的.read（）方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092402556.png"  alt="image-20211013092402556">      </p><p>响应对象的.read（）.decode（）方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092409918.png"  alt="image-20211013092409918">      </p><p>响应对象的.geturl（）与响应对象的.getcode（）方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092417285.png"  alt="image-20211013092417285">      </p>        <h3 id="怎么查看程序向网站发送请求时标头的-User-Agent"   >          <a href="#怎么查看程序向网站发送请求时标头的-User-Agent" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查看程序向网站发送请求时标头的-User-Agent" class="headerlink" title="怎么查看程序向网站发送请求时标头的 User-Agent"></a>怎么查看程序向网站发送请求时标头的 User-Agent</h3>      <p>直接向下面 url 地址发送请求即可查看请求协议标头的 User-Agent</p><p>网站：<span class="exturl"><a class="exturl__link"   href="http://httpbin.org/get" >http://httpbin.org/get</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>图示：</p><p>浏览器发送请求查看 User-Agent</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092437732.png"  alt="image-20211013092437732">      </p><p>python的urllib库发送请求查看 User-Agent</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092445366.png"  alt="image-20211013092445366">      </p>        <h3 id="urllib-request库内的-Request（）方法功能"   >          <a href="#urllib-request库内的-Request（）方法功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-request库内的-Request（）方法功能" class="headerlink" title="urllib.request库内的 Request（）方法功能"></a>urllib.request库内的 Request（）方法功能</h3>      <p>功能：包装请求标头信息（一般是 User-Agent），并且返回这个包装好的请求头对象，用于向 url 发送请求</p><p>语法：<code>req = urllib.request.Request（url = 网站域名，headers = &#123;“User-Agent”：“伪装的标头信息”&#125;）</code></p><p>参数：</p><p>url：待请求的链接地址</p><p>headers：伪装的请求标头信息</p><p>注意事项：Request方法并没有向网站发送请求，而是伪装请求标头，urlopen方法才向目标网站发送请求并且接收响应数据</p><p>截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092505732.png"  alt="image-20211013092505732">      </p>        <h2 id="urllib-parse模块的方法功能解析【重点】"   >          <a href="#urllib-parse模块的方法功能解析【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-parse模块的方法功能解析【重点】" class="headerlink" title="urllib.parse模块的方法功能解析【重点】"></a>urllib.parse模块的方法功能解析【重点】</h2>      <p>目标：</p><p>1：掌握搜索关键字 url 地址的组成部分</p><p>2：掌握向目标查询关键字地址发送请求的注意事项</p><p>3：urllib.parse.urlencode（）方法详解</p><p>4：urllib.parse.quote（）方法详解</p><p>5：掌握 urllib.parse库内的 urlencode 方法以及 quote 方法的区别~</p>        <h3 id="搜索关键字-url-地址的组成部分"   >          <a href="#搜索关键字-url-地址的组成部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#搜索关键字-url-地址的组成部分" class="headerlink" title="搜索关键字 url 地址的组成部分"></a>搜索关键字 url 地址的组成部分</h3>      <p>组成：协议项+域名+数据库资源路径+查询参数</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092521994.png"  alt="image-20211013092521994">      </p><p>注意：其实很多查询参数都没有用，上面的 url 可简化为 <span class="exturl"><a class="exturl__link"   href="https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3" >https://www.baidu.com/s?wd=美女</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="向查询关键字地址服务器发送请求的注意事项"   >          <a href="#向查询关键字地址服务器发送请求的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#向查询关键字地址服务器发送请求的注意事项" class="headerlink" title="向查询关键字地址服务器发送请求的注意事项"></a>向查询关键字地址服务器发送请求的注意事项</h3>      <p>什么是查询关键字地址？：就是搜索相应关键字所对应的url地址，例如在百度上查询美女的url地址如下</p><p> <span class="exturl"><a class="exturl__link"   href="https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3" >https://www.baidu.com/s?wd=美女</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>向查询关键字地址服务器发送请求的注意事项：需要将url地址内中文 编码后 才可以向服务器发送请求</p><p>示例：</p><p>编码前URL地址：<span class="exturl"><a class="exturl__link"   href="https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3" >https://www.baidu.com/s?wd=美女</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>编码后URL地址：<span class="exturl"><a class="exturl__link"   href="https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3" >https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>注意：编码后三个%对应一个中文字符，例如%E7%BE%8E就对应 美 这个中文字符</p>        <h3 id="urllib-parse-urlencode（）方法详解"   >          <a href="#urllib-parse-urlencode（）方法详解" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-parse-urlencode（）方法详解" class="headerlink" title="urllib.parse.urlencode（）方法详解"></a>urllib.parse.urlencode（）方法详解</h3>      <p>功能：将查询参数内的中文进行编码，并返回编码后的查询参数（返回多个编码后的查询参数时默认返回 &amp;）</p><p>语法：返回编码后查询参数 = urllib.parse.urlencode（{查询参数1：待编码值1，查询参数2：待编码值2……….}）</p><p>语法参数：</p><p>字典：字典内存放需要编码的查询参数，例如查询参数为   wd=美女   就这么写 {“wd”：“美女”}</p><p>语法参数返回值：</p><p><code>params = urllib.parse.urlencode（&#123;“wd”：“美女”&#125;）</code>   params 就是 wd=%E7%BE%8E%E5%A5%B3</p><p>注意事项：urllib.parse.urlencode（）方法只返回编码后的查询参数，并不是整个url地址，需要进行字符串拼接才能向目标url服务器发送请求</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092600107.png"  alt="image-20211013092600107">      </p>        <h3 id="urllib-parse-quote（）方法详解"   >          <a href="#urllib-parse-quote（）方法详解" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-parse-quote（）方法详解" class="headerlink" title="urllib.parse.quote（）方法详解"></a>urllib.parse.quote（）方法详解</h3>      <p>功能：对查询参数内的中文进行编码，并且返回这个中文编码后的字符串</p><p>语法：编码后的中文字符串 = urllib.parse.quote（”查询参数中的中文关键字“）</p><p>例如：params = urllib.parse.quote（”美女“）  params 就是  %E7%BE%8E%E5%A5%B3  </p><p>方法参数：</p><p>查询参数内的中文：只是中文，没有相对应的 wd 等</p><p>注意事项：这个方法只返回编码后的中文字符，连键都不返回需要自己写</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092614582.png"  alt="image-20211013092614582">      </p>        <h3 id="urllib-parse库内的-urlencode-方法以及-quote-方法的区别"   >          <a href="#urllib-parse库内的-urlencode-方法以及-quote-方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-parse库内的-urlencode-方法以及-quote-方法的区别" class="headerlink" title="urllib.parse库内的 urlencode 方法以及 quote 方法的区别~"></a>urllib.parse库内的 urlencode 方法以及 quote 方法的区别~</h3>      <p>区别：</p><p>1：参数不同，urlencode参数为字典，quote参数是中文字符串</p><p>2：返回值不同，urldecode返回的是键与值，例如 wd=%E7%BE%8E%E5%A5%B3 ，quote方法返回的只有值，例如 %E7%BE%8E%E5%A5%B3 </p>        <h2 id="简单爬虫的构架【重点】"   >          <a href="#简单爬虫的构架【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单爬虫的构架【重点】" class="headerlink" title="简单爬虫的构架【重点】"></a>简单爬虫的构架【重点】</h2>              <h3 id="简单爬虫的老版本构架（面向对象编程）"   >          <a href="#简单爬虫的老版本构架（面向对象编程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单爬虫的老版本构架（面向对象编程）" class="headerlink" title="简单爬虫的老版本构架（面向对象编程）"></a>简单爬虫的老版本构架（面向对象编程）</h3>      <p>可保存至电脑放大来看！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/python.png" >      </p>        <h3 id="简单爬虫的新版本构架（面向对象编程）"   >          <a href="#简单爬虫的新版本构架（面向对象编程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单爬虫的新版本构架（面向对象编程）" class="headerlink" title="简单爬虫的新版本构架（面向对象编程）"></a>简单爬虫的新版本构架（面向对象编程）</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/Snipaste_2021-04-28_20-31-44.png" >      </p>        <h2 id="正则模块（re）的使用【重点】"   >          <a href="#正则模块（re）的使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则模块（re）的使用【重点】" class="headerlink" title="正则模块（re）的使用【重点】"></a>正则模块（re）的使用【重点】</h2>              <h3 id="正则模块-re-抓取数据的两种方法形式"   >          <a href="#正则模块-re-抓取数据的两种方法形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则模块-re-抓取数据的两种方法形式" class="headerlink" title="正则模块 re 抓取数据的两种方法形式"></a>正则模块 re 抓取数据的两种方法形式</h3>      <p>第一种形式(直接使用findall（查找数据）方法)：</p><p>data_list = re.findall（正则表达式，待匹配字符串，re.S）</p><p>第二种形式（先创建正则编译对象在调用findall等方法）：</p><p>pattern = re.compile（正则表达式，re.S）<br>data_list = pattern.findall(待匹配字符串)</p><p>注意事项：一般大佬都用第二种形式，因为正则写好一个可以多次调用</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092723573.png"  alt="image-20211013092723573">      </p>        <h3 id="正则模块-re-方法的-re-S参数的作用"   >          <a href="#正则模块-re-方法的-re-S参数的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则模块-re-方法的-re-S参数的作用" class="headerlink" title="正则模块 re 方法的 re.S参数的作用"></a>正则模块 re 方法的 re.S参数的作用</h3>      <p>作用：正则表达式中的元字符 . 可以匹配任意字符（除了换行符/n），在findall等方法内部加上参数 re.S后 元字符 . 就可以匹配换行符/n啦</p><p>注意：在抓取 html 代码时一定不要忘记写 re.S参数，因为 html 代码有很多换行符</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092734436.png"  alt="image-20211013092734436">      </p>        <h3 id="正则表达式贪婪模式以及非贪婪模式的注意事项"   >          <a href="#正则表达式贪婪模式以及非贪婪模式的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式贪婪模式以及非贪婪模式的注意事项" class="headerlink" title="正则表达式贪婪模式以及非贪婪模式的注意事项"></a>正则表达式贪婪模式以及非贪婪模式的注意事项</h3>      <p>元字符 ？功能： ？ 前一个字符出现1次或者0次</p><p>贪婪模式：在满足匹配规则的前提下尽可能多的匹配数据</p><p>非贪婪模式：在满足匹配规则的前提下尽可能少的匹配数据</p><p>注意事项：</p><p>1：贪婪模式与非贪婪模式说的都是在匹配多个字符时才适用，即元字符 * + ？</p><p>2：python程序默认是贪婪模式匹配数据</p><p>3：在匹配多个数据的元字符（* + ？）后面加上 ？ 就可将贪婪模式转变为非贪婪模式，注意一定是在匹配多个元字符后面加才管用！！！</p>        <h3 id="正则表达式单个分组以及多个分组的用法"   >          <a href="#正则表达式单个分组以及多个分组的用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式单个分组以及多个分组的用法" class="headerlink" title="正则表达式单个分组以及多个分组的用法"></a>正则表达式单个分组以及多个分组的用法</h3>      <p>用法【单个分组】：如果在正则表达式的一部分加上单个分组，也就是一个（） 那么在调用 findall方法时，只将符合分组内的数据提取到列表内！</p><p>用法【多个分组】：如果在正则表达式的一部分加上多个分组，也就是多个（） 那么在调用 findall方法时，将符合多个分组内的数据先保存到一个元组内，然后在匹配其他符合分组的数据，再次存放到另一个元组内，然后在将多个元组存放至列表中【列表内嵌套元组】</p><p>图示【单个分组】  【多个分组】：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092752765.png"  alt="image-20211013092752765">      </p>        <h2 id="正则表达式匹配html数据的技巧【重点】"   >          <a href="#正则表达式匹配html数据的技巧【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式匹配html数据的技巧【重点】" class="headerlink" title="正则表达式匹配html数据的技巧【重点】"></a>正则表达式匹配html数据的技巧【重点】</h2>      <p>目标：掌握正则表达式匹配 html 代码的技巧</p>        <h3 id="正则表达式匹配-html-代码的技巧"   >          <a href="#正则表达式匹配-html-代码的技巧" class="heading-link"><i class="fas fa-link"></i></a><a href="#正则表达式匹配-html-代码的技巧" class="headerlink" title="正则表达式匹配 html 代码的技巧"></a>正则表达式匹配 html 代码的技巧</h3>      <p>实例html代码如下（提取电影名、主演、上映时间）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092804554.png"  alt="image-20211013092804554">      </p><p>正则表达式可以这么写！！</p><p>对应的正则表达式：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;movie-item-info&quot;&gt;.*?&lt;a href&#x3D;&quot;&#x2F;films&#x2F;[0-9]+&quot; title&#x3D;&quot;(.*?)&quot;.*?&lt;p class&#x3D;&quot;star&quot;&gt;\s+主演：(.*?)\s+&lt;&#x2F;p&gt;\s+&lt;p class&#x3D;&quot;releasetime&quot;&gt;上映时间：(.*?)&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></div></figure><p>书写正则的技巧：</p><p>1：第一个包含类的标签一定要写出来（例如 <code>&lt;div class=&quot;movie-item-info&quot;&gt;</code>）这样正则可一下就找出来匹配的数据在那个标签类</p><p>2：待匹配的数据要加上分组，一般都是这么写 <code>（.*？）</code>，这样可被findall方法直接匹配出来</p><p>3：待匹配数据的前一个标签一般要按照给出的写出来（也可以不写！）</p><p>4：<code>.*？</code>正则表达式是一个很好的东西哦，一定要学会使用！！！</p><p>5：因为加上了 re.S 参数，所以 . 可以匹配任何数据</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013092844399.png"  alt="image-20211013092844399">      </p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：了解什么是爬虫、urllib请求库的使用、正则表达式的使用等…..&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/categories/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
    
    <category term="爬虫基础篇" scheme="http://pythonlamb.github.io/tags/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>爬虫的疑难杂症【第一期】</title>
    <link href="http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E3%80%90%E7%AC%AC%E4%B8%80%E6%9C%9F%E3%80%91/"/>
    <id>http://pythonlamb.github.io/2021/10/13/%E7%88%AC%E8%99%AB%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E3%80%90%E7%AC%AC%E4%B8%80%E6%9C%9F%E3%80%91/</id>
    <published>2021-10-13T01:01:00.000Z</published>
    <updated>2021-10-13T01:13:31.397Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：在爬虫过程中遇到的编码解码问题、发送请求错误、写正则的技巧、字符串列表字典之间的互转、浏览器抓包犯病等等问题~</p><span id="more"></span>        <h2 id="获取响应数据出现编码的问题"   >          <a href="#获取响应数据出现编码的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取响应数据出现编码的问题" class="headerlink" title="获取响应数据出现编码的问题"></a>获取响应数据出现编码的问题</h2>      <p>报错提示：</p><p>UnicodeDecodeError: ‘gb18030’ codec can’t decode byte 0xa1 in position 32952: illegal multibyte sequence</p><p>报错翻译：’gb18030’编解码器无法解码位置32952中的字节0xa1：非法的多字节序列 </p><p>报错原因：有的字节使用 gb18030 字符集解码时是无效的</p><p>解决办法：在解码方法 decode（）里面加上参数  ignore，即可忽略不能解码的字符！！</p><p>办法截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091115228.png"  alt="image-20211013091115228">      </p><p>注意事项：中国对字符进行解码有三种字符集，分别是 gbk、gb2312、gb18030，其中gb18030是最强的解码字符集，gb2312不能解的，gb18030可以解！</p>        <h2 id="向网站服务器发送请求时错误（捕获异常）【网络问题】"   >          <a href="#向网站服务器发送请求时错误（捕获异常）【网络问题】" class="heading-link"><i class="fas fa-link"></i></a><a href="#向网站服务器发送请求时错误（捕获异常）【网络问题】" class="headerlink" title="向网站服务器发送请求时错误（捕获异常）【网络问题】"></a>向网站服务器发送请求时错误（捕获异常）【网络问题】</h2>      <p>报错提示：&lt;urlopen error [Errno 11001] getaddrinfo failed&gt;</p><p>报错翻译：&lt;urlopen错误[Errno 11001] getaddrinfo失败&gt;</p><p>报错原因：因为网络（网络不稳定）原因或者url地址的原因出现错误</p><p>解决办法：死循环加上捕获异常即可解决此问题</p><p>解决代码：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>：</span><br><span class="line"><span class="keyword">try</span>：</span><br><span class="line">html_data = urllib.request.urlopne(url = url)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line"><span class="built_in">print</span>( f <span class="string">&quot;出现错误：&#123;result&#125; 将继续执行此代码！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></div></figure><p>else功能：当try下面的代码不报错时执行else下面缩进的代码！</p><p>解决代码截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091147002.png"  alt="image-20211013091147002">      </p>        <h2 id="写正则的技巧【重中之重】"   >          <a href="#写正则的技巧【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#写正则的技巧【重中之重】" class="headerlink" title="写正则的技巧【重中之重】"></a>写正则的技巧【重中之重】</h2>      <p>目标：掌握在 html 源代码中提取数据写正则的技巧</p><p>一：在 html 源代码中提取数据写正则的技巧</p><p>答：写正则提取数据之前，先不要查看网站源代码，先检查查看提取的数据在哪个标签内，把这个标签直接复制到文本文档内，在写正则即可！！！</p><p>注意事项：</p><p>1：在写正则的时候一定不要出现这种情况→→→→ <code>.*? (.*?)</code>    也就是两个<code>.*？</code>连在一起的情况！！</p><p>2：需要提取的数据  前一个标签与后一个标签一定不能省略！（一定要写）</p>        <h2 id="字符串、列表、字典之间的相互转化【重点】"   >          <a href="#字符串、列表、字典之间的相互转化【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串、列表、字典之间的相互转化【重点】" class="headerlink" title="字符串、列表、字典之间的相互转化【重点】"></a>字符串、列表、字典之间的相互转化【重点】</h2>              <h3 id="列表与字符串之间的相互转换"   >          <a href="#列表与字符串之间的相互转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表与字符串之间的相互转换" class="headerlink" title="列表与字符串之间的相互转换"></a>列表与字符串之间的相互转换</h3>      <p>列表转换为字符串方法：“”. join（列表）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091209950.png"  alt="image-20211013091209950">      </p>        <h3 id="字典与字符串的相互转换"   >          <a href="#字典与字符串的相互转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#字典与字符串的相互转换" class="headerlink" title="字典与字符串的相互转换"></a>字典与字符串的相互转换</h3>      <p>转换所用到的标准库 json 库</p><p>字典转为字符串方法：json.dumps（带转换字典）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091220349.png"  alt="image-20211013091220349">      </p>        <h3 id="字符串转为字典的两种方法："   >          <a href="#字符串转为字典的两种方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串转为字典的两种方法：" class="headerlink" title="字符串转为字典的两种方法："></a>字符串转为字典的两种方法：</h3>      <p>1：dict = eval( s )   其中 s 为字典格式的字符串</p><p>2：json.loads（s）  其中 s 为字典格式的字符串</p><p>图示：</p><p>一般方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091237813.png"  alt="image-20211013091237813">      </p><p>Json.loads方法转换</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091244244.png"  alt="image-20211013091244244">      </p>        <h3 id="将字典转换为字符串之后写入到文件内中文出现乱码的问题！"   >          <a href="#将字典转换为字符串之后写入到文件内中文出现乱码的问题！" class="heading-link"><i class="fas fa-link"></i></a><a href="#将字典转换为字符串之后写入到文件内中文出现乱码的问题！" class="headerlink" title="将字典转换为字符串之后写入到文件内中文出现乱码的问题！"></a>将字典转换为字符串之后写入到文件内中文出现乱码的问题！</h3>      <p>字典转字符串的方法：json.dumps（带转换字典）</p><p>问题截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091252739.png"  alt="image-20211013091252739">      </p><p>解决问题：</p><p>将 json.dumps（）方法内的 ensure_ascii 参数值改为 False 即可（默认为True）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211013091301518.png"  alt="image-20211013091301518">      </p>        <h2 id="浏览器抓包时犯病怎么解决"   >          <a href="#浏览器抓包时犯病怎么解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#浏览器抓包时犯病怎么解决" class="headerlink" title="浏览器抓包时犯病怎么解决"></a>浏览器抓包时犯病怎么解决</h2>      <p>浏览器清除缓存快捷键：Ctrl + Shift + Del 【如果浏览器犯病就试试这个快捷键】</p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：在爬虫过程中遇到的编码解码问题、发送请求错误、写正则的技巧、字符串列表字典之间的互转、浏览器抓包犯病等等问题~&lt;/p&gt;</summary>
    
    
    
    <category term="疑难杂症篇" scheme="http://pythonlamb.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E7%AF%87/"/>
    
    
    <category term="疑难杂症篇" scheme="http://pythonlamb.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>精致BOY【第一期】</title>
    <link href="http://pythonlamb.github.io/2021/10/12/%E7%B2%BE%E8%87%B4BOY%E3%80%90%E7%AC%AC%E4%B8%80%E6%9C%9F%E3%80%91/"/>
    <id>http://pythonlamb.github.io/2021/10/12/%E7%B2%BE%E8%87%B4BOY%E3%80%90%E7%AC%AC%E4%B8%80%E6%9C%9F%E3%80%91/</id>
    <published>2021-10-12T10:56:53.000Z</published>
    <updated>2021-10-12T11:08:49.604Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：男孩子怎么护肤、怎么健身、怎么拍照、怎么选购香水、发型相关、怎么变帅、穿衣服的一些小技巧、怎么选购镜框、好物分享等…</p><span id="more"></span>        <h2 id="怎么护肤"   >          <a href="#怎么护肤" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么护肤" class="headerlink" title="怎么护肤"></a>怎么护肤</h2>      <p>早上：洁面【用氨基酸补水温和清洁的洗面奶】（用洗面奶洁面时不要太用力洗以及不要用太热的水，温水或凉水）  →   用毛巾轻轻吸干水分（不要用力擦） → 涂水  →  在涂精华  → 在用乳</p><p>晚上：洁面【用氨基酸补水深层清洁的洗面奶】 → 用毛巾轻轻吸干水分 → 用美白面膜【一周两次 可以选择泥状面膜】or 去角质【十天去一次角质】  →  涂水  →  在涂精华  → 在用乳</p>        <h2 id="怎么健身"   >          <a href="#怎么健身" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么健身" class="headerlink" title="怎么健身"></a>怎么健身</h2>      <p>我的体脂率为：13.96%</p><p>健身顺序为：热身 → 无氧运动【剧烈的运动 举重 哑铃】 → 有氧运动【缓慢的 慢跑 骑车】</p><p>健身中的吃法：</p><p>健身前半小时：粗粮面包 or 香蕉 or 补剂【增肌粉】    注意：增肌粉 = 蛋白粉 + 碳水化合物</p><p>健身中：十五分钟补充一次水分【每次150-200ml】</p><p>健身后半小时进食：粗粮面包 or 香蕉 or 补剂【增肌粉】    注意：增肌粉 = 蛋白粉 + 碳水化合物</p><p>健身的注意事项：</p><p>1：健身后不要立即冲凉水澡</p><p>2：运动过后不要急刹车</p><p>3：不要饱腹以及空腹运动</p><p>4：增肌健身最好的时间段在下午4：00 —  6：00 【我选择】</p><p>健身的时间掌控：热身约5分钟，力量训练约30<del>40分钟，有氧约10</del>20分钟，放松约5分钟，每次锻炼总时长约50~70分钟。</p>        <h2 id="怎么拍照"   >          <a href="#怎么拍照" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么拍照" class="headerlink" title="怎么拍照"></a>怎么拍照</h2>      <p>略…….</p>        <h2 id="怎么选购香水"   >          <a href="#怎么选购香水" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么选购香水" class="headerlink" title="怎么选购香水"></a>怎么选购香水</h2>      <p>香水分类：</p><p>1：香精</p><p>2：浓香水</p><p>3：淡香水【男士常用】</p><p>4：古龙水【男士常用】【有好感】</p><p>香水品牌：香奈儿、迪奥、爱马仕等等</p><p>男士选择香水香调的标准【我可以尝试 果香以及柑橘味道】：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012190655568.png"  alt="image-20211012190655568">      </p><p>香水涂抹留香的位置：指尖、脖颈、肘窝、肚皮【或者内衣】、裤兜</p><p>喷香水的注意事项：</p><p>1：烟味很大的话不建议喷香水</p><p>2：和女生约会考虑喷香水、成天和哥们一起就不要喷了</p><p>3：形象和气味要一致</p><p>4：先不要着急买大瓶，先尝试尝试小样！</p><p>最重要：如果我喷了香水就不要与其他味道浓的产品一起使用【例如凝香珠、发胶】</p>        <h2 id="发型相关"   >          <a href="#发型相关" class="heading-link"><i class="fas fa-link"></i></a><a href="#发型相关" class="headerlink" title="发型相关"></a>发型相关</h2>      <p>让头发蓬松起来的产品：蓬松粉、海盐水等一般都用在发根，减少头皮油脂</p><p>ps：我是长脸，需要有长头帘并且头帘要有碎盖的效果，否则显的整个人比较沉重、压抑等，并且长脸两边不要剃短，最好两边留长，这样显得脸比较短一点…….</p>        <h2 id="想买的产品"   >          <a href="#想买的产品" class="heading-link"><i class="fas fa-link"></i></a><a href="#想买的产品" class="headerlink" title="想买的产品"></a>想买的产品</h2>      <p>1：水乳【已经买了】</p><p>2：烧烤架子</p><p>3：墨镜</p><p>4：鼠标</p><p>5：早用温和洗面奶</p><p>6：晚用强力洗面奶</p><p>7：清洁面膜or美白面膜</p><p>8：拉力带</p><p>9：古龙果香味香水</p><p>10：漱口水【约会前漱漱口】</p><p>11：摇摇杯【内置搅拌球】</p><p>12：全身镜</p><p>13：投影仪</p><p>14：创意摆件</p><p>15：蒸汽眼罩</p>        <h2 id="怎么变帅"   >          <a href="#怎么变帅" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么变帅" class="headerlink" title="怎么变帅"></a>怎么变帅</h2>      <p>1：发型头帘一定要碎一点</p><p>2：长脸发型两边不要剪得特别短，尽量长一点，与头发有联系</p><p>3：眼睛一定要有神不要呆滞</p><p>练习方法：(找准某一个点一直盯着看【有神】，用手指画圈眼睛跟着看！逆时针、顺时针各15圈)</p><p>4：皮肤黑不要穿浅色亮面的衣服（北面那个羽绒服）</p><p>5：清洁面膜【泥状】使用步骤</p><p>1：先用温水洗一下脸</p><p>2：涂上爽肤水</p><p>3：在涂清洁面膜【出油多的地方多抹一点】</p>        <h2 id="穿【买】衣服的一些小技巧"   >          <a href="#穿【买】衣服的一些小技巧" class="heading-link"><i class="fas fa-link"></i></a><a href="#穿【买】衣服的一些小技巧" class="headerlink" title="穿【买】衣服的一些小技巧"></a>穿【买】衣服的一些小技巧</h2>      <p>1：买衣服问客服多大码衣服合身，多大码可以穿出宽松的感觉【就买那个码】</p><p>2：腿变长小妙招：鞋裤一体，尽量不要露脚踝</p><p>3：如果有一个体恤很花，那么裤子和鞋子要统一颜色</p><p>4：衣服一定要比配饰要大【充实】，也就是如果配饰很花那么衣服要更花</p>        <h2 id="怎么选购镜框"   >          <a href="#怎么选购镜框" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么选购镜框" class="headerlink" title="怎么选购镜框"></a>怎么选购镜框</h2>      <p>1：圆形脸选购方形镜框</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012190750509.png"  alt="image-20211012190750509">      </p><p>二：长脸选择圆形的镜框【镜片大的眼镜】</p><p>三：方脸选择方形镜框【就和我现在的差不多】</p><p>注意：眼镜的大小和太阳穴一齐就好</p><p>根据肤色选择镜框颜色</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211012190804802.png"  alt="image-20211012190804802">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211012190824951.png"  alt="image-20211012190824951">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012190835378.png"  alt="image-20211012190835378">      </p>        <h2 id="好物分享"   >          <a href="#好物分享" class="heading-link"><i class="fas fa-link"></i></a><a href="#好物分享" class="headerlink" title="好物分享"></a>好物分享</h2>      <p>1：衣物喷雾【吃完火锅或者晾晒衣服时候可以喷一喷】</p><p>2：RE的扩香水</p><p>3：磨砂膏【去死皮、去角质】</p><p>4：便捷式挂烫机</p><p>5：拼接式项链</p><p>未完待续……持续更新….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：男孩子怎么护肤、怎么健身、怎么拍照、怎么选购香水、发型相关、怎么变帅、穿衣服的一些小技巧、怎么选购镜框、好物分享等…&lt;/p&gt;</summary>
    
    
    
    <category term="精致BOY" scheme="http://pythonlamb.github.io/categories/%E7%B2%BE%E8%87%B4BOY/"/>
    
    
    <category term="精致BOY" scheme="http://pythonlamb.github.io/tags/%E7%B2%BE%E8%87%B4BOY/"/>
    
  </entry>
  
  <entry>
    <title>黑马程序员学Python——导入模块与继承问题</title>
    <link href="http://pythonlamb.github.io/2021/10/12/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6Python%E2%80%94%E2%80%94%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://pythonlamb.github.io/2021/10/12/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6Python%E2%80%94%E2%80%94%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-12T10:30:48.000Z</published>
    <updated>2021-10-12T10:54:47.835Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Python导入模块的几种方式及其注意事项、单继承与多继承、property装饰的使用、魔法属性与魔法方法、with上下文方式</p><span id="more"></span>        <h2 id="检测字符串文件的后缀【重点】"   >          <a href="#检测字符串文件的后缀【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#检测字符串文件的后缀【重点】" class="headerlink" title="检测字符串文件的后缀【重点】"></a>检测字符串文件的后缀【重点】</h2>              <h3 id="怎么检测文件（字符串）的后缀！"   >          <a href="#怎么检测文件（字符串）的后缀！" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么检测文件（字符串）的后缀！" class="headerlink" title="怎么检测文件（字符串）的后缀！"></a>怎么检测文件（字符串）的后缀！</h3>      <p>关键字：endswith</p><p>语法：文件字符串.endswith（“后缀”）</p><p>注意事项：</p><p>1：后缀要加上.      例如 .py  .txt</p><p>2：文件字符串.endswith（“后缀”）返回的是一个布尔值，是括号里面的后缀则返回True，不是括号里面的后缀返回False</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184426752.png"  alt="image-20211012184426752">      </p>        <h2 id="import导入模块路径【重点】"   >          <a href="#import导入模块路径【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#import导入模块路径【重点】" class="headerlink" title="import导入模块路径【重点】"></a>import导入模块路径【重点】</h2>              <h3 id="如何使用模块内的变量？"   >          <a href="#如何使用模块内的变量？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用模块内的变量？" class="headerlink" title="如何使用模块内的变量？"></a>如何使用模块内的变量？</h3>      <p>语法：模块名.变量名</p><p>实例：print（moudle.name） 即可打印 moudle 模块内name变量的值</p><p>注意事项：不仅可以使用模块内的函数以及类还可以使用变量等其他一切资源！</p><p>​    </p>        <h3 id="如何查看-python-解释器寻找模块所在路径的方法"   >          <a href="#如何查看-python-解释器寻找模块所在路径的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何查看-python-解释器寻找模块所在路径的方法" class="headerlink" title="如何查看 python 解释器寻找模块所在路径的方法"></a>如何查看 python 解释器寻找模块所在路径的方法</h3>      <p>关键字：sys.path</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>（sys.path）</span><br></pre></td></tr></table></div></figure><p>注意：sys.path是一个列表，里面存放着 python 解释器查找模块的所有路径</p><p>演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184426752.png" >      </p>        <h3 id="如何利用-import-导入指定路径的模块"   >          <a href="#如何利用-import-导入指定路径的模块" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何利用-import-导入指定路径的模块" class="headerlink" title="如何利用 import 导入指定路径的模块"></a>如何利用 import 导入指定路径的模块</h3>      <p>第一步：查看目标模块的路径</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184507006.png"  alt="image-20211012184507006">      </p><p>第二步：将目标模块路径加到 python 查找模块路径的列表内即可！</p><p>添加方法：</p><p>1：列表.append（待添加数据）</p><p>2：列表.insert（位置，待添加数据）</p><p>注意事项：</p><p>1：向 sys.path 列表（python查找模块的路径列表）内添加完模块目标路径之后，程序重新运行后，添加的那些数据会被清空！只是临时添加，需要重新添加否则报错</p><p>2：必须要先添加模块所在路径才能 import 导入 目标模块，否则报错！！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184533216.png"  alt="image-20211012184533216">      </p><p>关于注意事项1的截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184548407.png"  alt="image-20211012184548407">      </p>        <h2 id="import的reload加载问题【重点】"   >          <a href="#import的reload加载问题【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#import的reload加载问题【重点】" class="headerlink" title="import的reload加载问题【重点】"></a>import的reload加载问题【重点】</h2>              <h3 id="为什么要在一段程序中重新加载模块"   >          <a href="#为什么要在一段程序中重新加载模块" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要在一段程序中重新加载模块" class="headerlink" title="为什么要在一段程序中重新加载模块"></a>为什么要在一段程序中重新加载模块</h3>      <p>答：一段程序用到某模块运行时，其他人修改了这个模块的代码，但是运行的这段代码用的还是没修改之前的模块，这样就会造成损失，所以需要重新加载模块</p><p>注意事项：import 有防止模块重复功能，就是导入两个相同的模块，后面导入的那个一样的模块就不起作用了！</p><p>问题演示:</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184600024.png"  alt="image-20211012184600024">      </p>        <h3 id="使用-reload-方法重新加载模块"   >          <a href="#使用-reload-方法重新加载模块" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-reload-方法重新加载模块" class="headerlink" title="使用 reload 方法重新加载模块"></a>使用 reload 方法重新加载模块</h3>      <p>关键字：reload</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line">reload（待加载的模块名）</span><br></pre></td></tr></table></div></figure><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211012184615552.png"  alt="image-20211012184615552">      </p>        <h2 id="from…import-的私有化问题【重点】"   >          <a href="#from…import-的私有化问题【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#from…import-的私有化问题【重点】" class="headerlink" title="from…import * 的私有化问题【重点】"></a>from…import * 的私有化问题【重点】</h2>              <h3 id="什么是模块内变量私有化？"   >          <a href="#什么是模块内变量私有化？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是模块内变量私有化？" class="headerlink" title="什么是模块内变量私有化？"></a>什么是模块内变量私有化？</h3>      <p>答：只允许模块内的变量在模块内运行时被调用打印，在别的程序内无法调用此变量</p>        <h3 id="怎么实现模块内变量的私有化？"   >          <a href="#怎么实现模块内变量的私有化？" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么实现模块内变量的私有化？" class="headerlink" title="怎么实现模块内变量的私有化？"></a>怎么实现模块内变量的私有化？</h3>      <p>关键词：_变量名</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>（_变量名）</span><br></pre></td></tr></table></div></figure><p>注意：</p><p>1：上述语法执行就会报错，因为用 from 模块名 import * 导入模块时，被下划线处理的变量是无法被导入的因此报错</p><p>2：在模块内利用下划线_  处理的变量名，只有在 from 模块名 import * 时才能实现变量私有化，其他的任何导入方法都可以进行导入该变量！</p><p>图示：</p><p>模块内代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184711976.png"  alt="image-20211012184711976">      </p><p>导入模块代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184720347.png"  alt="image-20211012184720347">      </p>        <h2 id="import和from…import的区别【重点】"   >          <a href="#import和from…import的区别【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#import和from…import的区别【重点】" class="headerlink" title="import和from…import的区别【重点】"></a>import和from…import的区别【重点】</h2>      <p>目标：掌握 import 与 from …. import …. 两种导入模块方式的区别</p>        <h3 id="import-与-from-…-import-…-两种导入模块方式的区别"   >          <a href="#import-与-from-…-import-…-两种导入模块方式的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#import-与-from-…-import-…-两种导入模块方式的区别" class="headerlink" title="import 与 from …. import …. 两种导入模块方式的区别"></a>import 与 from …. import …. 两种导入模块方式的区别</h3>      <p>import导入模块：直接引用模块里面的所有内容，导入模块后对该模块内的函数、变量做出更改，那么原始模块内的数据也随之发生改变</p><p>from …. import ….导入模块：复制导入模块的所有变量、函数以及类并且拷贝到当前py文件内，不是直接引用模块内的方法等，这样对模块内的变量等进行修改后，原始模块内的数据将不发生变化！</p><p>注意事项：在掌握两种导入模块的区别之后，当遇到多个文件共享一个模块内的变量时（一个文件更改模块内容，其他文件可一接收到更改后的内容），那我们就要用到第一种导入模块的方式哦（import）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184743276.png"  alt="image-20211012184743276">      </p><p>代码：</p><p>girl模块内的代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184751624.png"  alt="image-20211012184751624">      </p>        <h2 id="可变参数的拆包问题【重点】"   >          <a href="#可变参数的拆包问题【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#可变参数的拆包问题【重点】" class="headerlink" title="可变参数的拆包问题【重点】"></a>可变参数的拆包问题【重点】</h2>              <h3 id="可变参数-args-与-kwargs-分别接受什么形式的数据？"   >          <a href="#可变参数-args-与-kwargs-分别接受什么形式的数据？" class="heading-link"><i class="fas fa-link"></i></a><a href="#可变参数-args-与-kwargs-分别接受什么形式的数据？" class="headerlink" title="可变参数 *args 与 **kwargs 分别接受什么形式的数据？"></a>可变参数 *args 与 **kwargs 分别接受什么形式的数据？</h3>      <p><code>*args</code>：将接收的数据存储在元组内</p><p>接收数据形式：a ,b,c,d,e      数据之间逗号分割</p><p><code>**kwargs</code>：将接受的数据存储到字典内<br>接受数据形式：a = 10，b = 20        赋值的方式</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184810727.png"  alt="image-20211012184810727">      </p>        <h3 id="如何将数据拆包并传递给其他函数"   >          <a href="#如何将数据拆包并传递给其他函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何将数据拆包并传递给其他函数" class="headerlink" title="如何将数据拆包并传递给其他函数"></a>如何将数据拆包并传递给其他函数</h3>      <p>首先分析出现下面问题的原因</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184824680.png"  alt="image-20211012184824680">      </p><p>问题修正</p><p>加上<code>*</code>与 <code>**</code> 可将 元组和字典拆包</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184831694.png"  alt="image-20211012184831694">      </p>        <h2 id="单继承中的super【重点】"   >          <a href="#单继承中的super【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#单继承中的super【重点】" class="headerlink" title="单继承中的super【重点】"></a>单继承中的super【重点】</h2>              <h3 id="类中的-super（）方法的作用"   >          <a href="#类中的-super（）方法的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#类中的-super（）方法的作用" class="headerlink" title="类中的 super（）方法的作用"></a>类中的 super（）方法的作用</h3>      <p>答：调用父类中的方法<br>语法：super（）. 父类方法     例如 super.（）<strong>init</strong>(参数1，参数2…..）  调用父类的初始化方法 <strong>init</strong>(参数1，参数2…..)<br>注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184831694.png" >      </p>        <h3 id="什么是-mro-序列"   >          <a href="#什么是-mro-序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是-mro-序列" class="headerlink" title="什么是__mro__序列"></a>什么是__mro__序列</h3>      <p>功能：查看目标类的父类以及祖父类等等一直向上，直到 object</p><p>语法：目标类.<strong>mro</strong></p><p>注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184855505.png"  alt="image-20211012184855505">      </p>        <h3 id="单继承类中的-super-调用父类方法是遵循-mro-序列调用的"   >          <a href="#单继承类中的-super-调用父类方法是遵循-mro-序列调用的" class="heading-link"><i class="fas fa-link"></i></a><a href="#单继承类中的-super-调用父类方法是遵循-mro-序列调用的" class="headerlink" title="单继承类中的 super 调用父类方法是遵循__mro__序列调用的"></a>单继承类中的 super 调用父类方法是遵循__mro__序列调用的</h3>      <p>代码截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184915904.png"  alt="image-20211012184915904">      </p><p>结果截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184922866.png"  alt="image-20211012184922866">      </p>        <h2 id="多继承和MRO顺序1【重点】"   >          <a href="#多继承和MRO顺序1【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#多继承和MRO顺序1【重点】" class="headerlink" title="多继承和MRO顺序1【重点】"></a>多继承和MRO顺序1【重点】</h2>      <p>注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！</p><p>目标：<br>1：掌握子类继承父类时调用父类方法的两种形式以及区别</p><p>2：掌握什么是多继承中的菱形继承（钻石继承）</p><p>2：掌握多继承中的mro顺序作用</p>        <h3 id="子类继承父类时调用父类方法的两种形式以及区别"   >          <a href="#子类继承父类时调用父类方法的两种形式以及区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#子类继承父类时调用父类方法的两种形式以及区别" class="headerlink" title="子类继承父类时调用父类方法的两种形式以及区别"></a>子类继承父类时调用父类方法的两种形式以及区别</h3>      <p>方法一：父类名.方法名（self，参数1，参数2……..）   例如 parent . <strong>init</strong>(self , name , age , gender)</p><p>方法二：super（）. 方法名（参数1，参数2…..）        例如 super（）.__init__（name，age，gender）</p><p>两种方法的区别：第一种方法继承时要传递参数 self    第二种方法不需要传递 self ！！</p><p>图示：</p><p>父类名.方法名（self，参数1，参数2……..）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184943566.png"  alt="image-20211012184943566">      </p><p>super（）. 方法名（参数1，参数2…..）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012184958749.png"  alt="image-20211012184958749">      </p>        <h3 id="什么是多继承中的菱形继承（钻石继承）"   >          <a href="#什么是多继承中的菱形继承（钻石继承）" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是多继承中的菱形继承（钻石继承）" class="headerlink" title="什么是多继承中的菱形继承（钻石继承）"></a>什么是多继承中的菱形继承（钻石继承）</h3>      <p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185007087.png"  alt="image-20211012185007087">      </p><p>注意事项：</p><p>1：出现菱形继承时，如果操作不当（利用父类名调用父类方法），可能会出现祖父类的某方法调用多次（只想调用一次），这是我们必须要用super（）继承父类方法来解决这一问题！！！</p><p>2：因此在多继承中应该尽量避免使用父类名.父类方法  这种形式调用父类的方法，会造成有的父类方法调用两次，使用super调用了完美解决</p>        <h3 id="多继承中的mro顺序作用"   >          <a href="#多继承中的mro顺序作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#多继承中的mro顺序作用" class="headerlink" title="多继承中的mro顺序作用"></a>多继承中的mro顺序作用</h3>      <p>使用语法：</p><p>1：类名.mro（）</p><p>2：类名.<strong>mro</strong></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185026156.png"  alt="image-20211012185026156">      </p><p>注意事项：</p><p>1：多继承中利用 super 调用父类的方法，不一定是调用父类的方法，而是按照多继承中的 mro 顺序来调用的</p><p>2：如果子类利用super调用父类方法，父类中没有super方法 就不会按照 mro 顺序调用方法，因此要想按照 mro 顺序调用方法，必须要求所有参与继承的家族类中都要有 super方法！</p><p>注意事项：super调用父类的方法是按照 mro 顺序来调用的，因此多继承中不一定调用的就是父类方法！！</p>        <h2 id="property装饰的基本使用【重点】"   >          <a href="#property装饰的基本使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#property装饰的基本使用【重点】" class="headerlink" title="property装饰的基本使用【重点】"></a>property装饰的基本使用【重点】</h2>              <h3 id="property装饰类中的函数的作用！"   >          <a href="#property装饰类中的函数的作用！" class="heading-link"><i class="fas fa-link"></i></a><a href="#property装饰类中的函数的作用！" class="headerlink" title="property装饰类中的函数的作用！"></a>property装饰类中的函数的作用！</h3>      <p>功能：在类中被 property 装饰后的函数，调用这个函数可像调用类中的属性一样使用（不用加括号了）！</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>（<span class="title">self</span>）</span></span><br><span class="line"><span class="function">…….</span></span><br></pre></td></tr></table></div></figure><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185104567.png"  alt="image-20211012185104567">      </p>        <h3 id="在类中使用-property-装饰的注意事项"   >          <a href="#在类中使用-property-装饰的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#在类中使用-property-装饰的注意事项" class="headerlink" title="在类中使用 property 装饰的注意事项"></a>在类中使用 property 装饰的注意事项</h3>      <p>1：装饰的类函数中必须只有一个参数self，不允许有其他的参数！</p>        <h2 id="property装饰的其他使用方法【重点】"   >          <a href="#property装饰的其他使用方法【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#property装饰的其他使用方法【重点】" class="headerlink" title="property装饰的其他使用方法【重点】"></a>property装饰的其他使用方法【重点】</h2>              <h3 id="property-装饰函数的-xxxxx-setter-形式的功能！"   >          <a href="#property-装饰函数的-xxxxx-setter-形式的功能！" class="heading-link"><i class="fas fa-link"></i></a><a href="#property-装饰函数的-xxxxx-setter-形式的功能！" class="headerlink" title="property 装饰函数的 @xxxxx.setter 形式的功能！"></a>property 装饰函数的 @xxxxx.setter 形式的功能！</h3>      <p>功能：被 @xxxxx.setter 装饰的类里面的函数可以传递参数进去</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@price.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">price</span>（）</span></span><br><span class="line"><span class="function">……..</span></span><br></pre></td></tr></table></div></figure><p>注意事项：</p><p>1：@xxxxx.setter 中的 xxxxx 是被装饰的函数名！</p><p>2：被@xxxxx.setter 装饰后的函数 通过实例对象.装饰函数名 = 参数   即可向被装饰后的函数传递参数！</p><p>3：@xxxxx.setter 这种装饰函数必须要在 property 装饰函数的基础上才能使用，也就是说类里面必须有 property装饰方法，才能使用 @xxxxx.setter ，并且这两种方法装饰的函数名一样！</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185131386.png"  alt="image-20211012185131386">      </p>        <h3 id="property-装饰函数的-xxxxx-deleter-形式的功能！"   >          <a href="#property-装饰函数的-xxxxx-deleter-形式的功能！" class="heading-link"><i class="fas fa-link"></i></a><a href="#property-装饰函数的-xxxxx-deleter-形式的功能！" class="headerlink" title="property 装饰函数的 @xxxxx.deleter 形式的功能！"></a>property 装饰函数的 @xxxxx.deleter 形式的功能！</h3>      <h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@price.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">price</span>（）</span></span><br><span class="line"><span class="function">……..</span></span><br></pre></td></tr></table></div></figure><p>代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185142289.png"  alt="image-20211012185142289">      </p>        <h2 id="prepery作为类属性的值传入【重点】"   >          <a href="#prepery作为类属性的值传入【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#prepery作为类属性的值传入【重点】" class="headerlink" title="prepery作为类属性的值传入【重点】"></a>prepery作为类属性的值传入【重点】</h2>              <h3 id="类属性与实例属性的区别"   >          <a href="#类属性与实例属性的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#类属性与实例属性的区别" class="headerlink" title="类属性与实例属性的区别"></a>类属性与实例属性的区别</h3>      <p>定义区别：实例属性是在__init__方法里面定义的属性，而类属性是在类里面并且所有方法外面定义的属性</p><p>调用区别：实例属性只能用类创建的实例调用，类属性可以用类名调用也可以用类创建的实例调用</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185202109.png"  alt="image-20211012185202109">      </p>        <h3 id="property作为类属性的值传入其中四个参数作用及其使用方法！"   >          <a href="#property作为类属性的值传入其中四个参数作用及其使用方法！" class="heading-link"><i class="fas fa-link"></i></a><a href="#property作为类属性的值传入其中四个参数作用及其使用方法！" class="headerlink" title="property作为类属性的值传入其中四个参数作用及其使用方法！"></a>property作为类属性的值传入其中四个参数作用及其使用方法！</h3>      <p>语法：类属性变量名 = property（参数1，参数2，参数3，参数4）</p><p>其中参数1到参数3都是函数名，参数4是字符串类型的值！</p><p>使用方法：</p><p>1：当写下 类对象 . 类属性变量名   会自动调用名为参数1的函数</p><p>2：当写下 类对象 . 类属性变量名 = 500  会自动调用名为参数2的函数（这个函数有参数 传递实参为500）</p><p>3：当写下 del 类对象 . 类属性变量名      会自动调用名为参数3的函数</p><p>4：当写下 类名.类属性变量名._ <em>doc</em> _   可打印参数4的值</p><p>注意事项：想打印参数4的值，要注意书写的不是类对象而是类名</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185218659.png"  alt="image-20211012185218659">      </p>        <h2 id="魔法属性和魔法方法【重点】"   >          <a href="#魔法属性和魔法方法【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔法属性和魔法方法【重点】" class="headerlink" title="魔法属性和魔法方法【重点】"></a>魔法属性和魔法方法【重点】</h2>              <h3 id="类的魔法属性-doc-的功能"   >          <a href="#类的魔法属性-doc-的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的魔法属性-doc-的功能" class="headerlink" title="类的魔法属性 _ doc _的功能"></a>类的魔法属性 _ <em>doc</em> _的功能</h3>      <p>功能：查看类的说明（注释）或者类里面方法的注释</p><p>语法：</p><p>1：类名.<strong>doc</strong>    或 类对象.<strong>doc</strong>             查看类的注释</p><p>2：类名.方法名.<strong>doc</strong>  或  类对象.方法名.<strong>doc</strong>              查看类里面方法的注释</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185237938.png"  alt="image-20211012185237938">      </p>        <h3 id="类的魔法属性-module-与-class-的功能"   >          <a href="#类的魔法属性-module-与-class-的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的魔法属性-module-与-class-的功能" class="headerlink" title="类的魔法属性 module 与 __class__的功能"></a>类的魔法属性 <strong>module</strong> 与 __class__的功能</h3>      <p>__module__功能：查看当前类所在的模块！</p><p>语法：类名.<strong>module</strong>  或   类对象.<strong>module</strong></p><p>__class__功能：查看当前对象所属的类！</p><p>语法：类对象.<strong>classes</strong></p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185248902.png"  alt="image-20211012185248902">      </p>        <h3 id="类的魔法方法-init-与-del-的功能"   >          <a href="#类的魔法方法-init-与-del-的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的魔法方法-init-与-del-的功能" class="headerlink" title="类的魔法方法 init( ) 与 del( ) 的功能"></a>类的魔法方法 <strong>init</strong>( ) 与 <strong>del</strong>( ) 的功能</h3>      <p><strong>init</strong>( )功能：初始化魔法方法，在类创建对象时自动调用的方法！注意它不是构造方法，构造方法是__new__( ) 与 <strong>init</strong>( )的统称</p><p> <strong>del</strong>( ) 功能：删除方法，当删除类创建的对象时自动调用的方法！</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185258083.png"  alt="image-20211012185258083">      </p>        <h3 id="魔术属性-dict-的功能及其使用方法"   >          <a href="#魔术属性-dict-的功能及其使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔术属性-dict-的功能及其使用方法" class="headerlink" title="魔术属性 dict 的功能及其使用方法"></a>魔术属性 <strong>dict</strong> 的功能及其使用方法</h3>      <p>功能：查看类对象的实例属性并将属性以键值对的形式存放在字典内或查看类的所有类属性（实例属性除外）和类方法存放在字典内</p><p>语法：</p><p>1：类对象 . <strong>dict</strong><br>2：类名 . <strong>dict</strong></p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185314019.png"  alt="image-20211012185314019">      </p>        <h3 id="魔法方法-call-与-str-功能及其使用方法"   >          <a href="#魔法方法-call-与-str-功能及其使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔法方法-call-与-str-功能及其使用方法" class="headerlink" title="魔法方法 call( ) 与 str( ) 功能及其使用方法"></a>魔法方法 <strong>call</strong>( ) 与 <strong>str</strong>( ) 功能及其使用方法</h3>      <p><strong>call</strong>( )功能：当实例化对象加上括号时，就会调用魔法方法__call__( )</p><p>语法：实例对象（）</p><p><strong>str</strong>( ) 功能：当打印实例化对象时，就会调用__str__( ) 魔法方法，注意__str__方法内必须要有返回值，且返回值必须是字符串类型！</p><p>语法：print（实例对象）</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185335037.png"  alt="image-20211012185335037">      </p>        <h3 id="魔法方法-getitem-key-、-setitem-key，value-、delitem-key-的调用方法"   >          <a href="#魔法方法-getitem-key-、-setitem-key，value-、delitem-key-的调用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#魔法方法-getitem-key-、-setitem-key，value-、delitem-key-的调用方法" class="headerlink" title="魔法方法 getitem( key ) 、 setitem( key，value )、delitem( key )的调用方法"></a>魔法方法 <strong>getitem</strong>( key ) 、 <strong>setitem</strong>( key，value )、<strong>delitem</strong>( key )的调用方法</h3>      <p><strong>getitem</strong>( key )调用方法：实例对象[key]      就会调用此方法</p><p> <strong>setitem</strong>( key，value )调用方法：实例对象[key] = value          就会调用此方法</p><p><strong>delitem</strong>( key )调用方法：del 实例对象[key]        就会调用此方法</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185346280.png"  alt="image-20211012185346280">      </p>        <h2 id="with管理上下文方式【重点】"   >          <a href="#with管理上下文方式【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#with管理上下文方式【重点】" class="headerlink" title="with管理上下文方式【重点】"></a>with管理上下文方式【重点】</h2>              <h3 id="利用-with-操作文件的优点"   >          <a href="#利用-with-操作文件的优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用-with-操作文件的优点" class="headerlink" title="利用 with 操作文件的优点"></a>利用 with 操作文件的优点</h3>      <p>答：与单纯的 open 打开文件相比，当 open 打开文件出现错误时，因为资源已经分配，所以对这个文件资源进行关闭操作就会失败，with 方式操作文件可有效解决这一问题！不会出现文件关闭失败的情况！</p>        <h3 id="with-操作文件的步骤！"   >          <a href="#with-操作文件的步骤！" class="heading-link"><i class="fas fa-link"></i></a><a href="#with-操作文件的步骤！" class="headerlink" title="with 操作文件的步骤！"></a>with 操作文件的步骤！</h3>      <p>第一步：执行上下文管理类里面的上文方法即 __enter__（）并且返回一个对象，也就是 as 后面的那个变量（实质是打开文件返回的对象）！</p><p>第二步：利用返回的对象对文件进行读写等操作！</p><p>第三步：执行上下文管理类里面的下文方法即 <strong>exit</strong>( ) 即关闭文件！</p><p>注意事项：</p><p>1：执行 __enter__（）上文方法返回的对象也就是 as 后面的 file ，file的实质为  file = open（“文件名”，“打开方式”）的打开文件操作的语句，而非是 open类</p><p>2：下面的注释中有一处错误就是 with open（“text.txt”，“r”） 的 open 不是一个类，而是一个上下文管理函数！！</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185403180.png"  alt="image-20211012185403180">      </p>        <h3 id="自己构建一个上下文管理器类实现读取指定文件内容"   >          <a href="#自己构建一个上下文管理器类实现读取指定文件内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#自己构建一个上下文管理器类实现读取指定文件内容" class="headerlink" title="自己构建一个上下文管理器类实现读取指定文件内容"></a>自己构建一个上下文管理器类实现读取指定文件内容</h3>      <p>什么是上下文管理器？</p><p>答：即支持 with 操作的类或者函数！</p><p>上下文管理器类包含的方法：</p><p>1：初始化方法__init__( )  用来接收参数【文件名、打开方式】</p><p>2：上文方法__enter__( ) 用来打开文件并且返回这个对象</p><p>3：下文方法__exit__( ) 用来关闭打开的文件！</p><p>注意事项：类里面如果有多个方法想共用一个变量，那么这个变量要变成实例属性的方式才行，也就是加上self</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185419418.png"  alt="image-20211012185419418">      </p>        <h3 id="利用装饰器装饰函数的方法实现-with-上下文管理操作文件（读取文件内所有数据）！"   >          <a href="#利用装饰器装饰函数的方法实现-with-上下文管理操作文件（读取文件内所有数据）！" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用装饰器装饰函数的方法实现-with-上下文管理操作文件（读取文件内所有数据）！" class="headerlink" title="利用装饰器装饰函数的方法实现 with 上下文管理操作文件（读取文件内所有数据）！"></a>利用装饰器装饰函数的方法实现 with 上下文管理操作文件（读取文件内所有数据）！</h3>      <p>实现关键字：</p><p>yield：函数内 yield上方为上文，下方为下文，调用函数时，第一次调用执行到 yield 处，第二次执行从 yield 继续执行！<br>yield有返回数据以及退出函数的功能</p><p>contextlib 库里面的装饰器 contextmanager ：利用 contextmanager 装饰器装饰写好的函数即可实现 with 上下文管理操作文件</p><p>实现步骤：</p><p>第一步：定义一个函数，传递两个参数即文件名以及文件打开方式</p><p>第二步：在函数内部打开指定文件，并用 yield 返回打开文件的对象，yield上方的也就是上文</p><p>第三步：在 yield 下方对打开的文件对象进行关闭！也就是上下文管理的下文</p><p>第四步：导入 contextlib 模块里面的装饰器 contextmanager</p><p>第五步：利用 @contextmanager 装饰写好的函数</p><p>第六步：利用 </p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 函数名（“文件名”，“打开方式”） <span class="keyword">as</span> file ：</span><br><span class="line">result = file.read（）</span><br><span class="line"><span class="built_in">print</span>（result）</span><br></pre></td></tr></table></div></figure><p>读取指定文件的所有数据</p><p>代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012185438098.png"  alt="image-20211012185438098">      </p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Python导入模块的几种方式及其注意事项、单继承与多继承、property装饰的使用、魔法属性与魔法方法、with上下文方式&lt;/p&gt;</summary>
    
    
    
    <category term="Python基础语法篇" scheme="http://pythonlamb.github.io/categories/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    
    
    <category term="Python基础语法篇" scheme="http://pythonlamb.github.io/tags/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>黑马程序员学Python——GIL锁与深浅拷贝</title>
    <link href="http://pythonlamb.github.io/2021/10/12/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6Python%E2%80%94%E2%80%94GIL%E9%94%81%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://pythonlamb.github.io/2021/10/12/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6Python%E2%80%94%E2%80%94GIL%E9%94%81%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-10-12T07:47:07.000Z</published>
    <updated>2021-10-12T08:00:34.245Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Python中的GIL锁以及怎么去解决这个问题，深浅拷贝等….</p><span id="more"></span>        <h2 id="GIL锁对多任务的影响【重点】"   >          <a href="#GIL锁对多任务的影响【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#GIL锁对多任务的影响【重点】" class="headerlink" title="GIL锁对多任务的影响【重点】"></a>GIL锁对多任务的影响【重点】</h2>              <h3 id="unubtu-系统的-htop-指令查看CUP的使用情况（百分比）"   >          <a href="#unubtu-系统的-htop-指令查看CUP的使用情况（百分比）" class="heading-link"><i class="fas fa-link"></i></a><a href="#unubtu-系统的-htop-指令查看CUP的使用情况（百分比）" class="headerlink" title="unubtu 系统的 htop 指令查看CUP的使用情况（百分比）"></a>unubtu 系统的 htop 指令查看CUP的使用情况（百分比）</h3>      <p>指令：终端输入 htop 即可</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155420672.png"  alt="image-20211012155420672">      </p>        <h3 id="单进程单线程死循环、多进程单线程死循环、多线程单进程死循环对CPU核的调用情况"   >          <a href="#单进程单线程死循环、多进程单线程死循环、多线程单进程死循环对CPU核的调用情况" class="heading-link"><i class="fas fa-link"></i></a><a href="#单进程单线程死循环、多进程单线程死循环、多线程单进程死循环对CPU核的调用情况" class="headerlink" title="单进程单线程死循环、多进程单线程死循环、多线程单进程死循环对CPU核的调用情况"></a>单进程单线程死循环、多进程单线程死循环、多线程单进程死循环对CPU核的调用情况</h3>      <p>1.单进程单线程死循环使用情况：</p><p>结论：单进程可完美利用cpu的核数</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155432451.png" >      </p><p>2.多进程单线程</p><p>结论：两个多进程死循环运行，两个cpu核利用率为百分之百，因此多进程可完美利用CPU的核数，不存在 cpu 利用不充分的问题哦！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155447877.png"  alt="image-20211012155447877">      </p><p>3.多线程单进程</p><p>结论：多个线程同时运行死循环函数，但是CPU的核却没有一个占满百分之百，可以说明多线程是伪多线程，并不能同时运行多个任务，这是因为GIL全局解释器锁的原因</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155458246.png"  alt="image-20211012155458246">      </p>        <h2 id="GIL锁的概念及影响【重点、面试点】"   >          <a href="#GIL锁的概念及影响【重点、面试点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#GIL锁的概念及影响【重点、面试点】" class="headerlink" title="GIL锁的概念及影响【重点、面试点】"></a>GIL锁的概念及影响【重点、面试点】</h2>              <h3 id="什么是GIL"   >          <a href="#什么是GIL" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h3>      <p>答：GIL称为全局解释器锁，python执行多线程任务之前，某线程会获得一把GIL，而且GIL又是一把互斥锁，某个线程执行任务调用cpu核资源时，其他线程就不能执行其他任务，只能等待GIL释放完毕才会执行任务，保证同一时间只有一个线程在使用GIL，简而言之，每个执行任务的线程都会获得一把GIL，有且整个程序只有一把GIL</p><p>注意:GIL与python语言无关，而是与cpython解释器有关，比如jpython解释器就没有这个GIL</p>        <h3 id="GIL存在的原因"   >          <a href="#GIL存在的原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#GIL存在的原因" class="headerlink" title="GIL存在的原因"></a>GIL存在的原因</h3>      <p>1：编写PYTHON的时候计算机普遍是单核cpu<br>2：不加GIL执行多线程任务容易引起资源竞争</p>        <h3 id="GIL对多任务的影响"   >          <a href="#GIL对多任务的影响" class="heading-link"><i class="fas fa-link"></i></a><a href="#GIL对多任务的影响" class="headerlink" title="GIL对多任务的影响"></a>GIL对多任务的影响</h3>      <p>多线程：造成伪多线程，实际同一时间只有一个cpu内核在轮询执行任务，保证同一时间只有一个线程可以执行任务</p><p>多进程：不会造成影响，两个进程，那就调度两个cpu内核执行这两个进程任务</p>        <h3 id="在什么时候可以释放GIL"   >          <a href="#在什么时候可以释放GIL" class="heading-link"><i class="fas fa-link"></i></a><a href="#在什么时候可以释放GIL" class="headerlink" title="在什么时候可以释放GIL"></a>在什么时候可以释放GIL</h3>      <p>1：获得全局解释器锁的线程任务执行完毕</p><p>2：获得全局解释器锁的线程超过时间片轮询时间，自动释放GIL，执行其他任务</p><p>3：I/O操作阻塞时自动释放GIL</p><p>4：获得全局解释器锁的线程执行阻塞时自动释放GIL</p><p>你问我答：因为GIL也是一把互斥锁，那么是否意味着我们在操作多线程全局变量时不用添加互斥锁了呢？</p><p>答：错误，因为无法控制GIL锁释放的时间，不能确保使用完全局变量的操作是否已经完成！</p><p>课后习题：因为GIL存在的原因，多线程相当与伪多线程，那么为什么多线程的执行效率比多线程高呢？</p><p>答：因为多线程执行任务时遇到I/O操作阻塞等原因会自动释放GIL</p>        <h2 id="GIL解决方案【重点、面试点】"   >          <a href="#GIL解决方案【重点、面试点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#GIL解决方案【重点、面试点】" class="headerlink" title="GIL解决方案【重点、面试点】"></a>GIL解决方案【重点、面试点】</h2>              <h3 id="python多线程解决GIL问题的几种方案"   >          <a href="#python多线程解决GIL问题的几种方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#python多线程解决GIL问题的几种方案" class="headerlink" title="python多线程解决GIL问题的几种方案"></a>python多线程解决GIL问题的几种方案</h3>      <p>方案一：因为GIL是 python 底层解释器 Cpython 产生的，因此可以更换其他底层解释器，例如 jpython 【不推荐】<br>不推荐原因：python默认解释器就是CPython，而不是Jpython，这肯定是有原因的</p><p>方案二：将多线程改成多进程【推荐】</p><p>优点：每一个进程都拥有一把GIL，不会因为互斥锁特性造成同一时间只有一个线程在执行任务，可以解决多线程利用 cpu 核不充分的问题</p><p>缺点：进程是资源分配的基本单元，改成多进程会消耗更多的内存资源，当计算机内存紧张是不推荐使用！</p><p>方案三：将多线程执行的任务（函数）改用 c语言代码编写，可避免GIL！</p><p>详解：python是胶水语言，将 c文件编译为 so 文件，并在python内导入 ctypes 模块即可在python内执行 c文件代码！</p><p>实现步骤：</p><p>第一步：在pycharm内创建后缀为 c 的C语言文件  new → file →文件名.c  编写c语言任务代码（多线程执行任务的代码）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155549163.png"  alt="image-20211012155549163">      </p><p>第二步：在 unubtu 终端内将后缀为 c 的文件编译为后缀为 so 的文件</p><p>指令关键字：gcc</p><p>语法：gcc  后缀为c的文件名  -shared  -o   待生成的后缀为so的文件名</p><p>注意事项：</p><p>1：待生成的后缀为so的文件名一般都是以lib三个字母开头</p><p>2：需要进入c文件所在的文件夹内才能执行此命令</p><p>3：-shares选项代表将目标文件编译为so文件</p><p>4：-o选项是用来输入的文件名选项</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155558587.png"  alt="image-20211012155558587">      </p><p>第三步：在python程序内导入 ctyes 库并导入 so 文件从而执行so文件内的多线程任务</p><p>关键语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">lib = ctypes.cdll.LoadLibrary（“./so文件名”）</span><br></pre></td></tr></table></div></figure><p>注意事项：<br>1：导入so文件时，一定要在相对位置目录导入，并且要加上 ./</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155611363.png"  alt="image-20211012155611363">      </p><p>第四步：执行代码查看cpu核的利用率判断是否解决了GIL</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155618933.png"  alt="image-20211012155618933">      </p>        <h3 id="多线程的适用场景"   >          <a href="#多线程的适用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程的适用场景" class="headerlink" title="多线程的适用场景"></a>多线程的适用场景</h3>      <p>适用场景：I/O密集型可使用多线程（GIL锁会释放）<br>不适用场景：CPU密集型不建议使用多线程（CPU利用率不高）</p>        <h2 id="python可变与不可变【重点】"   >          <a href="#python可变与不可变【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#python可变与不可变【重点】" class="headerlink" title="python可变与不可变【重点】"></a>python可变与不可变【重点】</h2>              <h3 id="python中可变与不可变数据类型的分类以及区别"   >          <a href="#python中可变与不可变数据类型的分类以及区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#python中可变与不可变数据类型的分类以及区别" class="headerlink" title="python中可变与不可变数据类型的分类以及区别"></a>python中可变与不可变数据类型的分类以及区别</h3>      <p>可变数据类型：列表、字典</p><p>不可变数据类型：数字、字符串、元组</p><p>可变与不可变数据类型的区别：</p><p>答：</p><p>1.可变数据类型在内存创建变量后，如果这个变量发生改变（增加数据等），内存不会开辟新的空间来存放变化后的数据，而是在原位置增加内存空间用来存放变化后的数据</p><p>2.不可变数据类型在内存创建变量后，如果这个变量发生变化，内存会开辟一块新的空间用来存放变化后的数据，而这个变量也会执行这个新的内存地址</p><p>简而言之：可变数据类型在发生变化后，不会在内存中开辟新地址存放数据，不可变数据类型在数据发生变化后，会开辟新的内存地址存放数据，并且原地址数据会被内存释放掉</p><p>注意事项：</p><p>1：变量名指向的是变量的内存地址</p><p>2：可变与不可变是数据发生改变后内存地址是否发生变化</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155709565.png"  alt="image-20211012155709565">      </p>        <h3 id="怎么用python代码验证可变与不可变数据类型"   >          <a href="#怎么用python代码验证可变与不可变数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么用python代码验证可变与不可变数据类型" class="headerlink" title="怎么用python代码验证可变与不可变数据类型"></a>怎么用python代码验证可变与不可变数据类型</h3>      <p>关键字：id（变量名）</p><p>方法：通过对比数据发生变化前后的内存地址变化从而确定是否为可变数据类型</p><p>代码演示：</p><p>不可变数据类型</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155721184.png"  alt="image-20211012155721184">      </p><p>可变数据类型</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155728120.png"  alt="image-20211012155728120">      </p>        <h2 id="数据的浅拷贝与深拷贝区别【重中之重】"   >          <a href="#数据的浅拷贝与深拷贝区别【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据的浅拷贝与深拷贝区别【重中之重】" class="headerlink" title="数据的浅拷贝与深拷贝区别【重中之重】"></a>数据的浅拷贝与深拷贝区别【重中之重】</h2>              <h3 id="数据的深浅拷贝区别"   >          <a href="#数据的深浅拷贝区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据的深浅拷贝区别" class="headerlink" title="数据的深浅拷贝区别"></a>数据的深浅拷贝区别</h3>      <p>浅拷贝：只拷贝数据的内存地址（引用），不会开辟新的内存空间，不能保证数据的独立性，如果拷贝的是对象【列表的嵌套】，原对象和copy对象都指向于同一个内存空间，不会拷贝对象内部的子对象</p><p>深拷贝：拷贝后会开辟新的内存空间存放拷贝后的数据，如果拷贝的是对象【列表的嵌套】，原对象和copy对象指向不同的内存空间，会拷贝对象及其子对象</p><p>注意事项：上述的深浅拷贝只是相对的，有些数据类型不能保证其正确性，比如简单可变数据类型（列表）的浅拷贝就会产生新的内存空间！</p>        <h3 id="python怎么实现深浅拷贝"   >          <a href="#python怎么实现深浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#python怎么实现深浅拷贝" class="headerlink" title="python怎么实现深浅拷贝"></a>python怎么实现深浅拷贝</h3>      <p>关键字：</p><p>浅拷贝：copy（变量名）</p><p>深拷贝：deepcopy（变量名）</p><p>语法：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list2 = copy.copy(list1)        浅拷贝</span><br><span class="line">list3 = copy.deepcopy（list1）  深拷贝</span><br></pre></td></tr></table></div></figure><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155801753.png"  alt="image-20211012155801753">      </p>        <h2 id="简单可变类型深浅拷贝【重点】"   >          <a href="#简单可变类型深浅拷贝【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单可变类型深浅拷贝【重点】" class="headerlink" title="简单可变类型深浅拷贝【重点】"></a>简单可变类型深浅拷贝【重点】</h2>              <h3 id="简单可变类型（列表）的深浅拷贝特点"   >          <a href="#简单可变类型（列表）的深浅拷贝特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单可变类型（列表）的深浅拷贝特点" class="headerlink" title="简单可变类型（列表）的深浅拷贝特点"></a>简单可变类型（列表）的深浅拷贝特点</h3>      <p>列表浅拷贝特点：产生新的内存空间，原列表与拷贝后的列表数据是相互独立的（互不影响），这与浅拷贝定义是不一样的一定要注意</p><p>列表深拷贝特点：产生新的内存空间，原列表与拷贝后的列表数据是相互独立的（互不影响）</p><p>注意事项：</p><p>1：浅拷贝的定义是 对原数据进行拷贝不会产生新的内存空间，只是对原数据地址的拷贝，但是列表的浅拷贝却产生了新的内存空间</p><p>2：拷贝后产生新的内存空间就是两个数据的内存地址不一样</p><p>图示：</p><p>浅拷贝</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155819140.png"  alt="image-20211012155819140">      </p><p>深拷贝</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155825294.png"  alt="image-20211012155825294">      </p>        <h2 id="复杂可变类型深浅拷贝【重点】"   >          <a href="#复杂可变类型深浅拷贝【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂可变类型深浅拷贝【重点】" class="headerlink" title="复杂可变类型深浅拷贝【重点】"></a>复杂可变类型深浅拷贝【重点】</h2>              <h3 id="复杂可变类型【列表的嵌套】的深浅拷贝的区别"   >          <a href="#复杂可变类型【列表的嵌套】的深浅拷贝的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂可变类型【列表的嵌套】的深浅拷贝的区别" class="headerlink" title="复杂可变类型【列表的嵌套】的深浅拷贝的区别"></a>复杂可变类型【列表的嵌套】的深浅拷贝的区别</h3>      <p>注意：列表的嵌套可看做是一个对象，这样就更好的理解深浅拷贝定义的后两句话了！</p><p>列表的嵌套浅拷贝：A是一个列表的嵌套对象，其中的子列表地址指向的是原列表的地址，相当于地址的引用，对A列表对象进行浅复制会产生新的内存空间，但是A列表内的子列表经过浅复制后不会产生新的空间，依旧是原列表地址的引用，因此对原列表数据进行更改，浅复制后的数据将发生变化！！</p><p>简而言之：浅拷贝不会拷贝嵌套列表的子列表，只拷贝了地址（引用子列表）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155839315.png"  alt="image-20211012155839315">      </p><p>代码演示：</p><p>注意：下面代码没有演示对A列表数据改变，观察C[0]与D[0]的数据变化   结果是也变化</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155847748.png"  alt="image-20211012155847748">      </p><p>列表的嵌套深拷贝：对嵌套的列表进行深复制会产生新的内存空间，并且嵌套的字列表也会产生新的内存空间，不再是地址的引用复制，这样对原数据进行更改，深复制后的数据将不再发生变化</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155856726.png"  alt="image-20211012155856726">      </p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155903218.png"  alt="image-20211012155903218">      </p>        <h2 id="简单不可变类型深浅拷贝【重点】"   >          <a href="#简单不可变类型深浅拷贝【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单不可变类型深浅拷贝【重点】" class="headerlink" title="简单不可变类型深浅拷贝【重点】"></a>简单不可变类型深浅拷贝【重点】</h2>              <h3 id="简单不可变数据类型（元组）的深浅拷贝"   >          <a href="#简单不可变数据类型（元组）的深浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单不可变数据类型（元组）的深浅拷贝" class="headerlink" title="简单不可变数据类型（元组）的深浅拷贝"></a>简单不可变数据类型（元组）的深浅拷贝</h3>      <p>答：简单可变数据类型（元组）不管是深拷贝还是浅拷贝都不会产生新的内存空间，只是单纯的拷贝地址（引用源对象），拷贝前后的数据也不是相互独立的</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155911751.png"  alt="image-20211012155911751">      </p>        <h2 id="复杂不不可变类型深浅拷贝【重点】"   >          <a href="#复杂不不可变类型深浅拷贝【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂不不可变类型深浅拷贝【重点】" class="headerlink" title="复杂不不可变类型深浅拷贝【重点】"></a>复杂不不可变类型深浅拷贝【重点】</h2>      <p>目标：掌握复杂不可变类型（元组内嵌套列表）的深浅拷贝对比</p>        <h3 id="复杂不可变类型（元组内嵌套列表）的深浅拷贝对比"   >          <a href="#复杂不可变类型（元组内嵌套列表）的深浅拷贝对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂不可变类型（元组内嵌套列表）的深浅拷贝对比" class="headerlink" title="复杂不可变类型（元组内嵌套列表）的深浅拷贝对比"></a>复杂不可变类型（元组内嵌套列表）的深浅拷贝对比</h3>      <p>元组内嵌套列表的浅拷贝：浅拷贝后元组不会产生新的内存空间，并且元组内嵌套的列表也不会产生新的内存空间，只是单纯的拷贝地址，原对象的引用！浅拷贝前后的数据也不是相互独立的！</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155924656.png"  alt="image-20211012155924656">      </p><p>元组内嵌套列表的深拷贝：元组深拷贝之后会产生新的内存空间存放复制后的元组，并且元组内的列表也会开辟新的内存空间，不再是单纯的地址复制，这点从复制前后列表的地址不同可看出，而且复制后两个元组的数据是相互独立的（更改原元组内列表的数据，复制的元组列表内数据不会发生变化）</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155937171.png"  alt="image-20211012155937171">      </p><p>重点：</p><p>1：复杂不可变类型数据（元组内嵌套数据）的深拷贝，如果元组内嵌套的是可变数据类型（列表）就会开辟新的内存空间保存可变的嵌套数据，如果嵌套的是不可变数据类型（元组），则不会开辟新的内存空间存放嵌套的数据！</p><p>2：复杂不可变类型数据（元组内嵌套数据）的浅拷贝，不管元组内嵌套的是可变还是不可变数据类型，都不会开辟新的内存空间，直接内存地址的引用，类似于超链接</p>        <h2 id="切片拷贝、字典拷贝【重点】"   >          <a href="#切片拷贝、字典拷贝【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#切片拷贝、字典拷贝【重点】" class="headerlink" title="切片拷贝、字典拷贝【重点】"></a>切片拷贝、字典拷贝【重点】</h2>              <h3 id="简单可变数据类型（列表）的切片拷贝是深拷贝还是浅拷贝"   >          <a href="#简单可变数据类型（列表）的切片拷贝是深拷贝还是浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单可变数据类型（列表）的切片拷贝是深拷贝还是浅拷贝" class="headerlink" title="简单可变数据类型（列表）的切片拷贝是深拷贝还是浅拷贝"></a>简单可变数据类型（列表）的切片拷贝是深拷贝还是浅拷贝</h3>      <p>切片拷贝示例代码：</p><p>list1 = [1,2,3]</p><p>list2 = list1[ : ]</p><p>list2就是list2的切片拷贝</p><p>实验结论：简单可变数据类型（列表）的切片拷贝是深拷贝</p><p>代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012155954539.png"  alt="image-20211012155954539">      </p>        <h3 id="复杂不可变数据类型（元组内嵌套列表）的切片拷贝是深拷贝还是浅拷贝"   >          <a href="#复杂不可变数据类型（元组内嵌套列表）的切片拷贝是深拷贝还是浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂不可变数据类型（元组内嵌套列表）的切片拷贝是深拷贝还是浅拷贝" class="headerlink" title="复杂不可变数据类型（元组内嵌套列表）的切片拷贝是深拷贝还是浅拷贝"></a>复杂不可变数据类型（元组内嵌套列表）的切片拷贝是深拷贝还是浅拷贝</h3>      <p>结论：是浅拷贝</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012160004682.png"  alt="image-20211012160004682">      </p>        <h3 id="简单可变数据类型（字典）的字典拷贝是深拷贝还是浅拷贝"   >          <a href="#简单可变数据类型（字典）的字典拷贝是深拷贝还是浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单可变数据类型（字典）的字典拷贝是深拷贝还是浅拷贝" class="headerlink" title="简单可变数据类型（字典）的字典拷贝是深拷贝还是浅拷贝"></a>简单可变数据类型（字典）的字典拷贝是深拷贝还是浅拷贝</h3>      <p>关键字：copy</p><p>语法：dict2 = dict1.copy（）</p><p>注意事项：字典拷贝不需要导入 copy 模块即可使用 copy 方法</p><p>结论：简单可变数据类型（字典）的字典拷贝是深拷贝</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012160018221.png"  alt="image-20211012160018221">      </p>        <h3 id="复杂可变数据类型（字典内嵌套列表）的字典拷贝是深拷贝还是浅拷贝"   >          <a href="#复杂可变数据类型（字典内嵌套列表）的字典拷贝是深拷贝还是浅拷贝" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂可变数据类型（字典内嵌套列表）的字典拷贝是深拷贝还是浅拷贝" class="headerlink" title="复杂可变数据类型（字典内嵌套列表）的字典拷贝是深拷贝还是浅拷贝"></a>复杂可变数据类型（字典内嵌套列表）的字典拷贝是深拷贝还是浅拷贝</h3>      <p>结论：复杂可变数据类型（字典内嵌套列表）的字典拷贝是浅拷贝</p><p>代码图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012160030517.png"  alt="image-20211012160030517">      </p><p>未完待续…….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Python中的GIL锁以及怎么去解决这个问题，深浅拷贝等….&lt;/p&gt;</summary>
    
    
    
    <category term="Python基础语法篇" scheme="http://pythonlamb.github.io/categories/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    
    
    <category term="Python基础语法篇" scheme="http://pythonlamb.github.io/tags/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>黑马程序员学Python——装饰器基础</title>
    <link href="http://pythonlamb.github.io/2021/10/12/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6Python%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://pythonlamb.github.io/2021/10/12/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6Python%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E7%A1%80/</id>
    <published>2021-10-12T07:34:32.000Z</published>
    <updated>2021-10-12T07:46:15.716Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：闭包的概念，装饰器入门、类装饰器、多重装饰器等等….</p><span id="more"></span>        <h2 id="闭包基础【重点】"   >          <a href="#闭包基础【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#闭包基础【重点】" class="headerlink" title="闭包基础【重点】"></a>闭包基础【重点】</h2>              <h3 id="将函数名赋值给变量并且打印，会打印出什么"   >          <a href="#将函数名赋值给变量并且打印，会打印出什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#将函数名赋值给变量并且打印，会打印出什么" class="headerlink" title="将函数名赋值给变量并且打印，会打印出什么"></a>将函数名赋值给变量并且打印，会打印出什么</h3>      <p>答：函数变量名保存的是这个函数在内存中存储的十六进制的地址</p><p>注意事项：函数名只是函数地址的一个引用，也就是一个变量  它可以赋值给其他变量，也可以被其他值赋值</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154150057.png"  alt="image-20211012154150057">      </p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154157111.png"  alt="image-20211012154157111">      </p>        <h3 id="了解函数的闭包"   >          <a href="#了解函数的闭包" class="heading-link"><i class="fas fa-link"></i></a><a href="#了解函数的闭包" class="headerlink" title="了解函数的闭包"></a>了解函数的闭包</h3>      <p>闭包概念：在一个外函数中定义一个内函数，内函数里运用了外函数的临时变量，并且外函数返回值是内函数的函数名（引用）</p><p>函数形成闭包的条件：</p><p>1：在外函数内部又定义了一个内函数</p><p>2：内函数可以引用（使用）外部函数的临时变量（内部函数引用外部变量）</p><p>3：外部函数返回值是内部函数的引用（函数名）</p><p>图示：</p><p>注意：下面代码的result（10，20）  不指定参数10，也是可以打印10 的，因为这个参数定义的形参就是和外部函数一致的</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154211238.png"  alt="image-20211012154211238">      </p>        <h2 id="闭包中的变量问题【重点】"   >          <a href="#闭包中的变量问题【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#闭包中的变量问题【重点】" class="headerlink" title="闭包中的变量问题【重点】"></a>闭包中的变量问题【重点】</h2>              <h3 id="闭包中变量使用的一些问题"   >          <a href="#闭包中变量使用的一些问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#闭包中变量使用的一些问题" class="headerlink" title="闭包中变量使用的一些问题"></a>闭包中变量使用的一些问题</h3>      <p>问题图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154222272.png"  alt="image-20211012154222272">      </p><p>解决办法：</p><p>在内部函数打印前提前声明 num 变量不使用内部函数的nun即可！</p><p>关键字：nonlocal</p><p>图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154232949.png"  alt="image-20211012154232949">      </p>        <h2 id="装饰器入门【面试点】"   >          <a href="#装饰器入门【面试点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器入门【面试点】" class="headerlink" title="装饰器入门【面试点】"></a>装饰器入门【面试点】</h2>              <h3 id="python内装饰器的使用场景"   >          <a href="#python内装饰器的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#python内装饰器的使用场景" class="headerlink" title="python内装饰器的使用场景"></a>python内装饰器的使用场景</h3>      <p>答：装饰器可以在不改变函数源代码的前提下为函数增加新的功能</p><p>装饰器的使用前提：</p><p>1：有一个待扩展功能的普通函数（不改变这个函数的源代码增加新功能）</p><p>2：装饰器要依赖于闭包才能实现扩展新功能（用于扩展函数新的功能）</p>        <h3 id="工作写代码的准则"   >          <a href="#工作写代码的准则" class="heading-link"><i class="fas fa-link"></i></a><a href="#工作写代码的准则" class="headerlink" title="工作写代码的准则"></a>工作写代码的准则</h3>      <p>答：掌握开放封闭原则，即以前写好的功能尽量不要修改其源代码（封闭），但是可以对以前写的功能进行扩展也就是开放（装饰器）</p>        <h3 id="装饰器的语法及使用依赖和使用方法"   >          <a href="#装饰器的语法及使用依赖和使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器的语法及使用依赖和使用方法" class="headerlink" title="装饰器的语法及使用依赖和使用方法"></a>装饰器的语法及使用依赖和使用方法</h3>      <p>语法：@闭包内的外层函数名</p><p>示例：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@function_out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>( ):</span></span><br><span class="line">xxxx</span><br><span class="line">Xxxx</span><br></pre></td></tr></table></div></figure><p>其中function_out是闭包中的外层函数名，test（）是待扩展功能的普通函数</p><p>使用依赖：</p><p>1：必须要有一个待扩展功能的函数</p><p>2：必须要有一个闭包，为待扩展函数在不修改源代码的前提下增加功能</p><p>3：在装饰器模式下，原来的闭包就被称为装饰器了</p><p>注意事项：</p><p>1：闭包的外层函数必须要有参数，用于待扩展函数的函数名传递</p><p>2：上方的 @function_out 等价于 test = function_out(test)</p><p>使用方法图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154304559.png"  alt="image-20211012154304559">      </p><p>注意事项：</p><p>1：test = function_out(test) 前后两个test代表的函数地址是不一样的  前面test代表的是闭包内层函数的地址，后面test代表的是test函数的内存地址！</p><p>2：闭包内的 func（）函数执行的就是待扩展的函数 test（）</p>        <h2 id="装饰器装饰有参数的函数【应用】"   >          <a href="#装饰器装饰有参数的函数【应用】" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器装饰有参数的函数【应用】" class="headerlink" title="装饰器装饰有参数的函数【应用】"></a>装饰器装饰有参数的函数【应用】</h2>              <h3 id="装饰器如何装饰有不可变参数的函数"   >          <a href="#装饰器如何装饰有不可变参数的函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器如何装饰有不可变参数的函数" class="headerlink" title="装饰器如何装饰有不可变参数的函数"></a>装饰器如何装饰有不可变参数的函数</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154317998.png"  alt="image-20211012154317998">      </p>        <h3 id="装饰器如何装饰有可变参数的函数"   >          <a href="#装饰器如何装饰有可变参数的函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器如何装饰有可变参数的函数" class="headerlink" title="装饰器如何装饰有可变参数的函数"></a>装饰器如何装饰有可变参数的函数</h3>      <p>答：function_in（闭包的内层函数参数）函数与 func 函数的参数设置同名！</p>        <h3 id="图示分析"   >          <a href="#图示分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#图示分析" class="headerlink" title="图示分析"></a>图示分析</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154328310.png"  alt="image-20211012154328310">      </p>        <h2 id="装饰有返回值的函数【应用】"   >          <a href="#装饰有返回值的函数【应用】" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰有返回值的函数【应用】" class="headerlink" title="装饰有返回值的函数【应用】"></a>装饰有返回值的函数【应用】</h2>              <h3 id="如何装饰有返回值的函数"   >          <a href="#如何装饰有返回值的函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何装饰有返回值的函数" class="headerlink" title="如何装饰有返回值的函数"></a>如何装饰有返回值的函数</h3>      <p>目标需求：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154344345.png"  alt="image-20211012154344345">      </p><p>实现代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154351297.png"  alt="image-20211012154351297">      </p>        <h2 id="实现通用版装饰器【重点】"   >          <a href="#实现通用版装饰器【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现通用版装饰器【重点】" class="headerlink" title="实现通用版装饰器【重点】"></a>实现通用版装饰器【重点】</h2>              <h3 id="装饰器通用版的模板是什么样的！（既能传递参数也能有返回值）"   >          <a href="#装饰器通用版的模板是什么样的！（既能传递参数也能有返回值）" class="heading-link"><i class="fas fa-link"></i></a><a href="#装饰器通用版的模板是什么样的！（既能传递参数也能有返回值）" class="headerlink" title="装饰器通用版的模板是什么样的！（既能传递参数也能有返回值）"></a>装饰器通用版的模板是什么样的！（既能传递参数也能有返回值）</h3>      <p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154408237.png"  alt="image-20211012154408237">      </p>        <h2 id="在装饰器外部设置变量（定义函数）【理解】"   >          <a href="#在装饰器外部设置变量（定义函数）【理解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#在装饰器外部设置变量（定义函数）【理解】" class="headerlink" title="在装饰器外部设置变量（定义函数）【理解】"></a>在装饰器外部设置变量（定义函数）【理解】</h2>              <h3 id="如何在装饰器外部设置变量（定义函数）"   >          <a href="#如何在装饰器外部设置变量（定义函数）" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何在装饰器外部设置变量（定义函数）" class="headerlink" title="如何在装饰器外部设置变量（定义函数）"></a>如何在装饰器外部设置变量（定义函数）</h3>      <p>答：即在装饰器（原始闭包）的外部再次定义一个函数并且返回原装饰器外层函数的函数名</p><p>注意事项：设置装饰器外部变量看着像是创造了装饰器，因此这种语法模式也被称为装饰器工厂模式</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154420691.png"  alt="image-20211012154420691">      </p>        <h3 id="怎么使用设置外部变量后的装饰器！"   >          <a href="#怎么使用设置外部变量后的装饰器！" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么使用设置外部变量后的装饰器！" class="headerlink" title="怎么使用设置外部变量后的装饰器！"></a>怎么使用设置外部变量后的装饰器！</h3>      <p>关键字：@设置的外部变量函数名（参数）      例如   @variable（“haha”）</p><p>注意：@variable（“haha”）  分为三步从而达到调用装饰器的目的</p><p>第一步：先执行  variable（“haha”）函数</p><p>第二步：执行   @第一步函数的返回值  例如 @function_out</p><p>第三步：正常执行装饰器的步骤</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154442599.png"  alt="image-20211012154442599">      </p>        <h3 id="不设置外部变量的装饰器与设置外部变量装饰器的区别"   >          <a href="#不设置外部变量的装饰器与设置外部变量装饰器的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#不设置外部变量的装饰器与设置外部变量装饰器的区别" class="headerlink" title="不设置外部变量的装饰器与设置外部变量装饰器的区别"></a>不设置外部变量的装饰器与设置外部变量装饰器的区别</h3>      <p>答：装饰器的调用一定要注意区别</p><p>例如 @ viriable（“lala”）  与  @viriable   有参数和没参数就天差地别</p><p>注意：装饰器的调用有参数就说明这个装饰器设置了外部变量，没有参数就没有设置外部变量！</p>        <h2 id="多重装饰器【面试点】"   >          <a href="#多重装饰器【面试点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#多重装饰器【面试点】" class="headerlink" title="多重装饰器【面试点】"></a>多重装饰器【面试点】</h2>              <h3 id="什么是多重装饰器？"   >          <a href="#什么是多重装饰器？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是多重装饰器？" class="headerlink" title="什么是多重装饰器？"></a>什么是多重装饰器？</h3>      <p>答：多重装饰器就是多个装饰器（闭包）装饰一个待扩展的函数</p>        <h3 id="多重装饰器的工作流程"   >          <a href="#多重装饰器的工作流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#多重装饰器的工作流程" class="headerlink" title="多重装饰器的工作流程"></a>多重装饰器的工作流程</h3>      <p>实例：</p><p>@ 第一个闭包外层函数名         → 这是第一个装饰器</p><p>@ 第二个闭包外层函数名         → 这是第二个装饰器</p><p>待扩展函数                              → 这是待装饰的函数</p><p>工作流程：函数从上向下开始执行 执行到第一个装饰器之后因为装饰器下面没有函数因此先停止装饰，第二个装饰器开始装饰下面的待扩展函数装饰完毕后第一个装饰器再装饰已经被第二个装饰器扩展完毕的函数！</p><p>也就是第二个装饰器装饰函数  →  第一个装饰器装饰被第二个装饰器扩展的函数！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154520715.png"  alt="image-20211012154520715">      </p>        <h3 id="多重装饰器的工作步骤（具体观看视频-p204）"   >          <a href="#多重装饰器的工作步骤（具体观看视频-p204）" class="heading-link"><i class="fas fa-link"></i></a><a href="#多重装饰器的工作步骤（具体观看视频-p204）" class="headerlink" title="多重装饰器的工作步骤（具体观看视频 p204）"></a>多重装饰器的工作步骤（具体观看视频 p204）</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154528084.png"  alt="image-20211012154528084">      </p>        <h2 id="类装饰器【重点】"   >          <a href="#类装饰器【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#类装饰器【重点】" class="headerlink" title="类装饰器【重点】"></a>类装饰器【重点】</h2>              <h3 id="为一个类创建的对象加上括号会发生什么？"   >          <a href="#为一个类创建的对象加上括号会发生什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为一个类创建的对象加上括号会发生什么？" class="headerlink" title="为一个类创建的对象加上括号会发生什么？"></a>为一个类创建的对象加上括号会发生什么？</h3>      <p>答：为一个类创建的对象加上括号会调用这个类中的 <strong>call</strong> 方法</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154539853.png"  alt="image-20211012154539853">      </p>        <h3 id="什么是类装饰器"   >          <a href="#什么是类装饰器" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是类装饰器" class="headerlink" title="什么是类装饰器"></a>什么是类装饰器</h3>      <p>答：正常装饰器的扩展体是一个闭包，而类装饰器的扩展体是一个类！</p>        <h3 id="怎么使用类装饰器"   >          <a href="#怎么使用类装饰器" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么使用类装饰器" class="headerlink" title="怎么使用类装饰器"></a>怎么使用类装饰器</h3>      <p>关键字：@类名     例如  @Test</p><p>使用方法：在待扩展函数前面加上@类名   即可实现利用类装饰器装饰函数的功能</p><p>实例：</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tset</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ceshi</span>( ):</span></span><br><span class="line">Xxx</span><br><span class="line">Xxx</span><br><span class="line">Xxx</span><br></pre></td></tr></table></div></figure><p>注意事项：</p><p>1：上面示例的 @Test  等价于  ceshi = Test（ceshi）</p><p>2：实例化的对象加上括号就会调用类里面的 <strong>call</strong>( )方法</p><p>3：类装饰器中的类必须包含两种方法，<strong>init</strong>( ) 与 <strong>call</strong>( ) 方法，而且 <strong>init</strong>( ) 方法必须接收 待扩展的函数名！并且初始化 例如 self.func = func   <strong>call</strong>( )方法内必须要执行 self.func（）才能达到装饰函数的目的</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012154600352.png"  alt="image-20211012154600352">      </p>        <h2 id="数据库的主从配置【了解】"   >          <a href="#数据库的主从配置【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的主从配置【了解】" class="headerlink" title="数据库的主从配置【了解】"></a>数据库的主从配置【了解】</h2>              <h3 id="数据库的主从配置使用场景"   >          <a href="#数据库的主从配置使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的主从配置使用场景" class="headerlink" title="数据库的主从配置使用场景"></a>数据库的主从配置使用场景</h3>      <p>答：当我们做一个项目时，一台服务器上的数据库保存着大量重要的数据，这时为了避免这个地区断电或者其他原因造成这个数据库（主服务器）不能正常访问，我们就可以访问从服务器，避免事故</p><p>注意事项：</p><p>1：主服务器与从服务器是即时通信的，主服务器上数据发生变化，会通过二进制报文与从服务器进行通信，从服务器可以实时更新数据</p><p>2：主服务器与从服务器的数据库版本以及环境要一模一样，否则不能建立通信</p><p>3：主服务器与从服务器不要放在同一地区</p><p>​        </p>        <h3 id="数据库主从配置的配置步骤"   >          <a href="#数据库主从配置的配置步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库主从配置的配置步骤" class="headerlink" title="数据库主从配置的配置步骤"></a>数据库主从配置的配置步骤</h3>      <p>请去浏览器搜索查看步骤！</p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：闭包的概念，装饰器入门、类装饰器、多重装饰器等等….&lt;/p&gt;</summary>
    
    
    
    <category term="Python基础语法篇" scheme="http://pythonlamb.github.io/categories/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    
    
    <category term="Python基础语法篇" scheme="http://pythonlamb.github.io/tags/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Mysql操作——数据库高级</title>
    <link href="http://pythonlamb.github.io/2021/10/12/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/"/>
    <id>http://pythonlamb.github.io/2021/10/12/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/</id>
    <published>2021-10-12T07:23:29.000Z</published>
    <updated>2021-10-12T07:33:11.274Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Mysql数据库中的高级操作，例如建立与删除索引、管理用户等……</p><span id="more"></span>        <h2 id="数据库索引——建立和删除索引【重点】"   >          <a href="#数据库索引——建立和删除索引【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库索引——建立和删除索引【重点】" class="headerlink" title="数据库索引——建立和删除索引【重点】"></a>数据库索引——建立和删除索引【重点】</h2>              <h3 id="数据库索引的应用场景"   >          <a href="#数据库索引的应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库索引的应用场景" class="headerlink" title="数据库索引的应用场景"></a>数据库索引的应用场景</h3>      <p>答：假设数据库内有大量数据时，我们要查找某一行数据，为这个数据字段加上索引会大大的提高查询效率，提高查询速度！</p><p>索引在数据库内的保存机制是平衡查询树机制，即 B+tree</p>        <h3 id="怎么在数据库内创建索引"   >          <a href="#怎么在数据库内创建索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么在数据库内创建索引" class="headerlink" title="怎么在数据库内创建索引"></a>怎么在数据库内创建索引</h3>      <p>语法：</p><p>1：create index 索引名称 on 数据表名（字段名（长度））</p><p>2：create index 索引名称 on 数据表名（字段名）</p><p>注意事项：</p><p>1：如果数据库内是唯一索引，索引名称按照 unip_字段名称 来命名，非唯一索引按照 idx_字段名称来命名</p><p>2：索引名称必须全部为小写</p><p>3：如果需要加索引的那个字段是字符串类型，那么在创建索引时要加上这个字段的最大长度，例如 varchar（10），就要加上10</p><p>4：单张表中索引数量不超过5个</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153012185.png"  alt="image-20211012153012185">      </p>        <h3 id="怎么查看数据库内的索引"   >          <a href="#怎么查看数据库内的索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查看数据库内的索引" class="headerlink" title="怎么查看数据库内的索引"></a>怎么查看数据库内的索引</h3>      <p>语法：show  index from 数据表名</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153021236.png"  alt="image-20211012153021236">      </p>        <h3 id="怎么删除数据库的索引"   >          <a href="#怎么删除数据库的索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么删除数据库的索引" class="headerlink" title="怎么删除数据库的索引"></a>怎么删除数据库的索引</h3>      <p>语法：drop index 索引名称 on 数据表</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153029769.png"  alt="image-20211012153029769">      </p>        <h2 id="数据库索引——插入10万条数据"   >          <a href="#数据库索引——插入10万条数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库索引——插入10万条数据" class="headerlink" title="数据库索引——插入10万条数据"></a>数据库索引——插入10万条数据</h2>              <h3 id="怎么在-python-端向数据库插入100000-条数据"   >          <a href="#怎么在-python-端向数据库插入100000-条数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么在-python-端向数据库插入100000-条数据" class="headerlink" title="怎么在 python 端向数据库插入100000 条数据"></a>怎么在 python 端向数据库插入100000 条数据</h3>      <p>答：利用 for 循环</p><p>代码：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153041798.png"  alt="image-20211012153041798">      </p>        <h2 id="数据库索引——验证索引效率【重点】"   >          <a href="#数据库索引——验证索引效率【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库索引——验证索引效率【重点】" class="headerlink" title="数据库索引——验证索引效率【重点】"></a>数据库索引——验证索引效率【重点】</h2>              <h3 id="如何验证数据库插入索引后查询某条数据的效率会提升！"   >          <a href="#如何验证数据库插入索引后查询某条数据的效率会提升！" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何验证数据库插入索引后查询某条数据的效率会提升！" class="headerlink" title="如何验证数据库插入索引后查询某条数据的效率会提升！"></a>如何验证数据库插入索引后查询某条数据的效率会提升！</h3>      <p>答：利用 mysql 数据库内置的SQL语句耗时监视方法 —— profiling （耗时监视方法）</p><p>验证步骤：</p><p>第一步：打开 SQL语句耗时监视方法 即 set profiling = 1 ；</p><p>第二步：执行查询某条数据的SQL语句 例如 select * from indes_ceshi where title = “haha_99999”；</p><p>第三步：为要查询的数据字段加上索引再次查询第二步相同的数据</p><p>第四步：执行显示耗时语句 即 show profiles；</p><p>第五步：对比耗时，看加入索引是否提升了效率</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153103669.png"  alt="image-20211012153103669">      </p>        <h2 id="用户管理【重点】"   >          <a href="#用户管理【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户管理【重点】" class="headerlink" title="用户管理【重点】"></a>用户管理【重点】</h2>              <h3 id="Mysql用户的应用场景"   >          <a href="#Mysql用户的应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql用户的应用场景" class="headerlink" title="Mysql用户的应用场景"></a>Mysql用户的应用场景</h3>      <p>答：就像做公众号一样，多人团队协作，创建其他用户并分配一些权限用于多人协作，每一个用户有自己的职责</p>        <h3 id="怎么查看指定数据库的所有用户"   >          <a href="#怎么查看指定数据库的所有用户" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查看指定数据库的所有用户" class="headerlink" title="怎么查看指定数据库的所有用户"></a>怎么查看指定数据库的所有用户</h3>      <p>第一步：利用 root 用户登录数据库，并且进入默认创建的 mysql 数据库，即 use mysql；</p><p>第二步：利用 desc 查看 user 数据表内的字段结构 即desc user；</p><p>第三步：利用 select 查看用户、主机等字段信息，即 select host，host  from user；</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153124479.png"  alt="image-20211012153124479">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153133021.png"  alt="image-20211012153133021">      </p>        <h3 id="怎么创建用户并且分配权限"   >          <a href="#怎么创建用户并且分配权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么创建用户并且分配权限" class="headerlink" title="怎么创建用户并且分配权限"></a>怎么创建用户并且分配权限</h3>      <p>创建用户步骤：</p><p>第一步：利用 root 登录数据库，进入指定数据库</p><p>第二步：创建用户，即 create user “用户名”@“主机名”identified by “密码”；</p><p>第三步：给这个用户分配权限，即 grant 权限 on python_ceshi2 . *  to“用户名”@“主机名”；</p><p>其中 python_ceshi2 . * 表示为 python_ceshi2 数据库内的所有数据表添加这个用户权限，也可以是为特定数据表添加权限等！</p><p>用户权限有很多种，例如 create select ，insert ，update，delete等，其中 all privileges 代表添加所有权限</p><p>注意区分主机名是localhost与%的区别</p><p>第四步：刷新权限，即 flush privileges；</p><p>截图：</p><p>注意：下面的截图忘记了第四步骤即刷新权限 flush privileges；</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153201477.png"  alt="image-20211012153201477">      </p>        <h3 id="怎么查询一个用户的所有权限"   >          <a href="#怎么查询一个用户的所有权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查询一个用户的所有权限" class="headerlink" title="怎么查询一个用户的所有权限"></a>怎么查询一个用户的所有权限</h3>      <p>语法：show  grants for “用户名”@“主机”；</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153218766.png"  alt="image-20211012153218766">      </p>        <h2 id="用户管理——增加权限【重点】"   >          <a href="#用户管理——增加权限【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户管理——增加权限【重点】" class="headerlink" title="用户管理——增加权限【重点】"></a>用户管理——增加权限【重点】</h2>              <h3 id="怎么增加指定用户的权限"   >          <a href="#怎么增加指定用户的权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么增加指定用户的权限" class="headerlink" title="怎么增加指定用户的权限"></a>怎么增加指定用户的权限</h3>      <p>语法：grant update on 数据库.数据表 to “用户名”@“主机” with grant option；<br>表示向指定用户新增 update 权限</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153230513.png"  alt="image-20211012153230513">      </p>        <h2 id="用户管理——重置密码【重点】"   >          <a href="#用户管理——重置密码【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户管理——重置密码【重点】" class="headerlink" title="用户管理——重置密码【重点】"></a>用户管理——重置密码【重点】</h2>              <h3 id="如何在知道密码的情况下重置用户密码"   >          <a href="#如何在知道密码的情况下重置用户密码" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何在知道密码的情况下重置用户密码" class="headerlink" title="如何在知道密码的情况下重置用户密码"></a>如何在知道密码的情况下重置用户密码</h3>      <p>语法：alter user “用户名”@“主机” identified by “新密码”</p><p>注意事项：这个操作需要用户先输入数据库原始密码进入数据库之后才能操作</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012153241543.png"  alt="image-20211012153241543">      </p>        <h3 id="如何在丢失用户数据库密码的情况下修改密码"   >          <a href="#如何在丢失用户数据库密码的情况下修改密码" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何在丢失用户数据库密码的情况下修改密码" class="headerlink" title="如何在丢失用户数据库密码的情况下修改密码"></a>如何在丢失用户数据库密码的情况下修改密码</h3>      <p>第一步：停止数据库服务，即 sudo service mysql stop</p><p>第二步：编辑数据库文件，即 sudo gedit  找到某一个数据库文件，在[mysqld]字段下面添加 skip-grant-tables</p><p>第三步：重启数据库 service mysql start</p><p>第四步：直接在命令行输入 mysql 即可进入数据库</p><p>第五步：用这个指令修改密码 update user set authentication_string = “” where user=”root”  重置 root 用户的密码</p><p>第六步：退出数据库 输入空密码进行登录数据库 即 mysql -u root -p </p><p>第七步：通过指令 alter user “root”@“%”identified by “新密码”进行重置密码</p>        <h2 id="用户管理——删除用户【重点】"   >          <a href="#用户管理——删除用户【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户管理——删除用户【重点】" class="headerlink" title="用户管理——删除用户【重点】"></a>用户管理——删除用户【重点】</h2>              <h3 id="如何指定用户远程登录数据库"   >          <a href="#如何指定用户远程登录数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何指定用户远程登录数据库" class="headerlink" title="如何指定用户远程登录数据库"></a>如何指定用户远程登录数据库</h3>      <p>第一步：本地数据库内检查用户的主机是否为%，如果是localhost就不能远程登录，只能本机登录，需要修改</p><p>第二步：在 Windows 中输入指令即可远程连接数据库，即 mysql -h windows的ip地址 -u 用户名 -p  然后输入密码即可</p>        <h3 id="如何删除数据库指定用户"   >          <a href="#如何删除数据库指定用户" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何删除数据库指定用户" class="headerlink" title="如何删除数据库指定用户"></a>如何删除数据库指定用户</h3>      <p>语法：</p><p>1：drop user “用户名”@“主机”<br>2：delete from user where user = “laowang”  （进入mysql数据库内的user表内删除用户）</p>        <h2 id="爬虫实战——爬取数据保存至数据库内【应用】"   >          <a href="#爬虫实战——爬取数据保存至数据库内【应用】" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬虫实战——爬取数据保存至数据库内【应用】" class="headerlink" title="爬虫实战——爬取数据保存至数据库内【应用】"></a>爬虫实战——爬取数据保存至数据库内【应用】</h2>      <p>……..</p>        <h2 id="爬虫实战——展示爬取的数据【应用】"   >          <a href="#爬虫实战——展示爬取的数据【应用】" class="heading-link"><i class="fas fa-link"></i></a><a href="#爬虫实战——展示爬取的数据【应用】" class="headerlink" title="爬虫实战——展示爬取的数据【应用】"></a>爬虫实战——展示爬取的数据【应用】</h2>      <p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Mysql数据库中的高级操作，例如建立与删除索引、管理用户等……&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/categories/Mysql%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/tags/Mysql%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql操作——数据库编程</title>
    <link href="http://pythonlamb.github.io/2021/10/12/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <id>http://pythonlamb.github.io/2021/10/12/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</id>
    <published>2021-10-12T07:00:04.000Z</published>
    <updated>2021-10-12T07:22:53.222Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Mysql数据库中外键的使用、事务的概念、Mysql数据库与Python进行交互等….</p><span id="more"></span>        <h2 id="外键使用"   >          <a href="#外键使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#外键使用" class="headerlink" title="外键使用"></a>外键使用</h2>              <h3 id="外键的使用场景"   >          <a href="#外键的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#外键的使用场景" class="headerlink" title="外键的使用场景"></a>外键的使用场景</h3>      <p>答：两个数据表相关联，一个数据表是产品名称，另一个数据表是这些产品的分类，向产品名称这个数据表添加数据时，但是产品分类这个数据表内没有这个产品的相应分类，我们就不能向名称数据表进行插入数据，这时就要用到外键！</p>        <h3 id="什么是外键"   >          <a href="#什么是外键" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是外键" class="headerlink" title="什么是外键"></a>什么是外键</h3>      <p>答：两个数据表相关联时，一个数据表的主键出现在另外一个数据表中，称另外这个数据表内的这个字段为外键</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151343486.png"  alt="image-20211012151343486">      </p>        <h3 id="怎么向已经存在的字段添加外键约束"   >          <a href="#怎么向已经存在的字段添加外键约束" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么向已经存在的字段添加外键约束" class="headerlink" title="怎么向已经存在的字段添加外键约束"></a>怎么向已经存在的字段添加外键约束</h3>      <p>关键字：foreign key 、references</p><p>语法：<code>alter table product add foreign key (nid) references classification(id);</code></p><p>表示向 product 表的 nid 字段添加外键，这个外键引用于 classification数据表的主键（id字段）</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151343486.png" >      </p>        <h3 id="怎么在创建数据表时添加外键"   >          <a href="#怎么在创建数据表时添加外键" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么在创建数据表时添加外键" class="headerlink" title="怎么在创建数据表时添加外键"></a>怎么在创建数据表时添加外键</h3>      <p>语法：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table product_test（</span><br><span class="line">id int not null primary key，</span><br><span class="line">name varchar（10）not null，</span><br><span class="line">mid int not null，</span><br><span class="line">foreign key (mid) references  classification（id））；</span><br></pre></td></tr></table></div></figure><p>上面语法表示创建 product_test 数据表并且为mid字段加上外键，foreign key (mid) references  classification（id）语法表示将mid字段设置为外键，外键引用于 classification数据表的 id 字段</p><p>注意事项：创建数据表添加外键，引用于哪个数据表的字段，那么这个数据表必须事先存在，例如上述的classification数据表之前就已经创建好！</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151414268.png"  alt="image-20211012151414268">      </p>        <h3 id="怎么查询数据表中的外键字段名称"   >          <a href="#怎么查询数据表中的外键字段名称" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查询数据表中的外键字段名称" class="headerlink" title="怎么查询数据表中的外键字段名称"></a>怎么查询数据表中的外键字段名称</h3>      <p><code>show create table 要查找外键的数据表名</code></p><p>例如：<code>show create  table product_test;</code></p><p>代码演示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151423481.png"  alt="image-20211012151423481">      </p><p>注意事项：上面查询的字段名称不是 mid 而是刚开始的那段字符串，即 product_test_ibfk_1 才是字段名称</p>        <h3 id="怎么删除数据表中的字段外键"   >          <a href="#怎么删除数据表中的字段外键" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么删除数据表中的字段外键" class="headerlink" title="怎么删除数据表中的字段外键"></a>怎么删除数据表中的字段外键</h3>      <p><code>alter table 数据表名 drop foreign key 外键字段名</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151433707.png"  alt="image-20211012151433707">      </p>        <h2 id="视图的概念【重点】"   >          <a href="#视图的概念【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#视图的概念【重点】" class="headerlink" title="视图的概念【重点】"></a>视图的概念【重点】</h2>              <h3 id="什么是视图，视图的使用场景"   >          <a href="#什么是视图，视图的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是视图，视图的使用场景" class="headerlink" title="什么是视图，视图的使用场景"></a>什么是视图，视图的使用场景</h3>      <p>答：简而言之就是将复杂的 SQL 语句封装成一张视图！只可查询数据，不可更改</p><p>使用场景：需要重复使用某条SQL语句时，就可以将这条 SQL 语句封装成视图</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151443532.png"  alt="image-20211012151443532">      </p>        <h2 id="视图的使用【重点】"   >          <a href="#视图的使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#视图的使用【重点】" class="headerlink" title="视图的使用【重点】"></a>视图的使用【重点】</h2>              <h3 id="视图的创建语法以及怎么查看视图是否创建成功"   >          <a href="#视图的创建语法以及怎么查看视图是否创建成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#视图的创建语法以及怎么查看视图是否创建成功" class="headerlink" title="视图的创建语法以及怎么查看视图是否创建成功"></a>视图的创建语法以及怎么查看视图是否创建成功</h3>      <p>创建语法：<code>create view 视图名 as 封装的SQL语句；</code></p><p>查看语法：<code>show tables；</code></p><p>注意事项：</p><p>1：视图名一般要以 v_ 开头 例如 v_name</p><p>2：视图只是一个虚拟的表，当视图数据来源的表数据发生变化时，视图内的数据也会发生变化！</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151514095.png"  alt="image-20211012151514095">      </p>        <h3 id="怎么查看视图内的数据以及怎么删除视图"   >          <a href="#怎么查看视图内的数据以及怎么删除视图" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查看视图内的数据以及怎么删除视图" class="headerlink" title="怎么查看视图内的数据以及怎么删除视图"></a>怎么查看视图内的数据以及怎么删除视图</h3>      <p>查看视图数据语法：<code>select * from 视图名；</code></p><p>删除视图语法：<code>drop view 视图名</code></p><p>快速代码体验；</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151525693.png"  alt="image-20211012151525693">      </p>        <h2 id="事务概念及特性【面试题】"   >          <a href="#事务概念及特性【面试题】" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务概念及特性【面试题】" class="headerlink" title="事务概念及特性【面试题】"></a>事务概念及特性【面试题】</h2>              <h3 id="事物的使用场景"   >          <a href="#事物的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#事物的使用场景" class="headerlink" title="事物的使用场景"></a>事物的使用场景</h3>      <p>答：假设控制数据库查询某些数据需要好几条SQL语句，而且这几条语句要么全都执行成功，要么全都执行失败，我们就可以把这几条SQL语句加到事物当中！比如说去银行给别人汇钱操作，分为 查询余额、你给别人汇款操作、别人收款操作，要么这几个步骤全部执行成功，要么这几个步骤全部执行失败！</p><p>简而言之，数据库的事务，就是当执行某操作，其中一个步骤失败，就回到未执行前的状态！要么事务所有步骤全部执行成功，要么全部失败！</p><p>事务功能：保证某个操作要么一定成功执行，要么一定失败执行</p>        <h3 id="事务的四大特性（ACID）"   >          <a href="#事务的四大特性（ACID）" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h3>      <p>1.原子性：一个事物必须被视为不可分割的最小单元，也就是事务内的所有步骤都是不可分割，要么所有步骤全部成功执行，要么全都失败回滚</p><p>2.一致性：数据库总是从一个状态转换到另外一个状态，汇钱例子，我向你打款500元，我余额减少500，你的余额必须增加500</p><p>3.隔离性：一个事务所做的修改在最终提交以前，对外是不可见的，例如汇款，我的余额600，正在向你汇款500，汇款的过程未结束时，别人是不可在用你卡向别人汇款的，因为他看到你的余额还是600元</p><p>4.持久性：一旦事务提交，则其所做的修改将永久保存到数据库</p><p>图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151606508.png"  alt="image-20211012151606508">      </p>        <h2 id="事务使用【重点】"   >          <a href="#事务使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务使用【重点】" class="headerlink" title="事务使用【重点】"></a>事务使用【重点】</h2>              <h3 id="什么是表引擎以及怎么查看数据表表引擎分类"   >          <a href="#什么是表引擎以及怎么查看数据表表引擎分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是表引擎以及怎么查看数据表表引擎分类" class="headerlink" title="什么是表引擎以及怎么查看数据表表引擎分类"></a>什么是表引擎以及怎么查看数据表表引擎分类</h3>      <p>答：表引擎就是数据表在系统中的存储方式</p><p>查看数据表表引擎分类语法：show engines；</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151624749.png"  alt="image-20211012151624749">      </p>        <h3 id="怎么查看数据表使用的是什么表引擎"   >          <a href="#怎么查看数据表使用的是什么表引擎" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么查看数据表使用的是什么表引擎" class="headerlink" title="怎么查看数据表使用的是什么表引擎"></a>怎么查看数据表使用的是什么表引擎</h3>      <p>语法：<code>show create table  数据表名；</code></p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151633154.png"  alt="image-20211012151633154">      </p>        <h3 id="begin、commit、rollback关键字对事务的影响"   >          <a href="#begin、commit、rollback关键字对事务的影响" class="heading-link"><i class="fas fa-link"></i></a><a href="#begin、commit、rollback关键字对事务的影响" class="headerlink" title="begin、commit、rollback关键字对事务的影响"></a>begin、commit、rollback关键字对事务的影响</h3>      <p>begin：开启事务，开启事务之后对数据库的更改都要符合事务的使用规范</p><p>commit：提交事务，开启事务后对数据库修改数据，如果不 commit 一下，别人看见的数据还是未修改之前的，所以数据修改完成后，需要commit才能正式生效，注意 commit之后 在 rollback 不能回滚之前的数据库状态</p><p>rollback：事务回滚，开启事务后修改数据，没有 commit 之前，执行 rollback后，数据库会回到事务begin之前的状态</p><p>注意事项：在事务开启之后，执行了 commit 或者 rollback 之后，事务就关闭了，想在再次开启事务，需再次执行 begin 指令！</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151646638.png"  alt="image-20211012151646638">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151656081.png"  alt="image-20211012151656081">      </p>        <h2 id="验证事务的ACID特性【重点】"   >          <a href="#验证事务的ACID特性【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证事务的ACID特性【重点】" class="headerlink" title="验证事务的ACID特性【重点】"></a>验证事务的ACID特性【重点】</h2>      <p>目标：掌握如何验证事务的隔离性（I）</p>        <h3 id="如何验证事务的隔离性（I）"   >          <a href="#如何验证事务的隔离性（I）" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何验证事务的隔离性（I）" class="headerlink" title="如何验证事务的隔离性（I）"></a>如何验证事务的隔离性（I）</h3>      <p>答：LINUX同时开启两个客户端，一个客户端开启事务，对数据进行修改，并且不要commit与rollback（代表事务没有结束），另一个客户端不需要开启事务，同时对这个数据进行更改，就会发现没开启事务的更改数据不成功！</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151709986.png"  alt="image-20211012151709986">      </p>        <h2 id="数据库的三范式【了解】"   >          <a href="#数据库的三范式【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的三范式【了解】" class="headerlink" title="数据库的三范式【了解】"></a>数据库的三范式【了解】</h2>      <p>前言：数据库设计三范式就是设置数据库时的注意事项</p>        <h3 id="数据库设计的第一、第二、第三范式"   >          <a href="#数据库设计的第一、第二、第三范式" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库设计的第一、第二、第三范式" class="headerlink" title="数据库设计的第一、第二、第三范式"></a>数据库设计的第一、第二、第三范式</h3>      <p>第一范式：强调列的原子性，即每一个字段都不能再次拆分成其他几个字段</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151722041.png"  alt="image-20211012151722041">      </p><p>第二范式：需满足第一范式，一个表内必须要有一个主键，非主键字段必须要完全依赖于主键字段，不能只有一部分字段依赖主键，即所有非主键字段全都要完全依赖于一个主键，不能有一部分依赖这个主键，其他不依赖这个主键</p><p>注意事项：如果数据表不满足第二范式，可以将数据表进行拆分</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151738763.png"  alt="image-20211012151738763">      </p><p>第三范式：必须要满足第二范式，非主键字段必须直接依赖于主键字段，不能存在传递依赖</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151747531.png"  alt="image-20211012151747531">      </p><p>注意事项：如果数据表不满足第二范式，可以将数据表进行拆分</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151758531.png"  alt="image-20211012151758531">      </p>        <h2 id="E-R模型及表间关系【了解】"   >          <a href="#E-R模型及表间关系【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#E-R模型及表间关系【了解】" class="headerlink" title="E-R模型及表间关系【了解】"></a>E-R模型及表间关系【了解】</h2>              <h3 id="E-R模型的使用场景"   >          <a href="#E-R模型的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#E-R模型的使用场景" class="headerlink" title="E-R模型的使用场景"></a>E-R模型的使用场景</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151819642.png"  alt="image-20211012151819642">      </p>        <h3 id="E-R模型的组成部分"   >          <a href="#E-R模型的组成部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#E-R模型的组成部分" class="headerlink" title="E-R模型的组成部分"></a>E-R模型的组成部分</h3>      <p>组成部分：实体、实体属性、联系</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151831293.png"  alt="image-20211012151831293">      </p>        <h3 id="数据表之间的一对一、一对多、多对多关系"   >          <a href="#数据表之间的一对一、一对多、多对多关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据表之间的一对一、一对多、多对多关系" class="headerlink" title="数据表之间的一对一、一对多、多对多关系"></a>数据表之间的一对一、一对多、多对多关系</h3>      <p>一对一：数据表1中的一个字段数据对应数据表2中的一个字段数据，可以靠两个表来实现关系，符号是 1-1</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151842427.png"  alt="image-20211012151842427">      </p><p>一对多：数据表1中的一个字段数据对应数据表2中的多个字段数据，可以靠两个表来实现关系，图示一个班级对应多名学生，符号为 1-N表示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151850087.png"  alt="image-20211012151850087">      </p><p>多对多：数据表1中的一个字段数据对应数据表2中的多个字段数据，数据表2中的一个字段数据对应数据表1中的多个字段数据，不能靠两个表来实现关系，需要第三个中间表才能实现数据的保存，图示一个科目可以有多个学生选，一个学生也可以选多们课程，符号为 N-N表示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012151857844.png"  alt="image-20211012151857844">      </p>        <h2 id="58到家数据库的30条军规解读【重点】"   >          <a href="#58到家数据库的30条军规解读【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#58到家数据库的30条军规解读【重点】" class="headerlink" title="58到家数据库的30条军规解读【重点】"></a>58到家数据库的30条军规解读【重点】</h2>      <p>军规阅读地址：</p><p><span class="exturl"><a class="exturl__link"   href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959906&amp;idx=1&amp;sn=2cbdc66cfb5b53cf4327a1e0d18d9b4a&amp;chksm=bd2d07be8a5a8ea86dc3c04eced3f411ee5ec207f73d317245e1fefea1628feb037ad71531bc&amp;scene=21&amp;key=e82f935468864c7d48052912f819a6dd5e6242373178c6cf6b2a30bc7a3bc45cf528644761f1c83760a26aa894abf4ecc9a77152e7a9d688d98cf9acbefe04f63cb0dbecd86ed0463d85e6e4022081a7&amp;ascene=7&amp;uin=MjE4OTMzMzMwNA==&amp;devicetype=Windows+10&amp;version=6203005d&amp;pass_ticket=HwLIq9t4Fwuxfe3EcHX5+6GOZG4yYlLMCZ8YH/vGq5QnbR/jduDlkLzmQa2Y+uiY&amp;winzoom=1#%23" >https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959906&amp;idx=1&amp;sn=2cbdc66cfb5b53cf4327a1e0d18d9b4a&amp;chksm=bd2d07be8a5a8ea86dc3c04eced3f411ee5ec207f73d317245e1fefea1628feb037ad71531bc&amp;scene=21&amp;key=e82f935468864c7d48052912f819a6dd5e6242373178c6cf6b2a30bc7a3bc45cf528644761f1c83760a26aa894abf4ecc9a77152e7a9d688d98cf9acbefe04f63cb0dbecd86ed0463d85e6e4022081a7&amp;ascene=7&amp;uin=MjE4OTMzMzMwNA%3D%3D&amp;devicetype=Windows+10&amp;version=6203005d&amp;pass_ticket=HwLIq9t4Fwuxfe3EcHX5%2B6GOZG4yYlLMCZ8YH%2FvGq5QnbR%2FjduDlkLzmQa2Y%2BuiY&amp;winzoom=1#%23</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>重点内容提取：</p><p>1：数据库必须使用 InnoDB存储引擎</p><p>2：数据库必须使用 utf-8进行编码</p><p>3：并发量大、数据量大的互联网业务禁止使用外键</p><p>4：禁止使用小数存储货币</p><p>5：禁止使用select * 只获取必要的字段，需要显示说明列属性</p><p>6：禁止大表使用join（连接）</p>        <h2 id="python连接操作MySQL【重点】"   >          <a href="#python连接操作MySQL【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#python连接操作MySQL【重点】" class="headerlink" title="python连接操作MySQL【重点】"></a>python连接操作MySQL【重点】</h2>              <h3 id="python-连接数据库的功能"   >          <a href="#python-连接数据库的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-连接数据库的功能" class="headerlink" title="python 连接数据库的功能"></a>python 连接数据库的功能</h3>      <p>答：用 python 代码充当客户端，对数据进行增删改查等操作</p>        <h3 id="python-连接数据库的步骤并实现查询数据库操作"   >          <a href="#python-连接数据库的步骤并实现查询数据库操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-连接数据库的步骤并实现查询数据库操作" class="headerlink" title="python 连接数据库的步骤并实现查询数据库操作"></a>python 连接数据库的步骤并实现查询数据库操作</h3>      <p>连接前准备： pip3 install pymysql 安装 pymysql 包</p><p>第一步：导入 pymysql 模块 即 import pymysql</p><p>第二步：建立数据库连接对象（相当于建立一条通信的高速公路）</p><p>语法：connection = pymysql.connect（host，port，root，possword，database，charset）</p><p>参数详解：</p><p>host：数据库所在的主机</p><p>port：连接数据库主机的端口号，可省略，默认3306</p><p>user：连接数据库用户名</p><p>password：连接数据库密码</p><p>database：要连接的数据库名</p><p>charset：通信采用的编码，可省略，默认是 utf-8</p><p>第三步：在连接（公路）的基础上，（利用高速公路）创建游标对象（相当于高速公路上的通信兵）<br>详解：cursor 相当于数据库与 python 端的通信兵，数据库数据的操作以及取出都是靠这通信兵来完成</p><p>语法：游标对象 = 连接对象.cursor（）  例如 cursor_obj = connection.cursor（）</p><p>第四步：利用通信兵的 execute 方法对数据库的数据进行查询操作，并返回影响数据库几行数据的结果！</p><p>关键字：execute</p><p>语法：num_result = cursor_obj.execute（SQL语句）</p><p>注意：</p><p>1：返回的结果是num类型</p><p>2：SQL语句是查询语句那就影响所有行数</p><p>3：SQL语句是字符串类型</p><p>第五步：利用通信兵的fetchone或者fetchall方法查询数据库的数据</p><p>关键字：</p><p>fetchone（）：查询数据库第一行数据</p><p>fetchall（）：查询数据库所有数据</p><p>语法：</p><p>1：data_result = cursor_obj.fetchone( )</p><p>2：data_result = cursor_obj.fetchall( )</p><p>注意：fetchone或者fetchall方法查询数据返回的结果都是元组，不同的是fetchone返回的是一个元组，如果数据库有多行数据则fetchall返回的是元组的嵌套</p><p>第六步：关闭通信兵以及高速公路</p><p>关键字：close</p><p>语法：</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.close（）</span><br><span class="line">cursor_obj.close( )</span><br></pre></td></tr></table></div></figure><p>截图演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152014285.png"  alt="image-20211012152014285">      </p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152021827.png"  alt="image-20211012152021827">      </p>        <h3 id="用-python-连接数据库并实现数据库的增删改操作"   >          <a href="#用-python-连接数据库并实现数据库的增删改操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#用-python-连接数据库并实现数据库的增删改操作" class="headerlink" title="用 python 连接数据库并实现数据库的增删改操作"></a>用 python 连接数据库并实现数据库的增删改操作</h3>      <p>关键字：execute</p><p>语法：</p><p>返回影响行数值 = 游标对象 . execute（增删改SQL语句） 例如 result_num = cursor_obj.execute(SQL语句)</p><p>连接对象.commit（）  即对数据表修改后需要提交！！</p><p>注意事项：</p><p>1：在对数据库进行增删改操作之后，需要提交修改，做的更改才会生效，否则不生效</p><p>2：对数据库进行增删改需要提交，查询操作不需要提交！</p><p>3：commit提交不是用游标对象提交，而是用连接对象来提交</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152039698.png"  alt="image-20211012152039698">      </p>        <h3 id="游标对象的-fetchone-与-fetchall-方法在数据库不同操作时打印结果的不同！"   >          <a href="#游标对象的-fetchone-与-fetchall-方法在数据库不同操作时打印结果的不同！" class="heading-link"><i class="fas fa-link"></i></a><a href="#游标对象的-fetchone-与-fetchall-方法在数据库不同操作时打印结果的不同！" class="headerlink" title="游标对象的 fetchone 与 fetchall 方法在数据库不同操作时打印结果的不同！"></a>游标对象的 fetchone 与 fetchall 方法在数据库不同操作时打印结果的不同！</h3>      <p>答：fetchone（）与fetchall（）方法只有在查询数据库（即查询数据库的SQL语句：select……）的时候才能打印出数据，当增删改数据库里面数据的时候，使用fetchone（）或fetchall（）方法是查询不出来数据的</p>        <h2 id="SQL防注入【重点】"   >          <a href="#SQL防注入【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL防注入【重点】" class="headerlink" title="SQL防注入【重点】"></a>SQL防注入【重点】</h2>              <h3 id="什么是SQL注入"   >          <a href="#什么是SQL注入" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h3>      <p>答：在查询数据库数据操作时，当别人在输入一些特殊的字符串的时候，可能会获得我们数据库里面的大量数据，但是这些数据我们是不想让它获取的，这样就造成了数据泄露，也称为SQL注入</p>        <h3 id="怎么防止SQL注入"   >          <a href="#怎么防止SQL注入" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么防止SQL注入" class="headerlink" title="怎么防止SQL注入"></a>怎么防止SQL注入</h3>      <p>实现点：在利用 cursor 通信兵对象的 execute 方法时，向这个方法内传入第二个参数可有效防止SQL注入（占位符）</p><p>实现语法：num_result = cur_obj.execute(SQL语句，params)  其中 params 是一个列表参数，列表内存放着SQL语句要查询的字段名或其他参数</p><p>注意：参数列表中可以有多个参数，因此SQL语句中也要有多个占位符与其一一对应，</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211012152104800.png"  alt="image-20211012152104800">      </p><p>未完待续…..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Mysql数据库中外键的使用、事务的概念、Mysql数据库与Python进行交互等….&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/categories/Mysql%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/tags/Mysql%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql操作——进阶指令语法</title>
    <link href="http://pythonlamb.github.io/2021/10/11/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95/"/>
    <id>http://pythonlamb.github.io/2021/10/11/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95/</id>
    <published>2021-10-11T12:02:32.000Z</published>
    <updated>2021-10-11T12:44:39.308Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Mysql数据库内高级的操作指令，例如where比较运算、order排序、grep分组、连接查询等..</p><span id="more"></span>        <h2 id="强化练习——去重复【重点】"   >          <a href="#强化练习——去重复【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#强化练习——去重复【重点】" class="headerlink" title="强化练习——去重复【重点】"></a>强化练习——去重复【重点】</h2>              <h3 id="查询结果去重复关键字-——-distinct"   >          <a href="#查询结果去重复关键字-——-distinct" class="heading-link"><i class="fas fa-link"></i></a><a href="#查询结果去重复关键字-——-distinct" class="headerlink" title="查询结果去重复关键字 —— distinct"></a>查询结果去重复关键字 —— distinct</h3>      <p>功能：将查询结果去重复</p><p>语法： select distinct  字段名 from 数据表名；</p><p>快速代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202331816.png"  alt="image-20211011202331816">      </p>        <h2 id="where之比较运算【重点】"   >          <a href="#where之比较运算【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之比较运算【重点】" class="headerlink" title="where之比较运算【重点】"></a>where之比较运算【重点】</h2>              <h3 id="Mysql数据库中几种比较运算符"   >          <a href="#Mysql数据库中几种比较运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql数据库中几种比较运算符" class="headerlink" title="Mysql数据库中几种比较运算符"></a>Mysql数据库中几种比较运算符</h3>      <p>常见几种Mysql运算符：</p><p>大于：&gt;</p><p>小于：&lt;</p><p>大于等于：&gt;=</p><p>小于等于：&lt;=</p><p>等于：=</p><p>不等于：!= 或者 &lt;&gt;</p><p>注意事项：在Mysql内，等于号是 = 而不是 ==</p>        <h3 id="where之比较查询的方法"   >          <a href="#where之比较查询的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之比较查询的方法" class="headerlink" title="where之比较查询的方法"></a>where之比较查询的方法</h3>      <p>功能：利用比较运算符查询符合条件的数据</p><p>语法：</p><p>1：select * from 数据表名 where id &lt;&gt; 15；(表示查询id不等于15的所有字段数据)</p><p>2：select * from 数据表名 where id = 15; （表示查询id等于15的所有字段数据）</p><p>快速代码体验</p><p><code>&lt;&gt;</code>   不等于运算符</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202447791.png"  alt="image-20211011202447791">      </p><p>=   等于运算符</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202455234.png"  alt="image-20211011202455234">      </p>        <h2 id="where之逻辑运算【重点】"   >          <a href="#where之逻辑运算【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之逻辑运算【重点】" class="headerlink" title="where之逻辑运算【重点】"></a>where之逻辑运算【重点】</h2>              <h3 id="Mysql的几种逻辑运算符"   >          <a href="#Mysql的几种逻辑运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql的几种逻辑运算符" class="headerlink" title="Mysql的几种逻辑运算符"></a>Mysql的几种逻辑运算符</h3>      <p>和运算符：and</p><p>或运算符：or</p><p>非运算符：not</p>        <h3 id="where之逻辑运算符查询的语法"   >          <a href="#where之逻辑运算符查询的语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之逻辑运算符查询的语法" class="headerlink" title="where之逻辑运算符查询的语法"></a>where之逻辑运算符查询的语法</h3>      <p>功能：按照逻辑运算符查询符合条件所有字段的数据</p><p>语法：<br>1：select * from 数据表名 where id &gt; 15 and gender = “女”; (表示查询id大于15并且性别为女的所有字段数据)</p><p>2：select * from 数据表名 where id &gt; 15 or new_age  &gt; 20 ; (表示查询 id 大于 15 或者 new_age 大于 20 的所有字段数据)</p><p>3：select * from 数据表名 where not id &gt; 15 ; (表示查询id小于等于15的所有字段数据)</p><p>4：select * from 数据表名 where not id &gt; 15 and gender = “女”; (表示查询id小于等于15并且性别为女的所有字段数据)</p><p>快速代码体验</p><p>and和or的代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202535900.png"  alt="image-20211011202535900">      </p><p>not代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202554729.png"  alt="image-20211011202554729">      </p>        <h2 id="where之模糊查询（类似于正则）【重点、常用】"   >          <a href="#where之模糊查询（类似于正则）【重点、常用】" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之模糊查询（类似于正则）【重点、常用】" class="headerlink" title="where之模糊查询（类似于正则）【重点、常用】"></a>where之模糊查询（类似于正则）【重点、常用】</h2>              <h3 id="模糊查询的几个关键字"   >          <a href="#模糊查询的几个关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#模糊查询的几个关键字" class="headerlink" title="模糊查询的几个关键字"></a>模糊查询的几个关键字</h3>      <p>like：放在字段后面使用用于模糊查询</p><p>%：表示匹配0个或多个任意字符，类似于正则表达式中的 *</p><p>_：表示匹配单个任意字符，类似于正则表达式中的 . </p>        <h3 id="where之模糊查询的使用方法"   >          <a href="#where之模糊查询的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之模糊查询的使用方法" class="headerlink" title="where之模糊查询的使用方法"></a>where之模糊查询的使用方法</h3>      <p>功能：模糊查询符合规则的字段所有数据，类似于正则表达式匹配字符串</p><p>应用场景：百度搜索引擎的模糊关键字查询</p><p>语法：<br>1：select * from 数据表名 where name like “张%”; （表示查询name字段中 第一个字符是张的所有名字信息）</p><p>2：select * from 数据表名 where name like “张_”；（表示查询name字段第一个字符是张，第二个字符任意的所有名字信息，注意名字只有两个字符）</p><p>3：select * from 数据表名 where name like “%莉%”；（表示查询name字段中包含莉这个字符的所有数据信息）</p><p>快速代码体验</p><p>语法一代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202631791.png"  alt="image-20211011202631791">      </p><p>语法二代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202640661.png"  alt="image-20211011202640661">      </p><p>语法三代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202647375.png"  alt="image-20211011202647375">      </p>        <h2 id="where之范围查询【重点】"   >          <a href="#where之范围查询【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之范围查询【重点】" class="headerlink" title="where之范围查询【重点】"></a>where之范围查询【重点】</h2>              <h3 id="in、not-in、between-and、not-between-and-关键字的作用"   >          <a href="#in、not-in、between-and、not-between-and-关键字的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#in、not-in、between-and、not-between-and-关键字的作用" class="headerlink" title="in、not in、between and、not between and 关键字的作用"></a>in、not in、between and、not between and 关键字的作用</h3>      <p>in：表示查询在非连续范围内的所有数据</p><p>not in ：表示查询不在这个非连续范围内的所有数据</p><p>between and：表示查询在连续范围内的所有数据</p><p>not between and ：表示查询不在这个连续范围内的所有数据</p>        <h3 id="where之范围查询的使用方法"   >          <a href="#where之范围查询的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之范围查询的使用方法" class="headerlink" title="where之范围查询的使用方法"></a>where之范围查询的使用方法</h3>      <p>功能：查询指定范围内（非连续范围与连续范围）的所有数据</p><p>语法：</p><p>1：select * from 数据表名 where id in（14，16，18）；（表示查询id为14，16，18的所有字段数据）</p><p>2：select * from 数据表名 where id not in （14，16，18）；（表示查询id不是14，16，18的所有字段数据）</p><p>3：select * from 数据表名 where id between 14 and 16；（表示查询id在14到16之间的所有字段数据，包括14与16）</p><p>4：select * from 数据表名 where id not between 14 and 16；（表示查询id不在14到16之间的所有字段数据）</p><p>注意事项：</p><p>1：利用关键字 between 16 and 18 在连续范围内查询数据时，包含16与18</p><p>2：利用关键字 not between 16 and 18 查询数据时不能这么写 not （between 16 and 18）即不能加括号！</p><p>快速代码体验：</p><p>in关键字与not in 关键字</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202723777.png"  alt="image-20211011202723777">      </p><p>Between and 关键字与 not between and 关键字</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202732020.png"  alt="image-20211011202732020">      </p>        <h2 id="where之空值判断【重点】"   >          <a href="#where之空值判断【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#where之空值判断【重点】" class="headerlink" title="where之空值判断【重点】"></a>where之空值判断【重点】</h2>              <h3 id="is-null-关键字与-is-not-null-关键字的作用"   >          <a href="#is-null-关键字与-is-not-null-关键字的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#is-null-关键字与-is-not-null-关键字的作用" class="headerlink" title="is null 关键字与  is not null 关键字的作用"></a>is null 关键字与  is not null 关键字的作用</h3>      <p>is null ：查询指定字段内数值为空（null）的所有数据（将指定字段内数据为空的数据查询出来）</p><p>is not null：查询指定字段内数据非空的所有数据</p>        <h3 id="where值空值判断的使用方法"   >          <a href="#where值空值判断的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#where值空值判断的使用方法" class="headerlink" title="where值空值判断的使用方法"></a>where值空值判断的使用方法</h3>      <p>功能：查询某一个字段内的空（null）与非空的所有数据值</p><p>语法：</p><p>1：select * from 数据表名 where new_age is null；（表示查询new_age字段中所有数值为空（null）的所有数据）</p><p>2：select * from 数据表名 where new_age is not null；（表示查询new_age字段中所有数值不为空的所有数据）</p><p>注意事项：在查询非空数据的时候，不能写成 not is null 而是 is not null 这是甲鱼的臀部</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202821485.png"  alt="image-20211011202821485">      </p>        <h2 id="order排序【重点】"   >          <a href="#order排序【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#order排序【重点】" class="headerlink" title="order排序【重点】"></a>order排序【重点】</h2>              <h3 id="Mysql排序关键字-order-by"   >          <a href="#Mysql排序关键字-order-by" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql排序关键字-order-by" class="headerlink" title="Mysql排序关键字 order by"></a>Mysql排序关键字 order by</h3>      <p>当sql语句中出现 where 关键字时就说明要按照条件查询数据， 当出现 order by 关键字时就说明要对查询数据进行排序啦</p><p>where 关键字与 order by 关键字关系图示</p>        <h3 id="Mysql-升序（asc）与降序（desc）的关键字"   >          <a href="#Mysql-升序（asc）与降序（desc）的关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql-升序（asc）与降序（desc）的关键字" class="headerlink" title="Mysql 升序（asc）与降序（desc）的关键字"></a>Mysql 升序（asc）与降序（desc）的关键字</h3>      <p>asc：当字段后面出现 asc 关键字时就说明将这个字段内的所有数据按照升序排列</p><p>desc：当字段后面出现 desc 关键字时就说明将这个字段内的所有数据按照降序排列</p><p>注意事项：<br>1：在写sql排序语句时，字段后面没有出现 asc与desc 默认按照升序（asc）进行排序<br>2：字母的升序是 a-z ，降序为 z-a</p>        <h3 id="order-by-排序的使用方法"   >          <a href="#order-by-排序的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#order-by-排序的使用方法" class="headerlink" title="order by 排序的使用方法"></a>order by 排序的使用方法</h3>      <p>功能：将查询的数据按照升序或者降序进行排序</p><p>语法：</p><p>1：select * from 数据表名 where id between 14 and 18 and gender = “男”order by new_age asc ;<br>(表示先查询id在14到18之间的所有男性信息，然后将这些信息再次按照 new_age 字段内的数据进行升序排序)</p><p>2：select * from 数据表名 where id between 14 and 18 and gender = “男”order by new_age desc<br>(表示先查询id在14到18之间的所有男性信息，然后将这些信息再次按照 new_age 字段内的数据进行降序排序)</p><p>注意事项：where关键字先按照后面的条件查询出符合条件的数据信息，然后 order by 关键字将 where查询的数据按照升序或者降序的规则进行排序，有点类似于linux指令的通道指令！</p><p>快速代码体验：</p><p>升序排列</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202943725.png"  alt="image-20211011202943725">      </p><p>降序排列</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011202951809.png"  alt="image-20211011202951809">      </p>        <h3 id="多字段排序"   >          <a href="#多字段排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h3>      <p>应用场景：按照单个字段进行排序时，如果有几个数据是一样的，就可以使用另一个字段将相同的数据再次进行排序<br>语法：select * from 数据表名 where id between 14 and 18 and gender= “男”order by new_age desc，id desc；<br>（表示先查询id在14到18之间的所有男性信息，然后将这些信息再次按照 new_age 字段内的数据进行降序排序，如果new_age字段内有相同的数据信息，将相同的数据信息再次按照 id字段进行降序排列）</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203007534.png"  alt="image-20211011203007534">      </p>        <h2 id="聚合函数【重点】"   >          <a href="#聚合函数【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#聚合函数【重点】" class="headerlink" title="聚合函数【重点】"></a>聚合函数【重点】</h2>              <h3 id="聚合函数的几个关键字"   >          <a href="#聚合函数的几个关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#聚合函数的几个关键字" class="headerlink" title="聚合函数的几个关键字"></a>聚合函数的几个关键字</h3>      <p>count（*）：查询整个数据表内有几行数据</p><p>max（字段名）：查询指定字段内的数据最大值</p><p>min（字段名）：查询指定字段的数据最小值</p><p>sum（字段名）：计算指定字段内的所有数据总和</p><p>avg（字段名）：计算指定字段内所有数据的平均值</p>        <h3 id="使用聚合函数的注意事项"   >          <a href="#使用聚合函数的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用聚合函数的注意事项" class="headerlink" title="使用聚合函数的注意事项"></a>使用聚合函数的注意事项</h3>      <p>1：聚合函数不能嵌套使用，例如 sum（max（字段名））</p><p>2：聚合函数内的数据一般为字段名或者表达式</p>        <h3 id="聚合函数的使用方法"   >          <a href="#聚合函数的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#聚合函数的使用方法" class="headerlink" title="聚合函数的使用方法"></a>聚合函数的使用方法</h3>              <h4 id="计算数据表内总共几行数据——count（-）"   >          <a href="#计算数据表内总共几行数据——count（-）" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算数据表内总共几行数据——count（-）" class="headerlink" title="计算数据表内总共几行数据——count（*）"></a>计算数据表内总共几行数据——count（*）</h4>      <p>语法：</p><p>1：select count（<em>） from classes；表示查询classes数据表内一共有几行数据</em></p><p>2：select count（<em>）as 总数量 from classes；表示查询classes数据表内一共有几行数据，并将count（</em>）替换为总数量显示出来</p><p>3：select count（*） from classes where gender = “男”; 表示查询数据表内所有男性一共几行数据</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203105924.png"  alt="image-20211011203105924">      </p>        <h4 id="查询指定字段内的最大、最小值"   >          <a href="#查询指定字段内的最大、最小值" class="heading-link"><i class="fas fa-link"></i></a><a href="#查询指定字段内的最大、最小值" class="headerlink" title="查询指定字段内的最大、最小值"></a>查询指定字段内的最大、最小值</h4>      <p>语法：</p><p>最大值</p><p>1：select max（new_age） from classes；表示查询new_age字段内数据的最大值</p><p>2：select max（new_age） from classes where gender = “女”； 表示查询所有女性new_age字段内的最大值</p><p>最小值</p><p>1：select min（new_age） from classes；表示查询new_age字段内数据的最小值</p><p>2：select min（new_age） from classes where gender = “女”；表示查询所有女性new_age字段内的最小值</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203126427.png"  alt="image-20211011203126427">      </p>        <h4 id="计算指定字段所有数据的总和以及平均值"   >          <a href="#计算指定字段所有数据的总和以及平均值" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算指定字段所有数据的总和以及平均值" class="headerlink" title="计算指定字段所有数据的总和以及平均值"></a>计算指定字段所有数据的总和以及平均值</h4>      <p>语法：</p><p>总和：select sum（new_age）from  classes；</p><p>平均值：select avg（new_age）from  classes；</p><p>快速代码体验：</p><p>总和</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203407105.png"  alt="image-20211011203407105">      </p><p>平均值</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203414077.png"  alt="image-20211011203414077">      </p>        <h3 id="round函数对数据的四舍五入以及保留几位小数的处理"   >          <a href="#round函数对数据的四舍五入以及保留几位小数的处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#round函数对数据的四舍五入以及保留几位小数的处理" class="headerlink" title="round函数对数据的四舍五入以及保留几位小数的处理"></a>round函数对数据的四舍五入以及保留几位小数的处理</h3>      <p>语法简洁：round（数值，num）num代表保留几位小数</p><p>语法：select round（avg（new_age）,2）from classes；表示计算classes数据表内new_age字段所有数据的平均值并且保留两位小数</p><p>注意事项：round（数据，num）不是聚合函数</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203438263.png"  alt="image-20211011203438263">      </p>        <h2 id="grep分组【重点】"   >          <a href="#grep分组【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#grep分组【重点】" class="headerlink" title="grep分组【重点】"></a>grep分组【重点】</h2>              <h3 id="分组关键字是什么？"   >          <a href="#分组关键字是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#分组关键字是什么？" class="headerlink" title="分组关键字是什么？"></a>分组关键字是什么？</h3>      <p>答：分组关键字是 group by 类似于 order by 以及 where</p>        <h3 id="对数据的分组"   >          <a href="#对数据的分组" class="heading-link"><i class="fas fa-link"></i></a><a href="#对数据的分组" class="headerlink" title="对数据的分组"></a>对数据的分组</h3>      <p>功能：将数据表内的某一个字段的所有数据进行分组（分类），有便于聚合函数计算统计</p><p>语法：</p><p>1：select gender from classes group by gender；表示将gender这个字段内数据进行分组（去重复）</p><p>2：select gender ，count（*）from classes group by gender；表示将gender这个字段内数据进行分组（去重复），并且计算每一个分组的人数（数量）</p><p>3：select gender,max(new_age) from classes group by gender ;表示按照gender进行分组然后查找这些分组内new_age字段中的最大值打印</p><p>注意事项：在写分组语法的时候 select 后面的字段必须是 group by 后面那个字段或者是聚合函数字段</p><p>快速代码体验：</p><p>语法1</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203506120.png"  alt="image-20211011203506120">      </p><p>语法2</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203515195.png"  alt="image-20211011203515195">      </p>        <h3 id="group-by-group-concat-的功能以及使用方法"   >          <a href="#group-by-group-concat-的功能以及使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#group-by-group-concat-的功能以及使用方法" class="headerlink" title="group by + group_concat 的功能以及使用方法"></a>group by + group_concat 的功能以及使用方法</h3>      <p>功能：对分组之后的数据的某个字段的所有数据进行拼接</p><p>语法：</p><p>1：select gender ,count（<em>）， group_concat(name)  from classes group by gender;</em><br>表示按照 gender 字段进行分组后，显示每个分组内有几行数据（count（*））并将分组后的数据的name字段内的所有数据进行拼接显示出来</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203601072.png"  alt="image-20211011203601072">      </p>        <h3 id="group-by-having-的功能以及使用方法及其注意事项"   >          <a href="#group-by-having-的功能以及使用方法及其注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#group-by-having-的功能以及使用方法及其注意事项" class="headerlink" title="group by + having 的功能以及使用方法及其注意事项"></a>group by + having 的功能以及使用方法及其注意事项</h3>      <p>功能：一个数据表内的数据进行group by 分组后，在按照一定条件查询数据就要使用 having 关键字，而不能使用 where关键字了</p><p>语法：</p><p>1：select gender , avg(new_age)  as avg ,group_concat(name) from classes group by gender having avg &gt; 18 ;<br>表示按照gender进行分组后查询所有分组后数据的年龄平均值以及所有name字段的拼接字符串，在查询平均年龄大于18的数据</p><p>注意事项：</p><p>1：where关键字只能用在 group by 关键字前面，而having关键字只能用在group by 关键字前面</p><p>2：order by 关键字也只能放在 group by 关键字后面</p><p>3：where与having关键字的功能相同，都是按照某个条件查询数据</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203633969.png"  alt="image-20211011203633969">      </p>        <h2 id="limit限制记录【重点】"   >          <a href="#limit限制记录【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#limit限制记录【重点】" class="headerlink" title="limit限制记录【重点】"></a>limit限制记录【重点】</h2>              <h3 id="limit-关键字的功能"   >          <a href="#limit-关键字的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#limit-关键字的功能" class="headerlink" title="limit 关键字的功能"></a>limit 关键字的功能</h3>      <p>功能：在海量数据内查询部分数据是就可以用到limit关键字啦</p>        <h3 id="limit-关键字的使用方法及其注意事项"   >          <a href="#limit-关键字的使用方法及其注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#limit-关键字的使用方法及其注意事项" class="headerlink" title="limit 关键字的使用方法及其注意事项"></a>limit 关键字的使用方法及其注意事项</h3>      <p>语法：select * from 数据表名 limit 1 ，2；</p><p>其中 1 代表数据存储位置代号，2 代表从代号为 1 的数据开始查询2条数据</p><p>注意事项：limit关键字一定要写在mysql语法的最后面</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203715243.png"  alt="image-20211011203715243">      </p>        <h2 id="连接查询【重点、面试点】"   >          <a href="#连接查询【重点、面试点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接查询【重点、面试点】" class="headerlink" title="连接查询【重点、面试点】"></a>连接查询【重点、面试点】</h2>              <h3 id="连接查询的使用场景"   >          <a href="#连接查询的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接查询的使用场景" class="headerlink" title="连接查询的使用场景"></a>连接查询的使用场景</h3>      <p>答：当数据库内有多张表时，要从几张数据表内取一些数据并且连接到一张表内，这是就要用到连接查询</p>        <h3 id="mysql-数据库的几种连接查询方式"   >          <a href="#mysql-数据库的几种连接查询方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#mysql-数据库的几种连接查询方式" class="headerlink" title="mysql 数据库的几种连接查询方式"></a>mysql 数据库的几种连接查询方式</h3>      <p>1：内连接查询（inner join）【常用】</p><p>查询的结果为两个表所产生交集的数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203728204.png"  alt="image-20211011203728204">      </p><p>2：外左连接查询（left join）</p><p>查询的结果为两个表交集部分加上左表特有的数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203737285.png"  alt="image-20211011203737285">      </p><p>3：外右连接查询（right join）</p><p>查询的结果为两个表交集部分加上表特有的数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203742496.png"  alt="image-20211011203742496">      </p>        <h3 id="什么是笛卡尔积"   >          <a href="#什么是笛卡尔积" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是笛卡尔积" class="headerlink" title="什么是笛卡尔积"></a>什么是笛卡尔积</h3>      <p>答：对于两个数据表使用笛卡尔积，就是将第1张表的每一个数据与第2张表的每一个数据都进行一次排列产生总数据的表</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011203752250.png"  alt="image-20211011203752250">      </p><p>注意事项：笛卡尔积是表1的数据先与表2最后一项数据进行排列，依次类推</p>        <h3 id="内连接查询的使用方法"   >          <a href="#内连接查询的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#内连接查询的使用方法" class="headerlink" title="内连接查询的使用方法"></a>内连接查询的使用方法</h3>      <p>关键字：inner join</p><p>功能：查询两个表内有交集的数据</p><p>语法：select * from 表1 inner join 表2 where/on 表1.字段名 = 表2.字段名</p><p>表示查询表1与表2某个字段相等的那些数据项（条件关键字可以是where也可以是on）</p><p>注意事项：内连接语法内不加条件判断，默认是笛卡尔积</p><p>代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204209868.png"  alt="image-20211011204209868">      </p>        <h3 id="外左连接查询的使用方法"   >          <a href="#外左连接查询的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#外左连接查询的使用方法" class="headerlink" title="外左连接查询的使用方法"></a>外左连接查询的使用方法</h3>      <p>功能：查询两个表内相同的数据信息在加上左边表为空的那部分信息（主表的字段数据与从表的字段数据进行比对）</p><p>关键字：主表 left join 从表</p><p>其中主表为左表，从表为右表</p><p>语法：select * from classes left join phone on/where classes.new_age = phone.age;</p><p>表示classes主表内第一条记录的new_age字段值与phone从表的每一条记录的age字段值比对，有相同的则查询出来，当字段数据不相同时，也将数据显示出来，并且将从表phone的那部位用null补空，以此类推直到classes主表内的每一条记录的new_age字段值都比对完毕！</p><p>注意事项：主表第一行记录的字段数据与从表每一行记录都要进行比对，有相等的查询出来，全都比对完还是没有相等的，从表那部分字段数据用null补空！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204228413.png"  alt="image-20211011204228413">      </p>        <h3 id="外右连接查询的使用方法"   >          <a href="#外右连接查询的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#外右连接查询的使用方法" class="headerlink" title="外右连接查询的使用方法"></a>外右连接查询的使用方法</h3>      <p>功能：查询两个表内相同的数据信息在加上右边表为空的那部分信息（主表的字段数据与从表的字段数据进行比对）</p><p>关键字：从表 right join 主表表</p><p>其中主表为右表，从表为做表</p><p>语法：select * from classes right join phone on/where classes.new_age = phone.age;</p><p>表示phone主表内的第一条记录的age字段值与classes从表的每一条记录的new_age字段值比对，<br>有相同的则查询出来，当字段数据不相同时，也将数据显示出来，并且将从表classes的那部位用null补空，以此类推直到phone主表内的每一条记录的age字段值都比对完毕！</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204241438.png"  alt="image-20211011204241438">      </p>        <h2 id="自连接查询【理解】"   >          <a href="#自连接查询【理解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#自连接查询【理解】" class="headerlink" title="自连接查询【理解】"></a>自连接查询【理解】</h2>              <h3 id="自连接的使用场景"   >          <a href="#自连接的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#自连接的使用场景" class="headerlink" title="自连接的使用场景"></a>自连接的使用场景</h3>      <p>答：比如说省、市、县三级联动式就要用到自连接来查询数据，即找到自身数据表内的某种关系，从而取出某些数据</p>        <h3 id="自连接的使用方法"   >          <a href="#自连接的使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#自连接的使用方法" class="headerlink" title="自连接的使用方法"></a>自连接的使用方法</h3>      <p>含义：特殊的内连接，自己连接自己</p><p>关键字：数据表名 as 数据表别名1 inner join 数据表名 as 数据表别名2</p><p>例如： classes as a inner join classes as b</p><p>语法: select * from aress as a inner aress as b on a.aid = b.pid where a.name = “内蒙古”;</p><p>表示 aress 数据表自连接，查询a（aress）表的aid字段与b（aress）表的pid字段相等的数据项并且连接打印出来，从而实现查找某某县是属于哪个市的！</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204317242.png"  alt="image-20211011204317242">      </p><p>注意事项：数据表自连接时必须给自己取两个别名，否则会造成混淆，报错！！</p>        <h2 id="子查询【重点、面试点】"   >          <a href="#子查询【重点、面试点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#子查询【重点、面试点】" class="headerlink" title="子查询【重点、面试点】"></a>子查询【重点、面试点】</h2>              <h3 id="子查询的应用场景"   >          <a href="#子查询的应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#子查询的应用场景" class="headerlink" title="子查询的应用场景"></a>子查询的应用场景</h3>      <p>答：查询某个信息，一条SQL语句不能成功查询，需要多条SQL语句才可成功查询，这是就可以用到子查询（sql语句的嵌套）</p>        <h3 id="什么是子查询以及分类及其用法"   >          <a href="#什么是子查询以及分类及其用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是子查询以及分类及其用法" class="headerlink" title="什么是子查询以及分类及其用法"></a>什么是子查询以及分类及其用法</h3>      <p>子查询：子查询就是将一条或多条sql语句嵌套进另外一条SQL语句内，嵌套语句是子查询语句，被嵌套语句（外部）是主查询语句</p><p>例如 select * from classes where age &gt; (select avg(new_age) from phone);   黄色区域的就是子查询语句，外面的就是主查询语句</p><p>子查询语句的分类：</p><p>【重点】1.标量子查询：子查询语句返回的是一个数据，但不局限于数据（一行一列）</p><p>【重点】2.列子查询：子查询语句返回的是一列多行的数据</p><p>3.行子查询：子查询语句返回的是一行多列的数据</p><p>4.表子查询：子查询语句返回的是多行多列的数据</p><p>注意事项：子查询是一条完整独立的SQL语句</p><p>子查询的用法（代码示例）：</p><p>标量子查询语法：select * from classes where age &gt; (select avg(age) from classes) ;</p><p>表示查询 classes表内学生年龄age 大于学生平均年龄avg（age）的所有学生信息</p><p>——————————————————————————————————————————</p><p>普通语法：为了达到上面的结果，不使用子查询，需要写两条SQL语句才能实现</p><p>语句1：select avg（age） from classes；   先求出学生的平均年龄，假设是28<br>语句2：select * from classes where age &gt; 28； 在查询比平均年龄大的学生信息</p><p>———————————————————————————————————————————</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204342655.png"  alt="image-20211011204342655">      </p><p>列子查询语法：select * from classes where classes.new_age in (select age from phone）;<br> 表示查询出classes表内的new_age字段信息等于 phone表的age字段的所有学生信息</p><p>——————————————————————————————</p><p>普通语法：</p><p>语句1：select age from phone   先查询出phone表内的所有age字段信息，返回值是一列多行，假设为1，2，5</p><p>语句2：select * from classes where classes.new_age in (1，2，5）;</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204402251.png"  alt="image-20211011204402251">      </p>        <h2 id="数据的分页查询显示【目标】"   >          <a href="#数据的分页查询显示【目标】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据的分页查询显示【目标】" class="headerlink" title="数据的分页查询显示【目标】"></a>数据的分页查询显示【目标】</h2>              <h3 id="分页查询的使用场景"   >          <a href="#分页查询的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#分页查询的使用场景" class="headerlink" title="分页查询的使用场景"></a>分页查询的使用场景</h3>      <p>答：数据库内有大量数据且要呈现给用户时，我们就要将所有数据进行分页显示，每页规定好有几条数据！</p>        <h3 id="怎么实现数据的分页查询"   >          <a href="#怎么实现数据的分页查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么实现数据的分页查询" class="headerlink" title="怎么实现数据的分页查询"></a>怎么实现数据的分页查询</h3>      <p>答：利用 limit 限制记录可以实现分页查询</p><p>实现公式：limit （显示第几页 - 1 ）* 每页展示给用户的数据数量（每页几条数据），每页几条数据</p><p>公式详解：</p><p>1：（显示第几页 - 1 ）* 每页展示给用户的数据数量（每页几条数据） 代表数据存储代号</p><p>2：每页几条数据  代表查询几条数据</p><p>公式实例： limit （4-1）*6 ，6  实例表示向用户展示第四页数据，每页数据有6条，那么就会从数据存储代号为18的数据考试显示，显示6条！</p><p>公式截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204427513.png"  alt="image-20211011204427513">      </p><p>实例语法：select * from classes limit （3-1）<em>2 ，2 ；  这个语第法表示从classes数据表的所有数据内显示第3页的数据，每页2条数据<br>其中（3-1）</em>2 等于4 表示从数据存储代号为4的数据开始显示！！！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011204436010.png"  alt="image-20211011204436010">      </p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Mysql数据库内高级的操作指令，例如where比较运算、order排序、grep分组、连接查询等..&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/categories/Mysql%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/tags/Mysql%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql操作——常用指令</title>
    <link href="http://pythonlamb.github.io/2021/10/11/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://pythonlamb.github.io/2021/10/11/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2021-10-11T11:40:48.000Z</published>
    <updated>2021-10-11T12:00:16.531Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：常用的SQL指令等等….【重点】</p><span id="more"></span>        <h2 id="SQL指令——数据库的一般操作【重点】"   >          <a href="#SQL指令——数据库的一般操作【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——数据库的一般操作【重点】" class="headerlink" title="SQL指令——数据库的一般操作【重点】"></a>SQL指令——数据库的一般操作【重点】</h2>              <h3 id="SQL指令——show——查看所有数据库"   >          <a href="#SQL指令——show——查看所有数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——show——查看所有数据库" class="headerlink" title="SQL指令——show——查看所有数据库"></a>SQL指令——show——查看所有数据库</h3>      <p>指令功能：<br>1：查看当前连接的服务器所有的数据库信息<br>2：查看创建数据库的过程</p><p>指令示例：</p><p>1（查看所有数据库）：<code>show databases</code></p><p>2（查看数据库的创建过程）：<code>show create database 数据库名</code></p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011194938794.png"  alt="image-20211011194938794">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011194953090.png"  alt="image-20211011194953090">      </p>        <h3 id="SQL指令——select——查看当前所在的数据库"   >          <a href="#SQL指令——select——查看当前所在的数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——select——查看当前所在的数据库" class="headerlink" title="SQL指令——select——查看当前所在的数据库"></a>SQL指令——select——查看当前所在的数据库</h3>      <p>功能：查看当前所在的数据库</p><p>指令格式：<code>select database（）；</code></p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195019906.png"  alt="image-20211011195019906">      </p>        <h3 id="SQL指令——create——创建数据库"   >          <a href="#SQL指令——create——创建数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——create——创建数据库" class="headerlink" title="SQL指令——create——创建数据库"></a>SQL指令——create——创建数据库</h3>      <p>功能：创建数据库</p><p>指令：</p><p>1(创建不指定编码的数据库)：<code>create database 数据库名;</code><br>2（创建指定编码的字符集）：<code>create database 数据库名 charset = 字符集;</code></p><p>​    </p><p>指令示例：</p><p>1：<code>create database name1；</code> 表示创建一个名为name1不指定编码的数据库</p><p>2：<code>create database name1 charset = utf8；</code> 表示创建一个名为name1编码为utf8的数据库</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195036096.png"  alt="image-20211011195036096">      </p>        <h3 id="SQL指令——drop——删除数据库"   >          <a href="#SQL指令——drop——删除数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——drop——删除数据库" class="headerlink" title="SQL指令——drop——删除数据库"></a>SQL指令——drop——删除数据库</h3>      <p>功能：删除指定MySQL数据库</p><p>指令：<code>drop database 数据库名</code></p><p>示例：<code>drop database python_ceshi1</code></p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195048859.png"  alt="image-20211011195048859">      </p>        <h3 id="SQL指令——use——选择指定数据库"   >          <a href="#SQL指令——use——选择指定数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——use——选择指定数据库" class="headerlink" title="SQL指令——use——选择指定数据库"></a>SQL指令——use——选择指定数据库</h3>      <p>功能：选择指定的数据库</p><p>指令：<code>use 数据库名</code></p><p>指令示例：<code>use python_database</code></p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195058818.png"  alt="image-20211011195058818">      </p><p>总结：<br>1：在使用 create 创建数据库的时候建议加上charset = utf8，要不然数据库容易出现乱码<br>2：最常用的数据库操作指令 show 、create 、use</p>        <h2 id="SQL指令——表的创建【重点】"   >          <a href="#SQL指令——表的创建【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——表的创建【重点】" class="headerlink" title="SQL指令——表的创建【重点】"></a>SQL指令——表的创建【重点】</h2>              <h3 id="SQL指令——create-在数据库内创建数据表"   >          <a href="#SQL指令——create-在数据库内创建数据表" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——create-在数据库内创建数据表" class="headerlink" title="SQL指令——create 在数据库内创建数据表"></a>SQL指令——create 在数据库内创建数据表</h3>      <p>功能：在指定的数据库内创建数据表，用来存放数据</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令语法：create table 表名（</span><br><span class="line">字段1的名称  字段1的数据类型 字段1的约束条件 ，</span><br><span class="line">字段2的名称  字段2的数据类型 字段2的约束条件 ，</span><br><span class="line">字段3的名称  字段3的数据类型 字段3的约束条件 </span><br><span class="line"></span><br><span class="line">）；</span><br></pre></td></tr></table></div></figure><p>注意事项：</p><p>1：每一个字段类型创建完毕后，都要在后面加上，最后一个字段除外</p><p>2：字段的约束条件很多，可以是不为空（not null）、自动增长（auto_increment）、无符号(unsight)、主键约束（primary key）等等</p><p>3：创建表时不要忘记最后括号外面的；号</p><p>4：id字段（数据表第一个字段）一般约束为 (primary key主键) 与 (auto_increment自动增长)</p><p>5：字段的约束条件可不写</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195129435.png"  alt="image-20211011195129435">      </p>        <h3 id="SQL指令——show查看数据库内的数据表"   >          <a href="#SQL指令——show查看数据库内的数据表" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——show查看数据库内的数据表" class="headerlink" title="SQL指令——show查看数据库内的数据表"></a>SQL指令——show查看数据库内的数据表</h3>      <p>功能：查看指定数据库内的所有数据表</p><p>语法：<code>show tables；</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195142293.png"  alt="image-20211011195142293">      </p>        <h3 id="SQL指令——desc查看一个数据表内的所有字段信息"   >          <a href="#SQL指令——desc查看一个数据表内的所有字段信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——desc查看一个数据表内的所有字段信息" class="headerlink" title="SQL指令——desc查看一个数据表内的所有字段信息"></a>SQL指令——desc查看一个数据表内的所有字段信息</h3>      <p>功能：查看指定数据表内的所有字段信息</p><p>语法：<code>desc 数据表名；</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195153531.png"  alt="image-20211011195153531">      </p>        <h3 id="SQL指令——show-create-table-查看一个数据表的创建过程"   >          <a href="#SQL指令——show-create-table-查看一个数据表的创建过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——show-create-table-查看一个数据表的创建过程" class="headerlink" title="SQL指令——show create table 查看一个数据表的创建过程"></a>SQL指令——show create table 查看一个数据表的创建过程</h3>      <p>功能：查看指定数据表的创建过程</p><p>语法：</p><p>1：<code>show create table 数据表名 ; </code>   (虚线模式查看建表过程，较乱)<br>2：<code>show create table 数据表名 \G ;  </code>  （星号模式查看建表过程）</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195209887.png"  alt="image-20211011195209887">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195216854.png"  alt="image-20211011195216854">      </p>        <h3 id="SQL指令——drop-删除指定的数据表"   >          <a href="#SQL指令——drop-删除指定的数据表" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——drop-删除指定的数据表" class="headerlink" title="SQL指令——drop 删除指定的数据表"></a>SQL指令——drop 删除指定的数据表</h3>      <p>功能：删除指定的数据表</p><p>语法：<code>drop table 数据表名</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195226698.png"  alt="image-20211011195226698">      </p>        <h2 id="SQL指令——清除表内数据【重点】"   >          <a href="#SQL指令——清除表内数据【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——清除表内数据【重点】" class="headerlink" title="SQL指令——清除表内数据【重点】"></a>SQL指令——清除表内数据【重点】</h2>              <h3 id="如何清除表内的数据"   >          <a href="#如何清除表内的数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何清除表内的数据" class="headerlink" title="如何清除表内的数据"></a>如何清除表内的数据</h3>      <p>语法：<code>truncate table 数据表名</code></p>        <h2 id="SQL指令——表结构（字段）的修改【重点】"   >          <a href="#SQL指令——表结构（字段）的修改【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——表结构（字段）的修改【重点】" class="headerlink" title="SQL指令——表结构（字段）的修改【重点】"></a>SQL指令——表结构（字段）的修改【重点】</h2>      <p>前言：本节课适用场景</p><p>答：在创建好一个数据表情况下，发现这个数据表内的结构不满足条件，这时我们就要对这个数据表进行修改！</p><p>本节必须注意：一个项目运行起来之后，我们就要谨慎修改数据表内的字段！否则会造成项目的瘫痪，那有什么办法可以避免修改数据库字段的情况呢？</p><p>答：在创建数据表时，多创建几个空闲字段！</p><p>目标：</p><p>1：掌握SQL指令——add 向数据表内添加字段<br>2：掌握SQL指令——change 修改数据表内字段的名称<br>3：掌握SQL指令——modify 修改数据表内字段类型<br>4：掌握SQL指令——drop 删除数据表内某一个字段</p>        <h3 id="SQL指令——add-向数据表内添加字段"   >          <a href="#SQL指令——add-向数据表内添加字段" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——add-向数据表内添加字段" class="headerlink" title="SQL指令——add 向数据表内添加字段"></a>SQL指令——add 向数据表内添加字段</h3>      <p>功能：向指定数据表内添加一个新的字段</p><p>语法：<code>alter table 表名 add 新字段名 字段类型 约束条件；</code></p><p>注意事项：在添加字段时约束条件可有可无</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195257504.png"  alt="image-20211011195257504">      </p>        <h3 id="SQL指令——change-修改数据表内字段的名称"   >          <a href="#SQL指令——change-修改数据表内字段的名称" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——change-修改数据表内字段的名称" class="headerlink" title="SQL指令——change 修改数据表内字段的名称"></a>SQL指令——change 修改数据表内字段的名称</h3>      <p>功能：修改指定数据表内指定字段的名称</p><p>语法：<code>alter table 表名 change 原字段名 新字段名 新字段类型 约束条件；</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195308611.png"  alt="image-20211011195308611">      </p>        <h3 id="SQL指令——modify-修改数据表内字段类型"   >          <a href="#SQL指令——modify-修改数据表内字段类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——modify-修改数据表内字段类型" class="headerlink" title="SQL指令——modify 修改数据表内字段类型"></a>SQL指令——modify 修改数据表内字段类型</h3>      <p>功能：修改指定数据表内的指定字段的数据类型</p><p>语法：<code>alter table 表名 modify 字段名 新的数据类型 约束条件</code></p><p>注意事项：约束条件可不写</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195319203.png"  alt="image-20211011195319203">      </p>        <h3 id="SQL指令——drop-删除数据表内某一个字段"   >          <a href="#SQL指令——drop-删除数据表内某一个字段" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——drop-删除数据表内某一个字段" class="headerlink" title="SQL指令——drop 删除数据表内某一个字段"></a>SQL指令——drop 删除数据表内某一个字段</h3>      <p>功能：删除指定数据表内的指定字段</p><p>语法：<code>alter table 表名 drop 字段名</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195328433.png"  alt="image-20211011195328433">      </p>        <h2 id="SQL指令——数据表内数据的增删改查【重点】"   >          <a href="#SQL指令——数据表内数据的增删改查【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——数据表内数据的增删改查【重点】" class="headerlink" title="SQL指令——数据表内数据的增删改查【重点】"></a>SQL指令——数据表内数据的增删改查【重点】</h2>              <h3 id="SQL指令——select-查看数据表内字段的数据"   >          <a href="#SQL指令——select-查看数据表内字段的数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——select-查看数据表内字段的数据" class="headerlink" title="SQL指令——select 查看数据表内字段的数据"></a>SQL指令——select 查看数据表内字段的数据</h3>      <p>功能：查看数据表内字段的数据信息</p><p>语法：</p><p>1：<code>select * from 数据表名 ； </code> （表示查看数据表内所有字段的数据信息）</p><p>2：<code>select id ，name from 数据表名；</code>  （表示查看数据表内id和name字段的所有信息）</p><p>3：<code>select id as “编号”,name as &quot;姓名&quot; from 数据表名 ；</code> （表示查询id与name字段的数据，以id别名编号与name别名姓名显示出来！！！）</p><p>4：<code>select id  “编号”，name  “姓名” from 数据表名；</code>（表示查询id与name字段的数据，以id别名编号与name别名姓名显示出来！！！）注意: id与name后面的空格类似于as的功能</p><p>5：<code>select * from 数据表名 where id = 1；</code> （表示查看id为1那个记录的所有字段的信息） </p><p>注意事项：</p><p>1：<code>select  id ，name from 数据表名；</code> 这样查出来的数据 id字段数据在 name字段数据前面显示</p><p>2：查询字段的数据信息，如果一个数据表内没有数据，查询为空</p><p>快速代码体验</p><p>字段有数据查询全部</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195406050.png"  alt="image-20211011195406050">      </p><p>字段有数据查询全部</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195429410.png"  alt="image-20211011195429410">      </p><p>有数据查询指定别名字段数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195439947.png"  alt="image-20211011195439947">      </p>        <h3 id="SQL指令——insert-向数据表内增加数据"   >          <a href="#SQL指令——insert-向数据表内增加数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——insert-向数据表内增加数据" class="headerlink" title="SQL指令——insert 向数据表内增加数据"></a>SQL指令——insert 向数据表内增加数据</h3>      <p>功能：向指定数据表内添加数据</p><p>语法：</p><p>1：<code>insert  into  数据表名  value（字段1的值，字段2的值…….）</code>  【表示向数据表内添加所有字段的一行（记录）数据信息】</p><p>2：<code>insert into 数据表名 value （字段1的值，字段2的值…）</code>，（字段1的值，字段2的值…）  【表示向数据表内添加所有字段的两行数据信息】</p><p>3：<code>insert into 数据表名（id，name）value（id字段的值，name字段的值…）</code>   【表示向数据表内添加id字段与name字段的一行信息】</p><p>注意事项：</p><p>1：如果某个字段设置为自动增长，那么在向这个字段添加数据时可为空（null），系统会实现数据自动增长</p><p>2：书写增加数据语句时可以写 value 也可以写 values</p><p>快速代码体验：</p><p>向数据表内添加多个记录（多行）数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195504599.png"  alt="image-20211011195504599">      </p><p>向指定字段添加数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195511467.png"  alt="image-20211011195511467">      </p>        <h3 id="SQL指令——update-更改数据表内的数据"   >          <a href="#SQL指令——update-更改数据表内的数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——update-更改数据表内的数据" class="headerlink" title="SQL指令——update 更改数据表内的数据"></a>SQL指令——update 更改数据表内的数据</h3>      <p>功能：对数据表内的已存在数据进行更改更新</p><p>语法：</p><p>1：<code>update 数据表名 set  字段名 = 更改值 </code>  （表示对数据表内某个字段的所有数据【全部记录】全部更改）</p><p>2：<code>update 数据表名 set 字段名 = 更改值 where id = 1</code>   （表示对数据表内id等于1的记录的某个字段的数据进行更改）</p><p>3：<code>update 数据表名 set 字段名1 = 更改值1，字段名2 = 更改值2</code> （表示更改多个字段的所有数据）</p><p>快速代码体验</p><p>更改一个字段的所有数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195534216.png"  alt="image-20211011195534216">      </p><p>更改指定一个记录的数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195540970.png"  alt="image-20211011195540970">      </p>        <h3 id="SQL指令——delete-删除数据表中的指定数据"   >          <a href="#SQL指令——delete-删除数据表中的指定数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——delete-删除数据表中的指定数据" class="headerlink" title="SQL指令——delete 删除数据表中的指定数据"></a>SQL指令——delete 删除数据表中的指定数据</h3>      <p>功能：物理删除指定数据表内的指定数据</p><p>语法：</p><p>1：<code>delete from 数据表名 </code> （表示删除数据表内的所有数据）</p><p>2：<code>delete from 数据表名 where id = 1 </code> （表示删除数据表内 id字段等于 1 那个记录的数据）</p><p>注意事项：delete指令是物理删除数据，不能恢复，我们可以选择逻辑删除从而更好地保存数据</p><p>快速代码体验</p><p>删除数据表内所有数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195556152.png"  alt="image-20211011195556152">      </p><p>删除指定条件（指定记录）的数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195602737.png"  alt="image-20211011195602737">      </p>        <h3 id="逻辑删除数据表内的数据"   >          <a href="#逻辑删除数据表内的数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#逻辑删除数据表内的数据" class="headerlink" title="逻辑删除数据表内的数据"></a>逻辑删除数据表内的数据</h3>      <p>实现方法：</p><p>第一步：向数据表内添加一个新的字段 字段名为 is_delete  字段属性为bit 字段默认值为 0</p><p>第二步：将需要删除的一个记录（一行）数据的 is_delete那个字段数据默认值更改为 1</p><p>第三步：查找is_delete 那个字段值为0的所有记录信息，默认值为0的那个记录不出现 就实现了逻辑删除</p><p>实现代码：</p><p>1.添加新字段：<code>alter table 数据表名 add  is_delete  bit  default 0 ;</code></p><p>2.更给默认值：<code> update 数据表名 set is_delect default = 1 where id = 2;</code></p><p>3.查找数据：<code>select * from 数据表名 where is_delete = 0 ;</code></p><p>注意事项：<br>1：新建一个字段名为 is_delete的字段而不是 is_delect的字段（截图创建的就是错误的）</p><p>2：创建is_delete字段时，字段的类型为bit，且默认值为0</p><p>3：bit数据类型只能存放两个值即0与1</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195700792.png"  alt="image-20211011195700792">      </p>        <h2 id="SQL指令——数据库的备份与恢复【重点】"   >          <a href="#SQL指令——数据库的备份与恢复【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL指令——数据库的备份与恢复【重点】" class="headerlink" title="SQL指令——数据库的备份与恢复【重点】"></a>SQL指令——数据库的备份与恢复【重点】</h2>              <h3 id="在Linux终端将指定数据库备份（导出）为SQL文件"   >          <a href="#在Linux终端将指定数据库备份（导出）为SQL文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#在Linux终端将指定数据库备份（导出）为SQL文件" class="headerlink" title="在Linux终端将指定数据库备份（导出）为SQL文件"></a>在Linux终端将指定数据库备份（导出）为SQL文件</h3>      <p>功能：将数据库导出到计算机磁盘中（后缀为sql的文件）</p><p>导出语法： <code>mysqldump -u 用户名 -p  数据库名  &gt;  数据库文件名.sql</code></p><p>示例： <code>mysqldump -u root -p python_ceshi1 &gt; python_ceshi2.sql</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195716350.png"  alt="image-20211011195716350">      </p>        <h3 id="在Linux终端将SQL文件导入到创建好的数据库中，以实现恢复数据库数据"   >          <a href="#在Linux终端将SQL文件导入到创建好的数据库中，以实现恢复数据库数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#在Linux终端将SQL文件导入到创建好的数据库中，以实现恢复数据库数据" class="headerlink" title="在Linux终端将SQL文件导入到创建好的数据库中，以实现恢复数据库数据"></a>在Linux终端将SQL文件导入到创建好的数据库中，以实现恢复数据库数据</h3>      <p>功能：将后缀为SQL文件导入创建好的数据库中，实现恢复数据库数据（数据表）功能</p><p>导入语法：<code>mysql -u 用户名 -p 数据库名 &lt; 后缀为SQL的文件</code></p><p>示例：<code>mysql -u root -p python_ceshi &lt; python_ceshi2.sql </code>  (表示将python_ceshi2.sql脚本文件导入到名为python_ceshi这个数据库中)</p><p>注意事项：因意外原因造成数据库删除，这是我们要新建一个同名的数据库，然后再把后缀为sql的备份文件导入才会成功，否则导入失败！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011195734526.png"  alt="image-20211011195734526">      </p><p>未完待续….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：常用的SQL指令等等….【重点】&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/categories/Mysql%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/tags/Mysql%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql操作——数据库基础</title>
    <link href="http://pythonlamb.github.io/2021/10/11/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>http://pythonlamb.github.io/2021/10/11/Mysql%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2021-10-11T10:02:53.000Z</published>
    <updated>2021-10-11T11:39:34.292Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：关系型数据库的概念、及其一些核心的元素与简单的语法等等…..</p><span id="more"></span>        <h2 id="数据库概念及作用【了解】"   >          <a href="#数据库概念及作用【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库概念及作用【了解】" class="headerlink" title="数据库概念及作用【了解】"></a>数据库概念及作用【了解】</h2>              <h3 id="数据库的功能"   >          <a href="#数据库的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的功能" class="headerlink" title="数据库的功能"></a>数据库的功能</h3>      <p>概念：数据库是以一定格式组织的数据集合，通俗来说就是计算机内一些具有特殊格式的数据文件集合（数据库是文件）</p><p>作用：存储数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011192834538.png"  alt="image-20211011192834538">      </p><p>抛出问题：既然数据库是一种文件，那么我们为什么不用其他文件存储数据呢？因为数据库有以下优点！</p><p>1：持久化存储</p><p>2：读写速度极快</p><p>3：保证数据的有效性</p><p>4：对程序的兼容性好，容易扩展</p>        <h2 id="数据库的分类及特点【了解】"   >          <a href="#数据库的分类及特点【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的分类及特点【了解】" class="headerlink" title="数据库的分类及特点【了解】"></a>数据库的分类及特点【了解】</h2>      <p>据库排名网站：<span class="exturl"><a class="exturl__link"   href="https://db-engines.com/en/ranking" >https://db-engines.com/en/ranking</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="数据库的分类"   >          <a href="#数据库的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3>      <p>数据库一般分为关系型数据以及非关系型数据库</p>        <h3 id="不同分类数据库的概念与特点"   >          <a href="#不同分类数据库的概念与特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同分类数据库的概念与特点" class="headerlink" title="不同分类数据库的概念与特点"></a>不同分类数据库的概念与特点</h3>      <p>关系型数据库：是指采用关系模型来组织数据的数据库，通俗来说采用二维表格组织数据的数据库就是关系型数据库</p><p>二维表示例</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011192909691.png"  alt="image-20211011192909691">      </p><p>关系型数据库的主要产品：MySQL 、Orcle、SQLite（移动端）SQLServer</p><p>MySQL官网：<span class="exturl"><a class="exturl__link"   href="https://www.mysql.com/" >https://www.mysql.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>————————————————————————————————————————————————————</p><p>非关系型数据库概念：非关系型数据库也称为 NoSQL，即 not only SQL  ，它是利用键值对 key-value等方式来存储数据的！</p><p>非关系型数据库主要产品：MongoDB 、Redis</p>        <h3 id="关系型数据库与非关系型数据库的对比分析"   >          <a href="#关系型数据库与非关系型数据库的对比分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#关系型数据库与非关系型数据库的对比分析" class="headerlink" title="关系型数据库与非关系型数据库的对比分析"></a>关系型数据库与非关系型数据库的对比分析</h3>      <p>关系型数据库优点：</p><p>1：用的是表结构存储数据，容易理解</p><p>2：使用的是通用的SQL语言</p><p>3：减少了数据的冗余和数据不一致的情况发生</p><p>4：可以进行表与表之间的复杂查询</p><p>关系型数据库缺点：</p><p>1：固定的表结构、灵活性不高</p><p>2：为了维护表结构而牺牲大量的读写速度</p><p>3：高并发读写能力差</p><p>非关系型数据库优点：</p><p>1：格式灵活，数据类型多种多样，可以是键对值，甚至是文档，图片，应用场景广泛，但是关系型数据库只支持原有的数据类型</p><p>2：数据没有耦合性，容易扩展</p><p>3：无需通过SQL层解析，读写能力较高</p><p>4：成本低、NoSQL基本都是开源，部署简单</p><p>非关系型数据库缺点：</p><p>1：不提供SQL支持、学习成本高</p><p>2：在数据复杂查询方面比较麻烦</p><p>以上信息参考网站：<span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/zedian752/p/11338139.html" >https://www.cnblogs.com/zedian752/p/11338139.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="数据库管理系统与SQL【了解】"   >          <a href="#数据库管理系统与SQL【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库管理系统与SQL【了解】" class="headerlink" title="数据库管理系统与SQL【了解】"></a>数据库管理系统与SQL【了解】</h2>              <h3 id="数据库与数据库管理系统的关系"   >          <a href="#数据库与数据库管理系统的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库与数据库管理系统的关系" class="headerlink" title="数据库与数据库管理系统的关系"></a>数据库与数据库管理系统的关系</h3>      <p>数据库管理系统概念：为了管理数据库而设计开发的软件系统，简称DBMS，它分为三大部分，如下！</p><p>1.数据库文件集合：主要是一系列文件，这些文件用来存储数据</p><p>2.数据库服务端：主要负责对数据库的文件和文件内数据进行管理</p><p>3.数据库客户端：与数据库服务端进行通信，负责用来传输数据以及接收数据</p><p>图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011192948605.png"  alt="image-20211011192948605">      </p><p>注意事项：数据库客户端想要通过数据库服务器获得或存储数据需要使用特殊的语言（SQL）</p><p>数据库与数据库管理系统的关系：数据库是一些特殊格式文件的集合，而数据库管理系统是对数据库文件进行管理的软件系统</p>        <h3 id="SQL语句"   >          <a href="#SQL语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3>      <p>概念：SQL是结构化查询语言，是一种用来操作 RDBMS (关系型数据库) 的数据库语言，它几乎支持所有的关系型数据库的数据管理操作，也就是说SQL是关系型数据库实现数据库客户端与数据库服务端通信的语言</p><p>语法表现形式：具有特殊格式的字符串</p><p>SQL语言的分类：</p><p>DQL：数据查询语言、用于对数据的查询，例如select命令</p><p>DML：数据操作语言、用于对数据记性增加、删除、修改，例如insert、delete、udpate命令</p><p>DDL： 数据定义语言、用于新建、删除数据库、表等，例如create（新建）、drop（删除）命令</p><p>TPL：  数据库处理语言、…….</p><p>DCL： 数据库控制语言、……..</p><p>主要学习前三个SQL语言即DQL（数据库查询语言） DML（数据库操作语言） DDL（数据库定义语言）</p>        <h2 id="关系型数据库中的核心元素【重点】"   >          <a href="#关系型数据库中的核心元素【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#关系型数据库中的核心元素【重点】" class="headerlink" title="关系型数据库中的核心元素【重点】"></a>关系型数据库中的核心元素【重点】</h2>      <p>一：关系型数据库中的核心元素</p><p>前言：关系型数据库是由不同数目的数据二维表构成，而数据二维表由数据行与数据列构成</p><p>关系型数据库的核心元素：</p><p>数据库：数据表的集合</p><p>数据表：用来存放数据的二维表</p><p>数据行（记录）：构成数据表的行</p><p>数据列（字段）：构成数据表的列</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193040501.png"  alt="image-20211011193040501">      </p><p>注意事项：</p><p>1：数据表中每一个数据列（每一列）的数据类型都是相同的（字段），每一个数据行都是一个完成的数据实体（记录）</p><p>2：在关系型数据中心将二维表内的一行称为一个记录，一列称为一个字段</p><p>​        </p><p>二：数据存入关系型数据库的步骤</p><p>1：新建一个数据库</p><p>2：创建存放数据的二维表</p><p>3：将数据存入到数据表内</p>        <h2 id="MySQL数据库的环境搭建【了解】"   >          <a href="#MySQL数据库的环境搭建【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL数据库的环境搭建【了解】" class="headerlink" title="MySQL数据库的环境搭建【了解】"></a>MySQL数据库的环境搭建【了解】</h2>              <h3 id="掌握MySQL数据库的环境搭建及其操作方法"   >          <a href="#掌握MySQL数据库的环境搭建及其操作方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#掌握MySQL数据库的环境搭建及其操作方法" class="headerlink" title="掌握MySQL数据库的环境搭建及其操作方法"></a>掌握MySQL数据库的环境搭建及其操作方法</h3>      <p>第一步：安装MySQL数据库的服务端（默认创建服务端以及数据库文件）<br>终端指令：sudo apt-get install  mysql-server</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193105730.png"  alt="image-20211011193105730">      </p><p>第二步：安装mysql数据库的客户端（图形化客户端）—— navicat </p><p>1：网上下载 navicat安装包 </p><p>2：运行navicat这个包即可</p><p>看截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193117486.png"  alt="image-20211011193117486">      </p>        <h3 id="数据库操作指令"   >          <a href="#数据库操作指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库操作指令" class="headerlink" title="数据库操作指令"></a>数据库操作指令</h3>      <p>1：启动数据库 sudo service mysql start</p><p>2：重启数据库 sudo service mysql restart</p><p>3：停止数据库 sudo service mysql stop</p><p>4：查看进程中是否存在 mysql服务   ps -ajx | grep mysql</p><p>指令解析：其中 ps 为linux查看所有进程指令 -ajx 为选项 -a 代表显示所有用户进程 -j代表任务格式显示进程 -x代表显示无控制终端进程    | 是管道指令    grep mysql 表示查看mysql的进程</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193158819.png"  alt="image-20211011193158819">      </p>        <h3 id="mysql数据库配置文件位置"   >          <a href="#mysql数据库配置文件位置" class="heading-link"><i class="fas fa-link"></i></a><a href="#mysql数据库配置文件位置" class="headerlink" title="mysql数据库配置文件位置"></a>mysql数据库配置文件位置</h3>      <p>路径：/etc/mysql/mysql.conf.d/mysqld.cnf</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193208464.png"  alt="image-20211011193208464">      </p><p>配置属性如下：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193215786.png"  alt="image-20211011193215786">      </p>        <h3 id="linux终端（客户端）连接mysql数据库与退出数据库"   >          <a href="#linux终端（客户端）连接mysql数据库与退出数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#linux终端（客户端）连接mysql数据库与退出数据库" class="headerlink" title="linux终端（客户端）连接mysql数据库与退出数据库"></a>linux终端（客户端）连接mysql数据库与退出数据库</h3>      <p>前言：在利用指令 sudo apt-get install  mysql-server  安装mysql数据库服务端时，默认也安装了mysql客户端，我们可以实现在Linux终端连接 mysql 数据库</p><p>连接数据库指令：mysql -u root -p </p><p>注意事项：</p><p>1：再终端利用上述指令连接mysql数据库时，应先利用指令 sudo -s 进入管理员用户 才能连接mysql数据库</p><p>2：mysql刚安装时默认密码为空，在后期可以通过指令更改密码</p><p>3：linux终端连接数据库成功后，我们在终端输入SQL语句指令就可以控制 mysql 数据库了</p><p>指令解析：-u 代表用户选项 root代表用户名 -p 代表数据库密码选项</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193244856.png"  alt="image-20211011193244856">      </p><p>退出数据库指令：exit 、 quit 、Ctrl键+D键</p>        <h2 id="MySQL数据库完整性约束【重点】"   >          <a href="#MySQL数据库完整性约束【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL数据库完整性约束【重点】" class="headerlink" title="MySQL数据库完整性约束【重点】"></a>MySQL数据库完整性约束【重点】</h2>              <h3 id="数据库完整性约束"   >          <a href="#数据库完整性约束" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h3>      <p>概念：数据库完整性约束用于保证数据的正确性，数据库客户端在更新、插入、删除数据时需要检查数据的完整性，核实其约束条件，从而保证更新数据时是正确的。</p><p>关系型数据库（mysql、二维表）完整性约束的分类：实体完整性、域完整性、参照完整性、用户定义完整性</p>        <h3 id="关系型数据库的几类完整性约束"   >          <a href="#关系型数据库的几类完整性约束" class="heading-link"><i class="fas fa-link"></i></a><a href="#关系型数据库的几类完整性约束" class="headerlink" title="关系型数据库的几类完整性约束"></a>关系型数据库的几类完整性约束</h3>      <p>1：实体完整性约束</p><p>概念：实体完整性要求关系型数据库二维表的一个记录中（一行）只有一个主键，且不同记录的主键值不能重复也不能为空</p><p>图示（主键约束）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193303887.png"  alt="image-20211011193303887">      </p><p>2：域完整性约束</p><p>概念：域完整性是指关系型数据库二维表内的一列（字段）的数据类型都是相同的，还有可以约束字段其取值范围、精度等</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193316428.png"  alt="image-20211011193316428">      </p><p>3：参照完整性约束</p><p>概念：参照完整性是关系型数据库内的父表删除某一个记录（一行）后，子表内的该记录（一行）也要删除！（父表与子表存在一定联系！）</p><p>4：用户定义完整性约束</p><p>概念：用户定义完整性是指关系型数据库二维表内的一个字段数据类型需要满足用户规定的类型，比如说，用户规定一个字段数据类型只能是数字，那么就不能向字段内添加其余的数据类型，再比如，用户要求一个字段内数据只能填写 男、女，用户就不能向这个字段内填写其他的数据！！</p><p>————————————————————————————————————————</p>        <h3 id="not-null-、primary-key、unique-key、default、foreign-key-这几个约束分别属于什么类型的约束！"   >          <a href="#not-null-、primary-key、unique-key、default、foreign-key-这几个约束分别属于什么类型的约束！" class="heading-link"><i class="fas fa-link"></i></a><a href="#not-null-、primary-key、unique-key、default、foreign-key-这几个约束分别属于什么类型的约束！" class="headerlink" title="not null 、primary key、unique key、default、foreign key 这几个约束分别属于什么类型的约束！"></a>not null 、primary key、unique key、default、foreign key 这几个约束分别属于什么类型的约束！</h3>      <p>primary key：主键约束（要求主键列的数据唯一，且不为空！）它属于实体完整性约束</p><p>unique key：唯一约束（唯一性、可以空，但只能有一个）它属于实体完整性约束</p><p>not null：非空约束（设置该字段不能为空） 它属于域完整性约束</p><p>default：默认约束 （设置该字段数据的默认值）它属于域完整性约束</p><p>foreign key：外键约束（建立两表的关系）它数据参照完整性约束</p>        <h2 id="客户端Navicat的使用【理解】"   >          <a href="#客户端Navicat的使用【理解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#客户端Navicat的使用【理解】" class="headerlink" title="客户端Navicat的使用【理解】"></a>客户端Navicat的使用【理解】</h2>              <h3 id="navicat-连接-本地mysql数据库的界面"   >          <a href="#navicat-连接-本地mysql数据库的界面" class="heading-link"><i class="fas fa-link"></i></a><a href="#navicat-连接-本地mysql数据库的界面" class="headerlink" title="navicat 连接 本地mysql数据库的界面"></a>navicat 连接 本地mysql数据库的界面</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193402647.png"  alt="image-20211011193402647">      </p><p>连接本地数据库服务器！成功后，本地数据库自带的四个数据库文件！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193409940.png"  alt="image-20211011193409940">      </p>        <h3 id="使用-Navica-t创建数据库"   >          <a href="#使用-Navica-t创建数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-Navica-t创建数据库" class="headerlink" title="使用 Navica t创建数据库"></a>使用 Navica t创建数据库</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193417066.png"  alt="image-20211011193417066">      </p>        <h3 id="使用-Navicat-在数据库内创建数据二维表"   >          <a href="#使用-Navicat-在数据库内创建数据二维表" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-Navicat-在数据库内创建数据二维表" class="headerlink" title="使用 Navicat 在数据库内创建数据二维表"></a>使用 Navicat 在数据库内创建数据二维表</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193426124.png"  alt="image-20211011193426124">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193434572.png"  alt="image-20211011193434572">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193443505.png"  alt="image-20211011193443505">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193450447.png"  alt="image-20211011193450447">      </p><p>注意事项：在新建的表栏右击选择设计表可重新编辑这个二维表</p>        <h3 id="使用-Navicat-向数据库内添加数据！"   >          <a href="#使用-Navicat-向数据库内添加数据！" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-Navicat-向数据库内添加数据！" class="headerlink" title="使用 Navicat 向数据库内添加数据！"></a>使用 Navicat 向数据库内添加数据！</h3>      <p>增加数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193502928.png"  alt="image-20211011193502928">      </p><p>删除数据</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193510093.png"  alt="image-20211011193510093">      </p>        <h3 id="Navicat-共享数据库（导出SQL文件）以及导入别人的SQL文件"   >          <a href="#Navicat-共享数据库（导出SQL文件）以及导入别人的SQL文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#Navicat-共享数据库（导出SQL文件）以及导入别人的SQL文件" class="headerlink" title="Navicat 共享数据库（导出SQL文件）以及导入别人的SQL文件"></a>Navicat 共享数据库（导出SQL文件）以及导入别人的SQL文件</h3>      <p>导出 SQL 文件</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193527692.png"  alt="image-20211011193527692">      </p><p>导入别人的 SQL 文件</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193534749.png"  alt="image-20211011193534749">      </p><p>注意事项：</p><p>1：需要在建立的数据库栏右击才有运行 SQL 文件</p><p>2：导入别人的SQL文件成功后，需要重启数据库才能看到导入的数据表（图示的数据库为 python_database）</p>        <h2 id="Navicat远程连接服务区数据库【重点】"   >          <a href="#Navicat远程连接服务区数据库【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#Navicat远程连接服务区数据库【重点】" class="headerlink" title="Navicat远程连接服务区数据库【重点】"></a>Navicat远程连接服务区数据库【重点】</h2>      <p>目标：掌握怎么在 Windows 系统内的 Navicat 软件上远程连接在Linux服务器上的数据库！</p><p>前言：我们在做web开发时，我们的数据库都是存放在服务器上面（linux系统），而且这个服务器是远程服务器，不在我们身边，这是我们就要学会利用 windows系统远程连接服务器数据库了！</p>        <h3 id="在-Windows-系统内的-Navicat-软件上远程连接在Linux服务器上的-mysql-数据库！"   >          <a href="#在-Windows-系统内的-Navicat-软件上远程连接在Linux服务器上的-mysql-数据库！" class="heading-link"><i class="fas fa-link"></i></a><a href="#在-Windows-系统内的-Navicat-软件上远程连接在Linux服务器上的-mysql-数据库！" class="headerlink" title="在 Windows 系统内的 Navicat 软件上远程连接在Linux服务器上的 mysql 数据库！"></a>在 Windows 系统内的 Navicat 软件上远程连接在Linux服务器上的 mysql 数据库！</h3>      <p>准备工作：利用服务器上的 Navicat软件将服务器数据库用户权限更改（更改为可远程连接！）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193556888.png"  alt="image-20211011193556888">      </p><p>远程登录步骤：</p><p>第一步：Windows系统打开Navicat软件</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193607264.png"  alt="image-20211011193607264">      </p><p>第二步：填写数据库信息远程登录</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193617724.png"  alt="image-20211011193617724">      </p>        <h2 id="MySQL数据类型【重点】"   >          <a href="#MySQL数据类型【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL数据类型【重点】" class="headerlink" title="MySQL数据类型【重点】"></a>MySQL数据类型【重点】</h2>      <p>你问我答：为什么要有不同的数据库数据类型的分类</p><p>答：MySQL定义数据字段的类型（数据类型）对数据库的优化是非常重要的，MySQL数据库常见三种数据类型为数值（整形、浮点型）、日期/时间、字符串</p>        <h3 id="MySQL数据库三大数据类型【数值（整形与浮点型）、日期、字符串】的分类！"   >          <a href="#MySQL数据库三大数据类型【数值（整形与浮点型）、日期、字符串】的分类！" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL数据库三大数据类型【数值（整形与浮点型）、日期、字符串】的分类！" class="headerlink" title="MySQL数据库三大数据类型【数值（整形与浮点型）、日期、字符串】的分类！"></a>MySQL数据库三大数据类型【数值（整形与浮点型）、日期、字符串】的分类！</h3>      <p>1.数值——整形数据类型分类：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193630371.png"  alt="image-20211011193630371">      </p><p>应用场景：</p><p>1：存储一个班级学生的年龄选择TINYINT整形类型（因为年龄最大不超过255），这样占用的空间最少还能存储数据</p><p>2：存储中国人数选择INT整形类型（因为之前的类型范围不够），INT范围是42亿多呢，够用，用BIGINT的话就浪费资源，没有达到优化数据库的目的</p><p>注意事项：</p><p>1：在存储数据时同一数据类型的不同分类对数据库的优化是非常重要的！</p><p>2：最常用的两大整形即 tinyint与int</p><p>数值——浮点型数据类型分类</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193655835.png"  alt="image-20211011193655835">      </p><p>注意事项：除了float与double浮点数类型，decimal 类型也可以表示小数，decimal定义的小数更加精确</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193705556.png"  alt="image-20211011193705556">      </p><p>2.字符串数据类型分类</p><p>数据库字符串类型常见分类：char、varchar、text、enum、set</p><p>定长字符类型——char</p><p>适用场景：存储字符长度固定的字符串，比如说中国邮政编码、手机号、身份证号等</p><p>定义形式：字段名称 char（字符个数）</p><p>特点：</p><p>1：最长储存255个字符</p><p>2：如果实际写入的字符不足设定长度，内部会自动用空格填充到设定的长度，例如 char（5）存储数据 he（两个字符长度），但是却占用五个字符的空间（补全空格）</p><p>3：相对于varchar，读取数据速度更快</p><p>变长字符类型——varchar</p><p>适用场景：存储的字符长度不确定，比如姓名、用户名等</p><p>定义形式：字段名称 varchar（字符个数）</p><p>特点：</p><p>1：最大可存储65535（2的16次方减1）个字节的字符</p><p>注释：<br>• 一个英文字符占用一个字节</p><p>• UTF-8编码的中文字符占用三个字节</p><p>• GBK编码的中文字符占用两个字节</p><p>2：当存储的字符长度小于设定的长度时，按照实际的长度存储，例如varchar（5）存储he，实际占用三个字符（最后是/0）的空间，这是与char的区别</p><p>3：相较于char，存取数据速度更快</p><p>注意事项：char最大存储255个字符，varchar最大存储65535个字节</p><p>长文本类型——text</p><p>适用场景：较长文章的存储，最长可存储65535（2的16次方减1）个字符，如果需要更长的字符可选择 mediumtext（1600万左右）或longtext（40亿左右）</p><p>定义方式：字段名称 text</p><p>注意事项：</p><p>1：长文本类型不能设置默认字符长度</p><p>2：text类型的数据不存在行中</p><p>3： mediumtext（1600万左右）或longtext（40亿左右）都是字符</p><p>4：65535个字符大约 64kb</p><p>5：utf-8的编码 text存储的字符数可能减半</p><p>枚举类型——enum、set</p><p>概念：在定义字段时预先规定好几个值，然后插入数据时只能从这几个规定好的值中选择一个</p><p>适用场景：字段插入数据时，有固定的几个值，比如性别、星期、月份时可用枚举类型</p><p>定义方式：gender enum（“男”，“女”），这样在插入数据时，只能选择男或者女</p><p>注意事项：</p><p>1：一个enum最多可存储65535个值</p><p>2：利用enum设置的字段最终只占用1或2个字节的空间，比较节省空间</p><p>3：枚举类型的enum与set的不同是，enum只能从枚举的数据中选取一个，而set可以从枚举的类型中选取多个！</p><p>3.日期数据类型分类</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193808869.png"  alt="image-20211011193808869">      </p><p>你问我答：datatime类型与timestamp类型都是定义到年月日时分秒，他俩有啥不同呢？</p><p>答：定义时间的范围不同 datatime定义的范围是1000-01-01 00:00:00/9999-12-31 23:59:59<br>而timestamp定义的范围是1970-01-01 00:00:00 / 2038-1-19 11:14:07</p>        <h3 id="知道选择一种合适的数据库数据类型的好处"   >          <a href="#知道选择一种合适的数据库数据类型的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#知道选择一种合适的数据库数据类型的好处" class="headerlink" title="知道选择一种合适的数据库数据类型的好处"></a>知道选择一种合适的数据库数据类型的好处</h3>      <p>好处1：节省数据库空间<br>好处2：增加数据的查询效率<br>好处3：优化数据库</p>        <h2 id="登录和退出MySQL数据库及其SQL指令查询数据库版本等【重点】"   >          <a href="#登录和退出MySQL数据库及其SQL指令查询数据库版本等【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#登录和退出MySQL数据库及其SQL指令查询数据库版本等【重点】" class="headerlink" title="登录和退出MySQL数据库及其SQL指令查询数据库版本等【重点】"></a>登录和退出MySQL数据库及其SQL指令查询数据库版本等【重点】</h2>              <h3 id="MySQL数据库的操作步骤"   >          <a href="#MySQL数据库的操作步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL数据库的操作步骤" class="headerlink" title="MySQL数据库的操作步骤"></a>MySQL数据库的操作步骤</h3>      <p>步骤：终端连接数据库→对数据库进行操作→终端退出数据库</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193837280.png"  alt="image-20211011193837280">      </p>        <h3 id="使用终端命令登录（连接）数据库"   >          <a href="#使用终端命令登录（连接）数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用终端命令登录（连接）数据库" class="headerlink" title="使用终端命令登录（连接）数据库"></a>使用终端命令登录（连接）数据库</h3>      <p>前言：终端（客户端）连接数据库的原理是，终端（客户端）连接数据库服务器，利用服务器管理数据库内的数据</p><p>指令： </p><p>mysql -u root -p </p><p>回车输入密码即可连接数据库服务器</p><p>指令解释：-u 用户选项 root 用户名  -p 密码选项</p><p>注意事项：</p><p>1：必须先切换到管理员用户在输入上面指令才能连接到数据库，否则失败</p><p>2：在连接到数据库之后，你就要输入SQL指令才能操作数据库</p><p>3：连接到数据库之后，每一行SQL指令都要以分号；结尾</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193855313.png"  alt="image-20211011193855313">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193909652.png"  alt="image-20211011193909652">      </p>        <h3 id="退出数据库"   >          <a href="#退出数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#退出数据库" class="headerlink" title="退出数据库"></a>退出数据库</h3>      <p>退出指令：exit 、quit 、Ctrl+D</p>        <h3 id="数据库的常见-SQL操作指令（查看数据库版本号等）"   >          <a href="#数据库的常见-SQL操作指令（查看数据库版本号等）" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库的常见-SQL操作指令（查看数据库版本号等）" class="headerlink" title="数据库的常见 SQL操作指令（查看数据库版本号等）"></a>数据库的常见 SQL操作指令（查看数据库版本号等）</h3>      <p>常见指令：</p><p>1：select version( ) ；查看mysql数据库的版本号</p><p>2：select now（）；查看当前时间</p><p>截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011193929670.png"  alt="image-20211011193929670">      </p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：关系型数据库的概念、及其一些核心的元素与简单的语法等等…..&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/categories/Mysql%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="Mysql操作" scheme="http://pythonlamb.github.io/tags/Mysql%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>多任务编程——协程</title>
    <link href="http://pythonlamb.github.io/2021/10/11/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%8D%8F%E7%A8%8B/"/>
    <id>http://pythonlamb.github.io/2021/10/11/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%8D%8F%E7%A8%8B/</id>
    <published>2021-10-11T09:03:46.000Z</published>
    <updated>2021-10-11T09:52:30.261Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Python中关于协程相关的知识……</p><span id="more"></span>        <h2 id="可迭代对象及其检测方法"   >          <a href="#可迭代对象及其检测方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#可迭代对象及其检测方法" class="headerlink" title="可迭代对象及其检测方法"></a>可迭代对象及其检测方法</h2>              <h3 id="为什么学习可迭代对象（迭代器）"   >          <a href="#为什么学习可迭代对象（迭代器）" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么学习可迭代对象（迭代器）" class="headerlink" title="为什么学习可迭代对象（迭代器）"></a>为什么学习可迭代对象（迭代器）</h3>      <p>答：因为学习迭代器是为了学习生成器，学习生成器是为了学习协程！</p>        <h3 id="什么是可迭代对象"   >          <a href="#什么是可迭代对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是可迭代对象" class="headerlink" title="什么是可迭代对象"></a>什么是可迭代对象</h3>      <p>答：可迭代对象就是可以被for循环遍历的对象，因此可迭代也称为可遍历</p><p>可迭代（遍历）对象举例：列表、元组、字典、字符串、range（）</p><p>不可迭代对象举例：自定义类对象（不包括内含迭代器的类对象）、函数、整数（int）</p><p>注意事项：遍历字典默认遍历的字典的key值</p><p>可迭代判断截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172657007.png"  alt="image-20211011172657007">      </p>        <h3 id="判断对象是否可迭代的方法"   >          <a href="#判断对象是否可迭代的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断对象是否可迭代的方法" class="headerlink" title="判断对象是否可迭代的方法"></a>判断对象是否可迭代的方法</h3>      <p>方法：isinstance（判断对象，Iterable）</p><p>判断实例：bool = isinstance（判断对象，Iterable）</p><p>注意事项：</p><p>1：在利用 isinstance（判断对象，Iterable）方法判断对象是否可迭代时，要先导入collections模块内的 Iterable类！！，即 from collections import Iterable语句 ，否则程序报错</p><p>2：Iterable是一个可迭代对象类，isinstance（）判断方法就是判断目标对象是否为Iterable类的一个子类</p><p>3：判断对象是可迭代对象返回 True，不是返回 False</p><p>4：默认的自定义类对象是不可迭代的，但是如果类中含有__iter__( ) 方法，那么这个类创建的对象就是可迭代的，其中__iter__( ) 方法也称为迭代器</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172714995.png"  alt="image-20211011172714995">      </p>        <h3 id="初识迭代器-（iter-魔法方法）"   >          <a href="#初识迭代器-（iter-魔法方法）" class="heading-link"><i class="fas fa-link"></i></a><a href="#初识迭代器-（iter-魔法方法）" class="headerlink" title="初识迭代器 （iter( )魔法方法）"></a>初识迭代器 （<strong>iter</strong>( )魔法方法）</h3>      <p>概念：类默认是不可迭代对象，但是在类中如果含有__iter__( ) 这个方法，那么这个类创建的对象就是可迭代对象，<strong>iter</strong>( ) 魔法方法就是迭代器</p><p>可迭代对象的本质：创建对象的所属类中含有迭代器（<strong>iter</strong>( )），可向外提供一个迭代器</p><p>注意事项：默认类是不可迭代的，如果一个类创建的对象判定为可迭代，那么这个对象所属的类中一定含有__iter__方法</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172803597.png"  alt="image-20211011172803597">      </p>        <h2 id="迭代器及其使用方法"   >          <a href="#迭代器及其使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器及其使用方法" class="headerlink" title="迭代器及其使用方法"></a>迭代器及其使用方法</h2>      <p>课前回顾：默认类创建的对象是不可迭代的，如果一个类创建的对象判定为可迭代，那么这个对象所属的类中一定含有__iter__方法（迭代器）</p>        <h3 id="什么是迭代器？"   >          <a href="#什么是迭代器？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h3>      <p>概念：用 for 循环遍历可迭代对象过程中，要有一个“人”来记录遍历访问第几个数据了，并且返回数据，以便于下一次遍历时返回的是下一个数据，这是把帮助我们记录遍历第几个数据的“人”称为迭代器（iterable）</p><p>注意事项：</p><p>1：类创建的可迭代对象通过__iter__方法向我们提供了一个迭代器，我们在遍历一个可迭代对象时，其实是先获取可迭代对象提供的的迭代器，然后再通过这个迭代器依次获取对象中的每一个数据！</p><p>2：比如说列表是一个可迭代对象，那么列表会向外提供一个迭代器，这个迭代器会获取列表内每个数据用于遍历</p><p>3：只要是可迭代对象，都可以获取这个对象的迭代器</p><p>迭代器特点：</p><p>1：记录遍历的位置<br>2：提供下一个元素的值（配合next（迭代器）函数使用）</p>        <h3 id="循环遍历可迭代对象依次获取数据的原理"   >          <a href="#循环遍历可迭代对象依次获取数据的原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环遍历可迭代对象依次获取数据的原理" class="headerlink" title="循环遍历可迭代对象依次获取数据的原理"></a>循环遍历可迭代对象依次获取数据的原理</h3>      <p>列表（可迭代对象）→iter（）函数获取迭代器→next（迭代器）函数依次获取迭代器内的数据！（执行几次next函数，获得几个可迭代对象数据）→捕获异常</p>        <h3 id="获取可迭代对象的迭代器函数——iter（）"   >          <a href="#获取可迭代对象的迭代器函数——iter（）" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取可迭代对象的迭代器函数——iter（）" class="headerlink" title="获取可迭代对象的迭代器函数——iter（）"></a>获取可迭代对象的迭代器函数——iter（）</h3>      <p>功能：获取可迭代对象的迭代器</p><p>语法：<code>iteratro_obj = iter（可迭代对象）</code><br>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172840216.png"  alt="image-20211011172840216">      </p>        <h3 id="next（）函数"   >          <a href="#next（）函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#next（）函数" class="headerlink" title="next（）函数"></a>next（）函数</h3>      <p>功能：获取迭代器中的下一个元素的数据</p><p>语法：<code>print（next（迭代器对象））</code></p><p>注意事项：</p><p>1：调用了几次next（迭代器对象）函数，就打印几次迭代器内的数据</p><p>2：如果调用next（）函数的次数大于迭代器内的数据数量，程序报错</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011172920020.png"  alt="image-20211011172920020">      </p>        <h3 id="for循环遍历可迭代对象的底层原理"   >          <a href="#for循环遍历可迭代对象的底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#for循环遍历可迭代对象的底层原理" class="headerlink" title="for循环遍历可迭代对象的底层原理"></a>for循环遍历可迭代对象的底层原理</h3>      <p>第一步：iter（可迭代对象）方法获取可迭代对象的迭代器    即调用可迭代对象类内的__iter__( )方法，<strong>iter</strong>( )方法返回的是一个迭代器类创建的迭代器</p><p>第二步：利用next（迭代器）方法依次获取数据，即多次调用迭代器类里面的__next__( )函数获取数据，直到数据全部获取成功结束迭代</p><p>第三步：捕获异常，如果next（）函数调用次数大于迭代器内的数据数，程序报错，捕获这个异常防止程序报错</p><p>快速代码体验（异常截图）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173000787.png"  alt="image-20211011173000787">      </p><p>for循环底层原理截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173007032.png"  alt="image-20211011173007032">      </p>        <h3 id="自定义迭代器类"   >          <a href="#自定义迭代器类" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义迭代器类" class="headerlink" title="自定义迭代器类"></a>自定义迭代器类</h3>      <p>自定义迭代器类注意事项：</p><p>1：类里面必须含有__iter( )__方法</p><p>2：类里面必须含有 <strong>next</strong>( )方法</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173018655.png"  alt="image-20211011173018655">      </p>        <h2 id="自定义迭代对象、迭代器【重点、难点】"   >          <a href="#自定义迭代对象、迭代器【重点、难点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义迭代对象、迭代器【重点、难点】" class="headerlink" title="自定义迭代对象、迭代器【重点、难点】"></a>自定义迭代对象、迭代器【重点、难点】</h2>              <h3 id="自定义一个可迭代对象类（列表）"   >          <a href="#自定义一个可迭代对象类（列表）" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义一个可迭代对象类（列表）" class="headerlink" title="自定义一个可迭代对象类（列表）"></a>自定义一个可迭代对象类（列表）</h3>      <p>构造必要条件：一个类默认是不可以迭代的，要想让一个类可迭代，类里面必须有 <strong>iter</strong> 方法（提供迭代器），其中提供的迭代器是另外定义的一个类，迭代器类里面必须包含__iter__ ( ）方法与__next__（）方法，而且自定义一个列表类，类里面还要有增加数据以及其他的基本方法，还有最起码的 __init__构造方法</p><p>自定义可迭代对象类(列表)条件清单：</p><p>1：两个类（自定义列表类与自定义迭代器类）</p><p>2：列表类里面的__iter__ ( ）、<strong>init</strong>()、基本数据构造等方法</p><p>3：迭代器类里面的__iter__ ( ）、<strong>next</strong>( )、<strong>init</strong>( )方法</p><p>注意事项：</p><p>1：自定义迭代器类是为自定义列表类的__iter__( )方法提供一个迭代器</p><p>条件截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173038555.png"  alt="image-20211011173038555">      </p><p>自定义列表类代码截图（三段代码组成一段程序）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173109740.png"  alt="image-20211011173109740">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173118610.png"  alt="image-20211011173118610">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173125582.png"  alt="image-20211011173125582">      </p>        <h3 id="自定义可迭代对象的方法步骤"   >          <a href="#自定义可迭代对象的方法步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义可迭代对象的方法步骤" class="headerlink" title="自定义可迭代对象的方法步骤"></a>自定义可迭代对象的方法步骤</h3>      <p>第一步：自定义可迭代对象类，内含__init__( )、 <strong>iter</strong>( )、  其他基本功能方法如添加数据等方法</p><p>第二步：自定义一个迭代器类，用来给自定义可迭代对象类提供一个迭代器，内含__init__( )、 <strong>iter</strong>( )、<strong>next</strong>( ) 方法</p><p>第三步：自定义可迭代对象类的__init( )方法要初始化一个容器保存数据，可以是列表、元组等</p><p>第四步：创建的可迭代对象类中的__iter__( )方法要返回创建的迭代类实例化的迭代器</p><p>第五步：创建的迭代器类里面的__next__( )方法要返回数据容器存放的数据！每调用一次返回一个数<br>据</p><p>第六步：创建的迭代器类里面的__next__( )方法要进行抛出异常即在遍历完成时结束迭代</p>        <h2 id="常见问题【重点、重点】"   >          <a href="#常见问题【重点、重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见问题【重点、重点】" class="headerlink" title="常见问题【重点、重点】"></a>常见问题【重点、重点】</h2>      <p>目标：知道 a = b  b = a + b 与   a ，b = b , a + b 的区别【重点】斐波那契数列必须知道这两个的区别才能书写代码</p>        <h3 id="代码区别"   >          <a href="#代码区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码区别" class="headerlink" title="代码区别"></a>代码区别</h3>      <p>a = b<br>b = a + b<br>上面代码先将 b 的值赋值给 a 在计算 b 的数值</p><p>————————————————————————————————————</p><p>a ，b = b , a + b</p><p>上面代码是先计算等号右面的数值，即 b 与 a + b 的数值，在赋值给等号左面类似于下面的代码</p><p>temp = b<br>b = a + b<br>a = temp</p><p>代码演示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173228774.png"  alt="image-20211011173228774">      </p>        <h2 id="迭代器应用——斐波那契数列【重点】"   >          <a href="#迭代器应用——斐波那契数列【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器应用——斐波那契数列【重点】" class="headerlink" title="迭代器应用——斐波那契数列【重点】"></a>迭代器应用——斐波那契数列【重点】</h2>              <h3 id="什么是斐波那契数列？"   >          <a href="#什么是斐波那契数列？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是斐波那契数列？" class="headerlink" title="什么是斐波那契数列？"></a>什么是斐波那契数列？</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173257483.png"  alt="image-20211011173257483">      </p><p>斐波那契数列实现原理：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173306874.png"  alt="image-20211011173306874">      </p>        <h3 id="创建一个迭代器类实现输出打印斐波那契数列"   >          <a href="#创建一个迭代器类实现输出打印斐波那契数列" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建一个迭代器类实现输出打印斐波那契数列" class="headerlink" title="创建一个迭代器类实现输出打印斐波那契数列"></a>创建一个迭代器类实现输出打印斐波那契数列</h3>      <p>创建迭代器类满足条件：<strong>init</strong>( )、  <strong>iter</strong>( )、  <strong>next</strong>( )、三个函数</p><p>注意事项：</p><p>1：迭代器类本身就是一个迭代器，因此迭代器类创建的实例可以被for循环遍历</p><p>2：想要迭代器类创建的对象可以被for循环遍历，那么迭代器类里面的__iter__( )方法就要返回迭代器本身，即return self</p><p>斐波那契数列代码实现：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173407453.png"  alt="image-20211011173407453">      </p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173416687.png"  alt="image-20211011173416687">      </p>        <h3 id="掌握斐波那契数列底层代码不能书写的样式"   >          <a href="#掌握斐波那契数列底层代码不能书写的样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#掌握斐波那契数列底层代码不能书写的样式" class="headerlink" title="掌握斐波那契数列底层代码不能书写的样式"></a>掌握斐波那契数列底层代码不能书写的样式</h3>      <p>答：底层重要代码不能这么写 a = b  b = a + b</p>        <h2 id="生成器——基本使用"   >          <a href="#生成器——基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成器——基本使用" class="headerlink" title="生成器——基本使用"></a>生成器——基本使用</h2>              <h3 id="什么是生成器（generator）？"   >          <a href="#什么是生成器（generator）？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是生成器（generator）？" class="headerlink" title="什么是生成器（generator）？"></a>什么是生成器（generator）？</h3>      <p>概念：生成器是一种特殊的迭代器（按照一定规律生成数列），是一种更加简洁的迭代器，生成器可以理解为可暂停的函数！</p><p>创建生成器两种方式：</p><p>1：根据列表推导式演变创建生成器 → generator_obj = （ i for i in range(10) ）</p><p>2：函数中使用了 yield 关键字</p><p>注意事项：</p><p>1：生成器是特殊迭代器，因此生成器也可以用next（生成器）来获取数据</p><p>2：生成器也可以被遍历</p><p>快速代码体验（推导式创建生成器）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173500784.png"  alt="image-20211011173500784">      </p><p>函数中使用 yield 创建生成器（函数为一个生成器）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173507678.png"  alt="image-20211011173507678">      </p>        <h2 id="生成器案例——斐波那契数列【重点】"   >          <a href="#生成器案例——斐波那契数列【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成器案例——斐波那契数列【重点】" class="headerlink" title="生成器案例——斐波那契数列【重点】"></a>生成器案例——斐波那契数列【重点】</h2>              <h3 id="利用函数内的-yield-关键字创建斐波那契数列生成器"   >          <a href="#利用函数内的-yield-关键字创建斐波那契数列生成器" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用函数内的-yield-关键字创建斐波那契数列生成器" class="headerlink" title="利用函数内的 yield 关键字创建斐波那契数列生成器"></a>利用函数内的 yield 关键字创建斐波那契数列生成器</h3>      <p>注意事项：调用一次next（生成器对象）函数，就会执行一次生成器函数到 yield 关键字处返回数据且暂停程序，直到下一次调用next（生成器对象）函数或者send（）函数才可以再次唤醒生成器程序函数继续执行！</p><p>代码截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173537699.png"  alt="image-20211011173537699">      </p>        <h3 id="生成器函数内-yield-关键字功能"   >          <a href="#生成器函数内-yield-关键字功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成器函数内-yield-关键字功能" class="headerlink" title="生成器函数内 yield 关键字功能"></a>生成器函数内 yield 关键字功能</h3>      <p>功能1：返回数据</p><p>功能2：暂停函数，不是退出函数，是暂停函数，这也是yield与return的区别！直到下一次调用next（）函数时程序继续执行<br>也可以理解为遇到yield关键字记录位置退出函数，下一次调用next（）函数从记录的位置继续执行代码！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173547455.png"  alt="image-20211011173547455">      </p>        <h2 id="生成器使用注意事项【send、return】"   >          <a href="#生成器使用注意事项【send、return】" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成器使用注意事项【send、return】" class="headerlink" title="生成器使用注意事项【send、return】"></a>生成器使用注意事项【send、return】</h2>              <h3 id="函数生成器中-return-的作用"   >          <a href="#函数生成器中-return-的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数生成器中-return-的作用" class="headerlink" title="函数生成器中 return 的作用"></a>函数生成器中 return 的作用</h3>      <p>功能：退出生成器函数，不在继续生成数据，当继续执行 next（）函数时报错，报错内容就是 return 返回的数据内容，对此我们可以对下面执行的 next（）进行异常捕获</p><p>注意事项：生成器内的 return 一般要配合 if 条件使用，在满足规定条件后才执行return语句，退出生成器函数</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173604573.png"  alt="image-20211011173604573">      </p>        <h3 id="send-方法启动生成器并且传递参数"   >          <a href="#send-方法启动生成器并且传递参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#send-方法启动生成器并且传递参数" class="headerlink" title="send 方法启动生成器并且传递参数"></a>send 方法启动生成器并且传递参数</h3>      <p>send（参数）功能：可以唤醒暂停的生成器程序（生成器内部遇见 yield 关键字就会暂停，直到继续调用next（）或send（）函数），并且向生成器内传递参数即 参数 = yieid result</p><p>使用语法：生成器对象.send（参数）</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173816824.png"  alt="image-20211011173816824">      </p>        <h2 id="协程——基本使用（yield实现协程）"   >          <a href="#协程——基本使用（yield实现协程）" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程——基本使用（yield实现协程）" class="headerlink" title="协程——基本使用（yield实现协程）"></a>协程——基本使用（yield实现协程）</h2>              <h3 id="什么是协程"   >          <a href="#什么是协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3>      <p>概念：协程可以理解为一种特殊的生成器，在不开辟其他子线程的情况下（只有主线程）可以实现多任务，并且协程有暂停函数的功能，且协程也称为微线程或者纤程</p><p>协程适用场景：在程序中存在大量不需要 cpu 的操作时，如I/O操作</p><p>线程与协程的差异：在实现多任务时，线程的切换非常耗性能，协程切换没有线程那么耗能</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173908875.png"  alt="image-20211011173908875">      </p>        <h3 id="函数使用yield关键字可以实现协程"   >          <a href="#函数使用yield关键字可以实现协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数使用yield关键字可以实现协程" class="headerlink" title="函数使用yield关键字可以实现协程"></a>函数使用yield关键字可以实现协程</h3>      <p>实现步骤：</p><p>1：创建两个生成器函数（内涵yield）</p><p>2：获取这两个生成器</p><p>3：value = next（生成器）来获取生成器返回的值</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173921881.png"  alt="image-20211011173921881">      </p>        <h2 id="greenlet-实现协程"   >          <a href="#greenlet-实现协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#greenlet-实现协程" class="headerlink" title="greenlet 实现协程"></a>greenlet 实现协程</h2>              <h3 id="什么是-greenlet-？"   >          <a href="#什么是-greenlet-？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是-greenlet-？" class="headerlink" title="什么是 greenlet ？"></a>什么是 greenlet ？</h3>      <p>答：greenlet 是 python 的一个 c 扩展，旨在提供一个可自行调度的 “微线程”（协程）方法</p><p>安装 greenlet 第三方库指令：pip3 install greenlet</p>        <h3 id="怎么用-greenlet-实现协程多任务-步骤"   >          <a href="#怎么用-greenlet-实现协程多任务-步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么用-greenlet-实现协程多任务-步骤" class="headerlink" title="怎么用 greenlet 实现协程多任务(步骤)"></a>怎么用 greenlet 实现协程多任务(步骤)</h3>      <p>第一步：导入 greenlet 模块   from greenlet import greenlet（导入greenlet模块里面的greenlet类）</p><p>第二步：创建任务函数（不含yield 必须含有任务切换方法 switch（））</p><p>第三步：创建协程 greenlet 对象，几个任务函数创建几个协程对象，并为协程对象指定函数任务（函数无括号）  即  协程对象 = greenlet（函数任务）</p><p>第四步：手动选择协程先执行哪个任务函数 即 协程对象.switch（）</p><p>注意事项：</p><p>1：创建的任务函数一定要包含 switch（） 切换任务函数</p><p>2：greenlet实现协程在只有主线程情况下进行多任务</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011173941458.png" >      </p>        <h2 id="gevent-实现协程【重中之重】"   >          <a href="#gevent-实现协程【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#gevent-实现协程【重中之重】" class="headerlink" title="gevent 实现协程【重中之重】"></a>gevent 实现协程【重中之重】</h2>              <h3 id="什么是-gevent"   >          <a href="#什么是-gevent" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是-gevent" class="headerlink" title="什么是 gevent"></a>什么是 gevent</h3>      <p>答：上一集我们用 greenlet 实现了协程多任务，但是多任务却要我们手动切换任务函数，不要捉急 python 有一个更为强大的第三方库 gevent 它可以实现自动切换任务函数</p><p>gevent 第三方库可以自动检测代码中哪些是耗时操作，遇到耗时较长的代码就会立刻切换到另一个任务去执行，然后在一个合适的时间返回执行刚开始的函数</p>        <h3 id="gevent-怎么使用及实现协程多任务"   >          <a href="#gevent-怎么使用及实现协程多任务" class="heading-link"><i class="fas fa-link"></i></a><a href="#gevent-怎么使用及实现协程多任务" class="headerlink" title="gevent 怎么使用及实现协程多任务"></a>gevent 怎么使用及实现协程多任务</h3>      <p>gevent实现多任务步骤：</p><p>1：导入模块 import gevent</p><p>2：创建任务函数，任务函数内含耗时操作（gevent.sleep（0.5））</p><p>3：为 gevent 指派任务 并且返回一个 gevent 对象 即 对象 =  gvenv.spawn（任务函数，参数1，参数2，…….），注意有几个任务就指派几次任务返回几个对象，先指派的哪个任务就先执行哪个任务函数</p><p>4：让主线程等待协程执行结束后在结束，即  gevent对象.join（）</p><p>注意事项：</p><p>1：在任务函数中耗时操作为什么不能使用 time.sleep（0.5）只能使用 gevent.sleep（0.5），因为gevent只能识别自己的gevent.sleep（0.5）是耗时操作，不能识别time.sleep（0.5）是耗时操作，但是它们两个的效果是一样的</p><p>2：第四步的join（）必须书写，否则在协程没有执行结束，主线程就结束了并且释放数据和内存，不能输出任何数据</p><p>3：耗时操作包括 I/O操作，比如文件的读取写入</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174348804.png" >      </p>        <h3 id="给一个-gevent-不能识别为耗时操作的代码（time-sleep（0-5）），转变成可以识别为耗时代码操作（打补丁）"   >          <a href="#给一个-gevent-不能识别为耗时操作的代码（time-sleep（0-5）），转变成可以识别为耗时代码操作（打补丁）" class="heading-link"><i class="fas fa-link"></i></a><a href="#给一个-gevent-不能识别为耗时操作的代码（time-sleep（0-5）），转变成可以识别为耗时代码操作（打补丁）" class="headerlink" title="给一个 gevent 不能识别为耗时操作的代码（time.sleep（0.5）），转变成可以识别为耗时代码操作（打补丁）"></a>给一个 gevent 不能识别为耗时操作的代码（time.sleep（0.5）），转变成可以识别为耗时代码操作（打补丁）</h3>      <p>什么是打补丁：打补丁就是在不修改程序源代码的情况下为程序增加新的功能</p><p>给 gevent 打补丁：在不改变 gevent 原始代码的情况下，为 gevent 增加新的功能</p><p>利用打补丁操作将 gevent 不能识别为耗时操作的代码（time.sleep（0.5））识别为耗时操作步骤：</p><p>第一步：导入模块   from gevent import monkey</p><p>第二步：破解所有即可  monkey.patch_all( )  这样就可以识别 time.sleep（0.5）代码为耗时操作了</p><p>注意事项：上面的这两行代码一般都写在一个程序的最上方！</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174538875.png"  alt="image-20211011174538875">      </p><p>猴子补丁功能：<br>1：在不修改第三方源代码的情况下增加原来不支持的功能<br>2：在运行时为内存中的对象增加补丁，而不是在磁盘的源代码中增加补丁</p>        <h2 id="线程、进程、协程区别【重点】"   >          <a href="#线程、进程、协程区别【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程、进程、协程区别【重点】" class="headerlink" title="线程、进程、协程区别【重点】"></a>线程、进程、协程区别【重点】</h2>              <h3 id="进程、线程、协程"   >          <a href="#进程、线程、协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174623986.png"  alt="image-20211011174623986">      </p>        <h3 id="进程、线程、协程关系"   >          <a href="#进程、线程、协程关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程、线程、协程关系" class="headerlink" title="进程、线程、协程关系"></a>进程、线程、协程关系</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174631826.png"  alt="image-20211011174631826">      </p>        <h3 id="线程、进程、协程应用场景"   >          <a href="#线程、进程、协程应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程、进程、协程应用场景" class="headerlink" title="线程、进程、协程应用场景"></a>线程、进程、协程应用场景</h3>      <p>多进程：密集 cpu 任务，需要充分使用多核cpu资源<br>缺点：多个进程间通信成本高、切换开销大</p><p>多线程：密集 I/O任务（网络I/O，磁盘I/O，数据库I/O） 网络I/O即联网下载上传文件<br>缺点：同一个时间切片只能运行一个线程，不能做到高并行，能做到高并发</p><p>多协程：不需要大量 cup 操作时，应用于网络 I/O 下载时<br>缺点：单线程执行，处理大量cpu操作以及磁盘I/O操作时性能较低，但是处理网络I/O性能比较高</p><p>注意事项：性能最高的组合即进程+协程，进程可调度多个cpu</p>        <h2 id="案例：并发下载器"   >          <a href="#案例：并发下载器" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例：并发下载器" class="headerlink" title="案例：并发下载器"></a>案例：并发下载器</h2>              <h3 id="urllib-request-第三方库的-urlopen（url）-方法"   >          <a href="#urllib-request-第三方库的-urlopen（url）-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#urllib-request-第三方库的-urlopen（url）-方法" class="headerlink" title="urllib.request 第三方库的 urlopen（url） 方法"></a>urllib.request 第三方库的 urlopen（url） 方法</h3>      <p>功能：打开指定 url 的网站并且返回一个类文件，这个类文件支持一般文件的操作比如说read（）、readlin（）等</p><p>注意事项：类文件对象 = urllib.reques.urlopen（url）返回一个类文件，但是要对这个类文件执行read（）方法才能读取到其中的数据从而实现保存文件的结果</p><p>具体功能详解：<span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/langdashu/p/4963053.html" >https://www.cnblogs.com/langdashu/p/4963053.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>使用步骤：</p><p>第一步：导入模块 import urllib.request</p><p>第二步：返回类文件对象，类文件对象 = urllib.reques.urlopen（url）</p><p>第三步：对这个类文件对象进行操作（读取这个文件数据） 即：类文件对象.read（）等操作</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174757294.png"  alt="image-20211011174757294">      </p>        <h3 id="给所有的-gevent-协程任务-join（）的方法-gevent-joinall（）"   >          <a href="#给所有的-gevent-协程任务-join（）的方法-gevent-joinall（）" class="heading-link"><i class="fas fa-link"></i></a><a href="#给所有的-gevent-协程任务-join（）的方法-gevent-joinall（）" class="headerlink" title="给所有的 gevent 协程任务 join（）的方法 gevent.joinall（）"></a>给所有的 gevent 协程任务 join（）的方法 gevent.joinall（）</h3>      <p>功能：给所有指定任务的协程进行 join（）</p><p>语法：gevent.joinall（[协程任务1，协程任务2，协程任务3]）</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011174805756.png"  alt="image-20211011174805756">      </p>        <h3 id="协程并发下载多种图片"   >          <a href="#协程并发下载多种图片" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程并发下载多种图片" class="headerlink" title="协程并发下载多种图片"></a>协程并发下载多种图片</h3>      <p>原理图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011175004393.png"  alt="image-20211011175004393">      </p><p>实现并发下载器的步骤：</p><p>第一步：导入猴子补丁模块并且破解所有 即 from gevent import monkey        monkey.patch（）</p><p>第二步：导入urllib.request 与 gevent 模块</p><p>第三步：定义down_load（）函数用于下载内容</p><p>1：获取图片的类文件<br>2：打开本地文件写入图片的二进制文件<br>3…</p><p>第四步：定义 main（）函数保存下载内容的 url 网站 并且调用 down_load( )函数对文件进行下载</p><p>第五步：对 down_load（ ）函数进行异常捕获</p><p>代码演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011175102556.png"  alt="image-20211011175102556">      </p>        <h2 id="案例：web协程服务器"   >          <a href="#案例：web协程服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例：web协程服务器" class="headerlink" title="案例：web协程服务器"></a>案例：web协程服务器</h2>      <p>略……</p><p>未完待续….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Python中关于协程相关的知识……&lt;/p&gt;</summary>
    
    
    
    <category term="多任务编程" scheme="http://pythonlamb.github.io/categories/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="多任务编程" scheme="http://pythonlamb.github.io/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多任务编程——多进程</title>
    <link href="http://pythonlamb.github.io/2021/10/11/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://pythonlamb.github.io/2021/10/11/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-10-11T08:38:17.000Z</published>
    <updated>2021-10-11T09:02:25.517Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：Python中有关于多进程相关的知识…..</p><span id="more"></span>        <h2 id="进程以及状态【重点】"   >          <a href="#进程以及状态【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程以及状态【重点】" class="headerlink" title="进程以及状态【重点】"></a>进程以及状态【重点】</h2>              <h3 id="一：什么是进程？"   >          <a href="#一：什么是进程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#一：什么是进程？" class="headerlink" title="一：什么是进程？"></a>一：什么是进程？</h3>      <p>概念：进程（Process）是系统资源分配的基本单位，也是线程的容器，即线程是轻量级的进程，一个进程包含多个线程</p><p>程序与进程的区别：</p><p>程序：例如xxxx.py就是程序，是静态的</p><p>进程：进程是程序运行起来后，程序代码+用到的资源，它是动态的，是操作系统分配资源的基本单位，即操作系统先将资源分配给进程，进程在分配给其他线程等</p><p>注意事项：如果没有进程线程是不能独立运行的</p><p>截图说明</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165051015.png"  alt="image-20211011165051015">      </p>        <h3 id="进程的几种状态"   >          <a href="#进程的几种状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h3>      <p>读前须知：cpu处理多任务的方式为时间片轮询！</p><p>新建状态：cpu在处理一个任务时，另一个新的任务加入进来，加入的任务为进程新建状态，或者任务没有获取到资源的状态</p><p>就绪状态：两种可能是就绪状态，第一种刚加入的任务获取到资源进入就绪状态，等待运行，第二种是任务刚从运行状态结束等待下一次运行为就绪状态</p><p>运行状态：cpu通过时间片轮询方式轮询到这个任务时为运行状态</p><p>等待状态：在cpu处理一个任务时，这个任务意外关闭（time.sleep（2））（阻塞），则这个任务进入等待状态，满足条件后进入就绪状态</p><p>死亡状态：一个任务运行结束后，没有其他的任务即机死亡状态</p><p>流程演示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165111519.png"  alt="image-20211011165111519">      </p><p>流程图解：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165117851.png"  alt="image-20211011165117851">      </p>        <h2 id="进程——基本使用【重点】"   >          <a href="#进程——基本使用【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——基本使用【重点】" class="headerlink" title="进程——基本使用【重点】"></a>进程——基本使用【重点】</h2>              <h3 id="创建子进程"   >          <a href="#创建子进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h3>      <p>语法：</p><p>1：导入模块 import multiprocessing<br>2：创建进程对象 process_obj = multiprocessing.Process（target = 函数任务名无括号）<br>3：启动进程 process_obj . start( )</p><p>创建的子进程对象的参数作用：</p><p>target：为子进程传递任务函数</p><p>args：给任务函数传参（元组形式）</p><p>kwargs：给认为函数传参（字典形式）</p><p>name：为创建的子进程命名，也可以不命名</p><p>group：为创建的子进程指定组，大多数用不到</p><p>Process类创建的子进程方法及功能：</p><p>创建的子进程对象.start（）：启动子进程</p><p>创建的子进程对象.is_alive（）：判断子进程是否还活着</p><p>创建的子进程对象.join（）：是否等待其他子进程执行完毕再执行</p><p>创建的子进程对象.terminate（）：不管任务是否完成立刻结束子进程</p><p>Process类创建的子进程属性：pid：当前进程的pid号（进程号）</p><p>注意事项：</p><p>1：进程与线程是受操作系统调配的，因此不同的操作系统执行的结果可能会不同</p><p>2：程序启动会建立一个主进程，主进程内又包含了主线程，因此一个程序启动就会建立一个主线程</p><p>3：target方法指定的函数任务没有括号！</p><p>4：创建子进程的方法和创建子线程的方法类似</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165152621.png"  alt="image-20211011165152621">      </p><p>截图感悟：从代码打印结果上来看，主线程和子进程是同时运行的！</p>        <h2 id="进程——获取名称、PID号、PPID号【重点】"   >          <a href="#进程——获取名称、PID号、PPID号【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——获取名称、PID号、PPID号【重点】" class="headerlink" title="进程——获取名称、PID号、PPID号【重点】"></a>进程——获取名称、PID号、PPID号【重点】</h2>              <h3 id="获取当前进程名称——multiprocessing-current-process"   >          <a href="#获取当前进程名称——multiprocessing-current-process" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取当前进程名称——multiprocessing-current-process" class="headerlink" title="获取当前进程名称——multiprocessing.current_process( )"></a>获取当前进程名称——multiprocessing.current_process( )</h3>      <p>功能：获取当前运行的进程名称（可以是主进程也可以是子进程）</p><p>语法：<code>print（multiprocessing.current_process( )）</code></p><p>注意事项：获取进程名称是主进程还是子进程要看代码书写的位置</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165215259.png"  alt="image-20211011165215259">      </p>        <h3 id="获取进程id的几种方法"   >          <a href="#获取进程id的几种方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取进程id的几种方法" class="headerlink" title="获取进程id的几种方法"></a>获取进程id的几种方法</h3>      <p>你问我答：什么是进程id？为什么要获取进程id？</p><p>答：进程id就是进程的编号，获取进程id是为了在终端输入特定指令（kill -9）杀死该进程</p><p>方法一：multiprocess.current_process( ).pid 即可获取当前线程的id号，pid是 process id 的缩写，是进程id的意思</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165244981.png"  alt="image-20211011165244981">      </p><p>方法二：os 模块下的 getpid（）方法获取进程的编号（id）即 os . getpid（）</p><p>注意事项：os . getpid（）写在什么位置就获取的是什么位置的进程id号</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165258464.png"  alt="image-20211011165258464">      </p>        <h3 id="获取进程-父id-的方法"   >          <a href="#获取进程-父id-的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取进程-父id-的方法" class="headerlink" title="获取进程 父id 的方法"></a>获取进程 父id 的方法</h3>      <p>你问我答：什么是进程的 父id</p><p>答：进程的 父id 就是创建这个进程的那个进程的id号就是父id</p><p>进程父id获取方法：os 模块下的 getppid（）方法 ，即 os . getppid（ ）</p><p>注意事项：os . getppid（）写在什么位置就获取的是什么位置的进程父id号</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165414564.png"  alt="image-20211011165414564">      </p>        <h2 id="进程——终端指令杀死进程【重点】"   >          <a href="#进程——终端指令杀死进程【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——终端指令杀死进程【重点】" class="headerlink" title="进程——终端指令杀死进程【重点】"></a>进程——终端指令杀死进程【重点】</h2>      <p>目标：掌握在终端输入指令 kill -9 进程编号 作用</p><p>​    </p>        <h3 id="终端输入指令-kill-9-进程编号-以及-kill-15-进程编号-的作用"   >          <a href="#终端输入指令-kill-9-进程编号-以及-kill-15-进程编号-的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#终端输入指令-kill-9-进程编号-以及-kill-15-进程编号-的作用" class="headerlink" title="终端输入指令 kill -9 进程编号 以及 kill -15 进程编号 的作用"></a>终端输入指令 kill -9 进程编号 以及 kill -15 进程编号 的作用</h3>      <p>Kill -9 进程id：在终端输入这个指令，不管这个进程id的进程是否结束，直接杀死该进程（结束掉）</p><p>注意事项：<br>1：如果用 kill -9 指令杀死的是主进程，那么其余的子进程也随之结束<br>2：如果用 kill -9 指令杀死的是子进程，那么主进程不受影响，继续执行，直到结束！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165432815.png"  alt="image-20211011165432815">      </p>        <h2 id="进程——参数、全局变量【重点】"   >          <a href="#进程——参数、全局变量【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——参数、全局变量【重点】" class="headerlink" title="进程——参数、全局变量【重点】"></a>进程——参数、全局变量【重点】</h2>              <h3 id="验证子进程之间不能共享一个全局变量"   >          <a href="#验证子进程之间不能共享一个全局变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证子进程之间不能共享一个全局变量" class="headerlink" title="验证子进程之间不能共享一个全局变量"></a>验证子进程之间不能共享一个全局变量</h3>      <p>验证思想：定义一个函数work1，对一个全局变量进行累加处理，在定义一个work2函数读取这个全局变量，再定义两个子进程，两个子进程分别执行这两个函数任务，如果执行读取全局变量的进程可以成功读取到另一个进程修改后的全局变量，那么说明多个进程间可以共享全局变量，如果执行读取全局变量的进程读取到的全局变量是没有修改的全局变量，说明多个进程之间不可以共享全局变量！！！</p><p>为什么子进程间不能共享全局变量？</p><p>答：因为子进程只是把全局变量的值都复制到自己内部然后独立修改，不会修改全局变量的值，因此多个子进程间互不影响</p><p>子进程间不能共享全局变量的例子：计算机打开微信（子进程1）与浏览器（子进程2）如果子进程间可以共享全局变量的话，那么在微信上的聊天记录不就被浏览器获取了嘛！</p><p>程序设计截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165448042.png"  alt="image-20211011165448042">      </p>        <h3 id="子进程访问（修改、读取）全局变量的底层原理"   >          <a href="#子进程访问（修改、读取）全局变量的底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#子进程访问（修改、读取）全局变量的底层原理" class="headerlink" title="子进程访问（修改、读取）全局变量的底层原理"></a>子进程访问（修改、读取）全局变量的底层原理</h3>      <p>原理图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165457888.png"  alt="image-20211011165457888">      </p><p><strong>注意事项：子进程访问（修改）全局变量时并不会真正改变全局变量的值，而是将全局变量的值复制下来供自己使用，并不会真正的改变全局变量的值！</strong></p>        <h3 id="给子进程指定的任务函数传递参数"   >          <a href="#给子进程指定的任务函数传递参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#给子进程指定的任务函数传递参数" class="headerlink" title="给子进程指定的任务函数传递参数"></a>给子进程指定的任务函数传递参数</h3>      <p>传递方法：</p><p>1：args（元组法）</p><p>2：kwargs（字典法）</p><p>3：args、kwargs（元组字典法）</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165524119.png"  alt="image-20211011165524119">      </p>        <h2 id="进程——设置守护主线程【重点】"   >          <a href="#进程——设置守护主线程【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——设置守护主线程【重点】" class="headerlink" title="进程——设置守护主线程【重点】"></a>进程——设置守护主线程【重点】</h2>              <h3 id="设置子进程守护主线程"   >          <a href="#设置子进程守护主线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置子进程守护主线程" class="headerlink" title="设置子进程守护主线程"></a>设置子进程守护主线程</h3>      <p>功能：将子进程设置为守护主进程，即主进程结束，子进程也随之结束</p><p>实现代码：子进程对象 . daemon = True</p><p>注意事项：设置子进程守护主进程要在子进程开始运行（start（））之前设置</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165541588.png"  alt="image-20211011165541588">      </p>        <h2 id="进程——强制杀死子进程【重点】"   >          <a href="#进程——强制杀死子进程【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——强制杀死子进程【重点】" class="headerlink" title="进程——强制杀死子进程【重点】"></a>进程——强制杀死子进程【重点】</h2>              <h3 id="强制杀死子进程"   >          <a href="#强制杀死子进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#强制杀死子进程" class="headerlink" title="强制杀死子进程"></a>强制杀死子进程</h3>      <p>功能：不管子进程是否结束，强制杀死子进程</p><p>语法：创建的子进程对象 . terminate（）</p><p>注意事项：强制杀死子进程与设置子进程守护主进程不一样</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165618187.png"  alt="image-20211011165618187">      </p>        <h2 id="多进程与多线程的区别【面试】【重中之重】"   >          <a href="#多进程与多线程的区别【面试】【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#多进程与多线程的区别【面试】【重中之重】" class="headerlink" title="多进程与多线程的区别【面试】【重中之重】"></a>多进程与多线程的区别【面试】【重中之重】</h2>              <h3 id="掌握进程与线程之间的区别"   >          <a href="#掌握进程与线程之间的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#掌握进程与线程之间的区别" class="headerlink" title="掌握进程与线程之间的区别"></a>掌握进程与线程之间的区别</h3>      <p>进程：可以完成多任务，一个进程就相当于计算机中一个应用程序，多进程就相当于在计算机中打开多个qq应用程序</p><p>线程：可以完成多任务，一个线程就相当于计算机中一个应用中的一个功能窗口，多线程相当于一个qq应用程序打开多个聊天窗口</p><p>实例截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165634999.png"  alt="image-20211011165634999">      </p><p>使用区别：</p><p>1：进程是系统进行资源分配的进本单元，线程是cpu调度和分派的基本单位，进程包括线程</p><p>2：线程占用内存资源比进程少（划分尺度小），这使的多线程程序有高并发行</p><p>3：多个进程运行时，每个进程都拥有独立的内存资源（多进程间不能共享全局变量），而多个线程运行时，共享一个内存（因此多线程间可共享全局变量），因此多进程相对于多线程更稳定</p><p>图解：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165700391.png"  alt="image-20211011165700391">      </p><p>进程与线程对比图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165708935.png"  alt="image-20211011165708935">      </p><p>注意事项：</p><p>1：一个程序至少有一个进程（主进程），一个进程至少有一个线程（主线程）</p><p>2：线程不能单独运行，必须依赖进程中运行（进程提供线程运行的资源），比如必须开启qq（进程）才能聊天（线程）</p>        <h3 id="实际处理问题时进程与线程的优先选择："   >          <a href="#实际处理问题时进程与线程的优先选择：" class="heading-link"><i class="fas fa-link"></i></a><a href="#实际处理问题时进程与线程的优先选择：" class="headerlink" title="实际处理问题时进程与线程的优先选择："></a>实际处理问题时进程与线程的优先选择：</h3>      <p>1：需要频繁的创建销毁，优先选择线程，因为进程占用资源多，创建销毁慢，例如WEB服务器</p><p>2：线程切换速度快，在需要大量计算，频繁切换时，使用线程，例如算法、图像处理</p><p>3：多机分布用进程、多核分布用线程</p><p>4：需要运行稳定优先用进程，想要运行速度快优先用线程</p><p>5：cpu密集型（频繁操作），优先使用进程，因为现在python的解释器cpython存在GIL（全局解释器锁）创建互斥锁，会造成线程处理问题时，多核cpu处理问题变为单核cpu，进程不会出现这种现象</p><p>6：i/o密集型可以使用线程</p><p>注意事项：</p><p>1：在以后实际处理问题时，要用进程+线程+协程的思想，不要选入非此即彼的思想中，灵活运用</p>        <h2 id="消息队列——基本操作【重点】"   >          <a href="#消息队列——基本操作【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息队列——基本操作【重点】" class="headerlink" title="消息队列——基本操作【重点】"></a>消息队列——基本操作【重点】</h2>              <h3 id="为什么要学习消息队列？什么是队列？"   >          <a href="#为什么要学习消息队列？什么是队列？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要学习消息队列？什么是队列？" class="headerlink" title="为什么要学习消息队列？什么是队列？"></a>为什么要学习消息队列？什么是队列？</h3>      <p>答：进程之间是不可以进行共享全局变量的，但是我们可以创建一个消息队列，用来传递进程间的数据，从而间接进行数据共享，消息队列相当于两个进程间的对接人，媒婆，进程靠着消息队列传递消息</p><p>什么是队列：队列是一种线性数据结构类型，队列存放数据在队尾存放，而取数据在队首取走</p><p>图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165746751.png"  alt="image-20211011165746751">      </p><p>python中怎么创建消息队列：multiprocessing模块中的Queue（num）类可创建消息队列</p><p>例如：queue1 = multiprocessing.Queue(3)  代表创建一个长度为3的队列</p>        <h3 id="Queue（队列）的-put（）以及-put-nowait-与-get（）和-get-nowait-的基本作用"   >          <a href="#Queue（队列）的-put（）以及-put-nowait-与-get（）和-get-nowait-的基本作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Queue（队列）的-put（）以及-put-nowait-与-get（）和-get-nowait-的基本作用" class="headerlink" title="Queue（队列）的 put（）以及 put_nowait( ) 与 get（）和 get_nowait( ) 的基本作用"></a>Queue（队列）的 put（）以及 put_nowait( ) 与 get（）和 get_nowait( ) 的基本作用</h3>      <p>功能：</p><p>put（“3”）: 向队列中存放“3”数据（从队尾存入）,如果队列数据已满，那么会等待队列释放后再存入，程序处于阻塞状态</p><p>put_nowait( “3”): 向队列中存放“3”数据，如果队列已满，程序不会进入阻塞状态，直接报错</p><p>get（）：在队列中取出数据（从队首取出），执行一次在队列中取走一个数据！如果队列已空，程序进入阻塞状态，等待数据存入队列中在取出</p><p>get_nowait( ) :在队列中取出数据（从队首取出），执行一次在队列中取走一个数据！如果队列已空，程序不会进入阻塞状态，直接报错</p><p>快速代码体验（put方法）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165804154.png"  alt="image-20211011165804154">      </p><p>put_nowait（）方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165810714.png"  alt="image-20211011165810714">      </p><p>get（）方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165817853.png"  alt="image-20211011165817853">      </p><p>get_nowait( )方法</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165823789.png"  alt="image-20211011165823789">      </p>        <h2 id="消息队列—常见判断【重点】"   >          <a href="#消息队列—常见判断【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息队列—常见判断【重点】" class="headerlink" title="消息队列—常见判断【重点】"></a>消息队列—常见判断【重点】</h2>              <h3 id="队列中-full（）方法与-empty（）方法的作用"   >          <a href="#队列中-full（）方法与-empty（）方法的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列中-full（）方法与-empty（）方法的作用" class="headerlink" title="队列中 full（）方法与 empty（）方法的作用"></a>队列中 full（）方法与 empty（）方法的作用</h3>      <p>消息队列的full（）方法：判断消息队列是否为满，如果消息队列已满返回True，反之False</p><p>实例：bool = queue.full（） 判断queue这个消息队列是否已满，并且返回值</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165837547.png"  alt="image-20211011165837547">      </p><p>消息队列的empty（）方法：判断消息队列是否为空，为空返回True，反之False</p><p>实例：bool = queue.empty（）  判断queue这个队列是否为空，并且返回值</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165851708.png"  alt="image-20211011165851708">      </p>        <h3 id="消息队列中qsize（）方法的作用"   >          <a href="#消息队列中qsize（）方法的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息队列中qsize（）方法的作用" class="headerlink" title="消息队列中qsize（）方法的作用"></a>消息队列中qsize（）方法的作用</h3>      <p>功能：返回消息队列中尚存的数据个数，注意是尚存，不是消息队列的长度！</p><p>语法：num = 消息队列对象 . qsize（）</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165909972.png"  alt="image-20211011165909972">      </p>        <h2 id="消息队列——判断是否为空的坑【重点】"   >          <a href="#消息队列——判断是否为空的坑【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息队列——判断是否为空的坑【重点】" class="headerlink" title="消息队列——判断是否为空的坑【重点】"></a>消息队列——判断是否为空的坑【重点】</h2>              <h3 id="判断消息队列是否为空的坑！！"   >          <a href="#判断消息队列是否为空的坑！！" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断消息队列是否为空的坑！！" class="headerlink" title="判断消息队列是否为空的坑！！"></a>判断消息队列是否为空的坑！！</h3>      <p>你问我答：是什么坑？</p><p>答：当消息队列被数据项填满，用empty（）判断消息队列是否为空时，返回值为True，说明消息队列已空，这就是坑</p><p>二：出现这种坑的原因</p><p>答：可以理解为向队列中存数据为子进程1控制，判断队列是否为空是子进程2控制，但是子进程2的运行速度快过于子进程1，造成了数据还没有存入队列，就进行了判断，因此出现了队列中明明有数据却判断为空的原因</p><p>原理截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165946447.png"  alt="image-20211011165946447">      </p><p>代码图示（坑）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165953349.png"  alt="image-20211011165953349">      </p><p>解决这个坑的方法代码截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011165959275.png"  alt="image-20211011165959275">      </p>        <h2 id="Queue实现进程间的通信【重点】"   >          <a href="#Queue实现进程间的通信【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#Queue实现进程间的通信【重点】" class="headerlink" title="Queue实现进程间的通信【重点】"></a>Queue实现进程间的通信【重点】</h2>              <h3 id="消息队列可以实现进程间的通信与通信原理"   >          <a href="#消息队列可以实现进程间的通信与通信原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息队列可以实现进程间的通信与通信原理" class="headerlink" title="消息队列可以实现进程间的通信与通信原理"></a>消息队列可以实现进程间的通信与通信原理</h3>      <p>通信原理：Queue（消息队列）相当于一个中介，它可以存储进程1的数据，从而让进程2取出，这样就实现了进程间数据的传递</p><p>原理模型截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170016420.png"  alt="image-20211011170016420">      </p><p>代码截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170023558.png"  alt="image-20211011170023558">      </p>        <h2 id="进程——进程池【重点】"   >          <a href="#进程——进程池【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——进程池【重点】" class="headerlink" title="进程——进程池【重点】"></a>进程——进程池【重点】</h2>              <h3 id="什么是进程池？"   >          <a href="#什么是进程池？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是进程池？" class="headerlink" title="什么是进程池？"></a>什么是进程池？</h3>      <p>进程池概念：当创建大量进程的时候，multiprocess的Process（）方法就太过麻烦，我们需要采用multiprocess内的Pool（）来创建进程池，用来保存大量进程，即进程池是进程的容器，我们可以用它创建指定数量的进程</p><p>进程序功能：管理与维护进程池</p><p>创建进程池语法：pool_obj = multiprocess.Pool( 3 ) 表示最大创建一个内含三个进程的进程池</p><p>注意事项：multiprocess.Pool( 3 )表示最大可以创建三个进程，在只有一个任务的时候，只需创建一个进程完成任务即可</p><p>不需要把三个进程都创建出来完成任务</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170039772.png"  alt="image-20211011170039772">      </p><p>进程池工作方式（同步与异步）：</p><p>同步工作方式</p><p>概念：进程池内的进程执行函数任务时，同一时间只允许一个进程工作<br>函数方法：进程池对象 . apply（函数任务，（函数参数1，参数2…….））：以同步的方式执行任务<br>注意事项：同步的方法给任务函数传递参数只有以元组的方式进行传递</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170055846.png"  alt="image-20211011170055846">      </p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170103268.png"  alt="image-20211011170103268">      </p><p>异步工作方式：</p><p>概念：进程池内的进程同一时间可以一起工作</p><p>函数方法：进程池对象 . apply_async(函数参数1，参数2….) </p><p>注意事项：</p><p>1：异步的方法给任务函数传递参数只有以元组的方式进行传递</p><p>2：在使用进程池异步工作方式时，一定要将添加完任务的线程池执行close（）操作，表示不再接受新的任务，否则的话会造成进程池不运行！</p><p>3：采用进程池异步工作方式，主进程将不再等待进程池执行结束后退出！！为了避免数据在主进程退出时销毁，要对进程池采用 join（）方法！</p><p>图示：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170127948.png"  alt="image-20211011170127948">      </p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170134678.png"  alt="image-20211011170134678">      </p>        <h2 id="进程——进程池间的通信"   >          <a href="#进程——进程池间的通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程——进程池间的通信" class="headerlink" title="进程——进程池间的通信"></a>进程——进程池间的通信</h2>              <h3 id="进程池内进程间的通信"   >          <a href="#进程池内进程间的通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程池内进程间的通信" class="headerlink" title="进程池内进程间的通信"></a>进程池内进程间的通信</h3>      <p>通信原理：利用进程池内创建的Queue（队列）来实现进程池内进程间的通信</p><p>进程池内创建队列方法：pool_queue = multiprocessing.Manager（）.Queue（3）   【创建一个长度为3的线程池队列】</p><p>注意事项：</p><p>1：在进程池中创建队列，一定要用multiprocessing模块内的Manager（）类里面的Queue（）类来创建！</p><p>2：在采用异步方法实现进程池中进程的通信时，不要在最后忘记close（）方法和join（）方法</p><p>通信图示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170154915.png"  alt="image-20211011170154915">      </p><p>快速代码体验（同步）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170201954.png"  alt="image-20211011170201954">      </p><p>异步【重点】：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011170208591.png"  alt="image-20211011170208591">      </p>        <h2 id="案例：多进程文件夹copy器"   >          <a href="#案例：多进程文件夹copy器" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例：多进程文件夹copy器" class="headerlink" title="案例：多进程文件夹copy器"></a>案例：多进程文件夹copy器</h2>      <p>怎么创建文件夹？</p><p>os.mkdir（“文件夹名称”）</p><p>怎么获取文件夹内所有文件名并且保存至一个列表内？（包括文件名和文件夹名）</p><p>os.listdir（“目标文件夹名称”）</p>        <h2 id="案例：多进程简单web服务器"   >          <a href="#案例：多进程简单web服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例：多进程简单web服务器" class="headerlink" title="案例：多进程简单web服务器"></a>案例：多进程简单web服务器</h2>      <p>略…..</p><p>未完待续…..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：Python中有关于多进程相关的知识…..&lt;/p&gt;</summary>
    
    
    
    <category term="多任务编程" scheme="http://pythonlamb.github.io/categories/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="多任务编程" scheme="http://pythonlamb.github.io/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多任务编程——多线程</title>
    <link href="http://pythonlamb.github.io/2021/10/11/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://pythonlamb.github.io/2021/10/11/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-10-11T08:14:59.000Z</published>
    <updated>2021-10-11T08:37:38.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：在Python内多任务编程中的多线程实现方法…..</p><span id="more"></span>        <h2 id="多任务介绍"   >          <a href="#多任务介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h2>              <h3 id="什么是多任务？"   >          <a href="#什么是多任务？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是多任务？" class="headerlink" title="什么是多任务？"></a>什么是多任务？</h3>      <p>多任务就是操作系统同一时间执行多个任务，现在多核CPU已经很普及了，但是即便单核CPU也可以实现多任务（单核CPU采用时间片轮询方法实现多任务，因为CPU没秒计算速度特别快！，2.6GHZ的CPU每秒可运行26亿次）</p><p>多任务效率极高，在文件下载、爬虫等应用都很广泛！！</p><p>多任务优势</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162739207.png"  alt="image-20211011162739207">      </p>        <h3 id="单任务与多任务的区别"   >          <a href="#单任务与多任务的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#单任务与多任务的区别" class="headerlink" title="单任务与多任务的区别"></a>单任务与多任务的区别</h3>      <p>1：多任务是操作系统同一时间执行多个任务，单任务是同一时间执行单个任务</p><p>2：多任务相较于单任务效率快，广泛应用在文件下载、python爬虫等</p>        <h3 id="python程序默认是单任务执行"   >          <a href="#python程序默认是单任务执行" class="heading-link"><i class="fas fa-link"></i></a><a href="#python程序默认是单任务执行" class="headerlink" title="python程序默认是单任务执行"></a>python程序默认是单任务执行</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162754107.png"  alt="image-20211011162754107">      </p>        <h2 id="线程——基本使用【重中之重】"   >          <a href="#线程——基本使用【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——基本使用【重中之重】" class="headerlink" title="线程——基本使用【重中之重】"></a>线程——基本使用【重中之重】</h2>              <h3 id="什么是线程？主线程与子线程的关系？"   >          <a href="#什么是线程？主线程与子线程的关系？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是线程？主线程与子线程的关系？" class="headerlink" title="什么是线程？主线程与子线程的关系？"></a>什么是线程？主线程与子线程的关系？</h3>      <p>什么是线程？线程可以理解为程序执行的一条分支，也是程序执行流的最小单元，线程是被系统独立调动的和分派的基本单元，线程不拥有自己的系统资源，只拥有一点在运行中必不可少的资源，但是它可以与同属于同一个进程的其他线程共享所拥有的资源</p><p>主线程：当一个程序启动时，就会建立一个主进程，这个主进程内又包含了一个主线程，简而言之，系统启动就会建立一个主进程，主进程包含主线程，因此程序启动就会建立一个主线程！！</p><p>子线程：子线程是由主线程（程序启动自动生成主线程）创建的，建立之后子线程与主线程一起同时向下执行</p><p>理解主线程与子线程的关系：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162829936.png"  alt="image-20211011162829936">      </p><p>主线程重要的方面：</p><p>1：主线程创建子线程</p><p>2：主线程通常最后执行结束（子线程全部结束执行主线程才结束），打扫战场，如各种关闭操作</p><p>​<br>​            </p>        <h3 id="threading模块的Thread类创建线程（子线程）步骤"   >          <a href="#threading模块的Thread类创建线程（子线程）步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#threading模块的Thread类创建线程（子线程）步骤" class="headerlink" title="threading模块的Thread类创建线程（子线程）步骤"></a>threading模块的Thread类创建线程（子线程）步骤</h3>      <p>1：导入threading模块</p><p>2：利用threading模块的Thread类创建子线程对象</p><p>3：利用类的target参数为子线程指定分支任务（例如 target = 函数名，注意函数没有括号）</p><p>4：启动创建的子线程，创建子线程对象 . start（）</p><p>创建步骤代码演示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162851447.png"  alt="image-20211011162851447">      </p><p>注意事项：</p><p>1：在利用 Thread 类创建的子线程对象用targrt参数指定任务是函数，且没有括号！！！</p><p>2：创建的子线程对象只有调用start（）方法，子线程才会执行！</p><p>3：主线程只有在所有子线程全部执行结束后才结束执行！</p><p>4：创建多个子线程对象，利用start（）方法启动，因为计算机运算速度超快，故可看做多个子线程是同时启动运行的！</p><p>线程实例应用（唱歌跳舞）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162908067.png"  alt="image-20211011162908067">      </p>        <h2 id="线程——查看线程名称、总数量（活跃）【重点】"   >          <a href="#线程——查看线程名称、总数量（活跃）【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——查看线程名称、总数量（活跃）【重点】" class="headerlink" title="线程——查看线程名称、总数量（活跃）【重点】"></a>线程——查看线程名称、总数量（活跃）【重点】</h2>      <p>目标：掌握如何查看正在活跃（执行）的线程数量（名称）</p>        <h3 id="threading-enumerate（）函数"   >          <a href="#threading-enumerate（）函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#threading-enumerate（）函数" class="headerlink" title="threading.enumerate（）函数"></a>threading.enumerate（）函数</h3>      <p>功能：查看程序中正在活跃的线程数量及其名称，并存放至列表内</p><p>语法：<code>thread_list = threading.enumerate( )</code></p><p>注意事项：threading.enumerate（）函数只能查看正在活跃（运行）的线程（主线程与子线程）</p><p>快速代码体验（查看数量）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162928409.png"  alt="image-20211011162928409">      </p><p>查看线程名称</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011162949302.png"  alt="image-20211011162949302">      </p>        <h2 id="线程——线程函数传参、线程执行顺序【重点】"   >          <a href="#线程——线程函数传参、线程执行顺序【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——线程函数传参、线程执行顺序【重点】" class="headerlink" title="线程——线程函数传参、线程执行顺序【重点】"></a>线程——线程函数传参、线程执行顺序【重点】</h2>              <h3 id="向线程函数传参数方法1——args元组传参"   >          <a href="#向线程函数传参数方法1——args元组传参" class="heading-link"><i class="fas fa-link"></i></a><a href="#向线程函数传参数方法1——args元组传参" class="headerlink" title="向线程函数传参数方法1——args元组传参"></a>向线程函数传参数方法1——args元组传参</h3>      <p>功能：向子线程target指定的函数任务传递参数，因为有的函数是要有参数的</p><p>语法：thread_obj = threading.Thread（target = 函数名 ， agrs = （函数参数1，函数参数2，函数参数3））</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163010242.png"  alt="image-20211011163010242">      </p>        <h3 id="线程函数传递参数方法2——kwargs字典传参"   >          <a href="#线程函数传递参数方法2——kwargs字典传参" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程函数传递参数方法2——kwargs字典传参" class="headerlink" title="线程函数传递参数方法2——kwargs字典传参"></a>线程函数传递参数方法2——kwargs字典传参</h3>      <p>功能：向子线程target指定的函数任务传递参数，因为有的函数是要有参数的</p><p>语法：<code>thread_obj = threading.Thread（target = 函数名 ， kwagrs = &#123;“函数参数1”：参数1的值，…….&#125;</code></p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163100543.png"  alt="image-20211011163100543">      </p>        <h3 id="线程函数传递参数方法2——args元组传参以及kwargs字典混合搭配"   >          <a href="#线程函数传递参数方法2——args元组传参以及kwargs字典混合搭配" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程函数传递参数方法2——args元组传参以及kwargs字典混合搭配" class="headerlink" title="线程函数传递参数方法2——args元组传参以及kwargs字典混合搭配"></a>线程函数传递参数方法2——args元组传参以及kwargs字典混合搭配</h3>      <p>功能：向子线程target指定的函数任务传递参数，因为有的函数是要有参数的</p><p>语法：<code>thread_obj = threading.Thread（target = 函数名 ，args=（参数1，）  kwargs = &#123;“函数参数2”：参数2的值，…….&#125;</code></p><p>注意事项：混合传参，也是总共传递那几个参数</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163136019.png"  alt="image-20211011163136019">      </p>        <h3 id="子线程的执行顺序"   >          <a href="#子线程的执行顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#子线程的执行顺序" class="headerlink" title="子线程的执行顺序"></a>子线程的执行顺序</h3>      <p>答：子线程是由系统独立调动的和分派的基本单元，所以子线程的执行顺序是无序的，是cpu决定的，不是程序员决定的</p><p>总结：</p><p>1：每一个线程（子线程、主线程）都有自己的名字，它们由python自动指定</p><p>2：线程的run（）方法结束时该线程结束执行</p><p>3：我们无法控制线程的执行顺序，但是我们可以通过其他方式影响调度方式</p>        <h2 id="线程——守护线程【重点】"   >          <a href="#线程——守护线程【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——守护线程【重点】" class="headerlink" title="线程——守护线程【重点】"></a>线程——守护线程【重点】</h2>              <h3 id="什么是守护线程？"   >          <a href="#什么是守护线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h3>      <p>答：即子线程与主线程的一种约定！将子线程设置为守护主线程后，主线程结束运行后，守护线程（子线程）也会自动结束，反之，主线程没有结束运行，守护线程也不会结束运行。可以将主线程比作皇上，设置为守护线程的子线程比作妃子，皇上驾崩（主线程结束），则妃子们全部殉葬（全部守护线程全部结束执行）</p><p>答：如果不将子线程设置为守护线程，在主线程意外结束执行后，子线程还会继续执行，这样是缺乏逻辑的，因此要设置守护线程！</p>        <h3 id="子线程设置为守护线程——-创建的子线程对象-setDaemon（True）"   >          <a href="#子线程设置为守护线程——-创建的子线程对象-setDaemon（True）" class="heading-link"><i class="fas fa-link"></i></a><a href="#子线程设置为守护线程——-创建的子线程对象-setDaemon（True）" class="headerlink" title="子线程设置为守护线程—— 创建的子线程对象.setDaemon（True）"></a>子线程设置为守护线程—— 创建的子线程对象.setDaemon（True）</h3>      <p>功能：将子线程设置为守护线程，在主线程结束运行后（意外结束等），守护线程（子线程）也全部结束运行！</p><p>语法：创建的子线程对象 . setDaemon（True）</p><p>注意事项：</p><p>1：将子线程设置为守护线程要在 thread.start（）之前设置！</p><p>2：如果不将子线程设置为守护线程，主线程意外结束后，子线程会继续执行，这样是不允许的！</p><p>3：什么情况下主程序执行完毕？就是在if <strong>name</strong> == ‘<strong>main</strong>‘:这行代码下面除了守护线程的代码外，其余代码均执行完毕即主程序执行结束！！</p><p>快速代码体验（没将子线程设置为守护线程的结果</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163209160.png"  alt="image-20211011163209160">      </p><p>将子线程设置为守护线程后的结果截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163220727.png"  alt="image-20211011163220727">      </p>        <h3 id="pycharm软件按住结束程序按钮显示骷髅头是为什么？"   >          <a href="#pycharm软件按住结束程序按钮显示骷髅头是为什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#pycharm软件按住结束程序按钮显示骷髅头是为什么？" class="headerlink" title="pycharm软件按住结束程序按钮显示骷髅头是为什么？"></a>pycharm软件按住结束程序按钮显示骷髅头是为什么？</h3>      <p>答：因为按下程序结束按钮，主程序结束，但因为多线程，故子线程没有结束执行，子线程还在继续执行，这是没有将子线程设置为守护线程的缘故！！！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163236159.png"  alt="image-20211011163236159">      </p>        <h2 id="线程——并发和并行【了解】"   >          <a href="#线程——并发和并行【了解】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——并发和并行【了解】" class="headerlink" title="线程——并发和并行【了解】"></a>线程——并发和并行【了解】</h2>              <h3 id="多任务的底层原理"   >          <a href="#多任务的底层原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#多任务的底层原理" class="headerlink" title="多任务的底层原理"></a>多任务的底层原理</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163317896.png"  alt="image-20211011163317896">      </p>        <h3 id="并发与并行概念及区别"   >          <a href="#并发与并行概念及区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发与并行概念及区别" class="headerlink" title="并发与并行概念及区别"></a>并发与并行概念及区别</h3>      <p>并发：当操作系统需要执行的任务数大于计算机CPU数量时，计算机通过系统的各种跳读算法（时间片轮询），实现多个任务一起“执行”（其实不是一起执行的，只不过是计算机运行速度飞快，看上去所有的任务一起执行）</p><p>并行：操作系统需要执行的任务数小于或等于cpu内核数，一个cpu会最多执行一个任务，即任务真的是一起执行！</p><p>注意事项：计算机一般多任务方式都为并发</p>        <h2 id="线程——自定义线程类【重中之重】"   >          <a href="#线程——自定义线程类【重中之重】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——自定义线程类【重中之重】" class="headerlink" title="线程——自定义线程类【重中之重】"></a>线程——自定义线程类【重中之重】</h2>      <p>目标：通过继承 threading . Thread 类来自定义线程类（应用于多线程下载、爬虫等）</p><p>你问我答：已经有现成的子线程类 threading.Thread 可创建子线程，为啥还要自定义线程类创建子线程呢？</p><p>答：为了让每个线程的封装更加完美，所以使用 threading 模块时，需要自定义线程类，这样才会更加完美！！！</p>        <h3 id="通过继承-threading-Thread-类来自定义线程类的步骤"   >          <a href="#通过继承-threading-Thread-类来自定义线程类的步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过继承-threading-Thread-类来自定义线程类的步骤" class="headerlink" title="通过继承 threading . Thread 类来自定义线程类的步骤"></a>通过继承 threading . Thread 类来自定义线程类的步骤</h3>      <p>1：class新建一个类，并且继承 threading.Thread 父类</p><p>2：重写父类 threading.Thread 的 run（）方法</p><p>3：通过实例化对象（子线程）的 start（）方法（继承父类的start（）方法）启动这个自定义线程类</p><p>注意事项：</p><p>1：父类的start（）方法只能调用一次</p><p>2：子类在重写父类的__init__方法时，一定要先调用父类的__init__方法，即super（）.__init__继承父类的属性</p><p>3：不管是什么问题，只要是子类继承了父类，那么在给子类实例化属性时，一定要继承父类的实例化属性，即super（）.<strong>init</strong>( )</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163356240.png"  alt="image-20211011163356240">      </p><p>注意事项代码演示：子类在重写父类的__init__方法时，一定要先调用父类的__init__方法，即super（）.<strong>init</strong></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163413276.png"  alt="image-20211011163413276">      </p>        <h2 id="线程——多线程之间共享全局变量【重点】"   >          <a href="#线程——多线程之间共享全局变量【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——多线程之间共享全局变量【重点】" class="headerlink" title="线程——多线程之间共享全局变量【重点】"></a>线程——多线程之间共享全局变量【重点】</h2>              <h3 id="函数中修改全局变量的注意事项"   >          <a href="#函数中修改全局变量的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数中修改全局变量的注意事项" class="headerlink" title="函数中修改全局变量的注意事项"></a>函数中修改全局变量的注意事项</h3>      <p>答：在函数内修改全局变量之前，要先声明这个变量为全局变量，方法为 global 全局变量名</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163426671.png"  alt="image-20211011163426671">      </p>        <h3 id="多个线程之间（子线程、主线程）是可以共享全局变量的！"   >          <a href="#多个线程之间（子线程、主线程）是可以共享全局变量的！" class="heading-link"><i class="fas fa-link"></i></a><a href="#多个线程之间（子线程、主线程）是可以共享全局变量的！" class="headerlink" title="多个线程之间（子线程、主线程）是可以共享全局变量的！"></a>多个线程之间（子线程、主线程）是可以共享全局变量的！</h3>      <p>证明逻辑步骤：</p><p>1：定义全局变量<br>2：定义函数1（子线程1）修改全局变量的值<br>3：定义函数2（子线程2）读取全局变量的值，看读取的全局变量值，是否是被函数1修改后的全局变量值！是的话就证明全局变量是可以在多线程之间共享的！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163441280.png"  alt="image-20211011163441280">      </p>        <h2 id="线程——多线程共享一个全局变量产生的问题【重点】"   >          <a href="#线程——多线程共享一个全局变量产生的问题【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——多线程共享一个全局变量产生的问题【重点】" class="headerlink" title="线程——多线程共享一个全局变量产生的问题【重点】"></a>线程——多线程共享一个全局变量产生的问题【重点】</h2>              <h3 id="多线程间共享同一个全局变量（同时处理这个全局变量）会产生资源竞争等问题"   >          <a href="#多线程间共享同一个全局变量（同时处理这个全局变量）会产生资源竞争等问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程间共享同一个全局变量（同时处理这个全局变量）会产生资源竞争等问题" class="headerlink" title="多线程间共享同一个全局变量（同时处理这个全局变量）会产生资源竞争等问题"></a>多线程间共享同一个全局变量（同时处理这个全局变量）会产生资源竞争等问题</h3>      <p>你问我答：多线程什么情况会产生资源竞争的问题呢？</p><p>答：两个（多个）子线程同时处理一个公共资源时（比如说同一个全局变量），就会产生资源竞争的问题</p><p>图片详解</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163501152.png"  alt="image-20211011163501152">      </p><p>问题代码解释</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163508863.png"  alt="image-20211011163508863">      </p>        <h3 id="解决多线程间资源竞争的方法——-join（）"   >          <a href="#解决多线程间资源竞争的方法——-join（）" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决多线程间资源竞争的方法——-join（）" class="headerlink" title="解决多线程间资源竞争的方法—— join（）"></a>解决多线程间资源竞争的方法—— join（）</h3>      <p>功能：可以有效解决多线程间资源竞争问题，即让一个指定线程先执行完在执行其他线程，即从多线程变为单线程但是会造成程序效率变低</p><p>语法：指定线程 . join（)</p><p>注意事项：</p><p>1：子线程的join方法要在子线程的start方法后加入！</p><p>2：给某个子线程加入join方法后，这个子线程执行任务时另一个子线程则不启动了，等待这个子线程执行结束，另一个子线程才启动继续执行任务</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163533848.png"  alt="image-20211011163533848">      </p>        <h2 id="线程——同步与异步【重点】"   >          <a href="#线程——同步与异步【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——同步与异步【重点】" class="headerlink" title="线程——同步与异步【重点】"></a>线程——同步与异步【重点】</h2>              <h3 id="同步与异步"   >          <a href="#同步与异步" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3>      <p>同步：多任务执行时要求有先后顺序，必须一个先执行完毕，另一个线程才能继续执行，只有一个主线！（一个子线程执行，另一个子线程等待这个子线程执行结束，等待期间什么也不做）</p><p>异步：多任务执行时没有先后顺序，可以同时执行，存在多条运行主线！</p>        <h3 id="解决多线程同时修改同一个全局变量产生的资源竞争问题（线程锁）"   >          <a href="#解决多线程同时修改同一个全局变量产生的资源竞争问题（线程锁）" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决多线程同时修改同一个全局变量产生的资源竞争问题（线程锁）" class="headerlink" title="解决多线程同时修改同一个全局变量产生的资源竞争问题（线程锁）"></a>解决多线程同时修改同一个全局变量产生的资源竞争问题（线程锁）</h3>      <p>答：可以通过线程同步（同一时间只能有一个线程对全局变量进行修改）的方式（线程锁）来修改多线程间资源竞争问题！思路如下</p><p>线程锁机制（同步）：两个子线程同时对一个全局变量进行修改，会产生资源竞争问题，采用线程锁机制可以解决此问题，线程锁是在一个子线程修改全局变量时，子线程会对这个全局变量上一把锁，这样其他子线程无法对这个全局变量进行修改，修改完全局变量后，在把锁打开，让其他线程进行修改（线程锁同理）！这就是线程锁机制</p><p>图解：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163554812.png"  alt="image-20211011163554812">      </p>        <h2 id="线程——互斥锁【重点】"   >          <a href="#线程——互斥锁【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——互斥锁【重点】" class="headerlink" title="线程——互斥锁【重点】"></a>线程——互斥锁【重点】</h2>              <h3 id="什么是互斥锁？"   >          <a href="#什么是互斥锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是互斥锁？" class="headerlink" title="什么是互斥锁？"></a>什么是互斥锁？</h3>      <p>答：互斥锁是将线程同步思想落实的一种机制（锁机制），多个线程几乎同时执行同一任务时（注意一定是同一任务！！！），需要进行同步控制！</p><p>互斥锁是最简单的线程同步机制！</p><p>互斥锁两种状态：锁定/非锁定</p><p>互斥锁实现原理：当一个线程执行某个任务时，该线程对这个任务进行锁定，锁定期间不允许其他线程访问执行这个任务，直到该线程执行完当前任务，将锁打开，变为非锁定状态，其他线程才可以对这个任务进行访问执行，这样就避免了资源竞争问题，互斥锁实现了每次只有一个线程执行任务，保证了多线程情况下数据的正确性</p>        <h3 id="创建互斥锁方法——-threading模块的-Lock（）类创建互斥锁"   >          <a href="#创建互斥锁方法——-threading模块的-Lock（）类创建互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建互斥锁方法——-threading模块的-Lock（）类创建互斥锁" class="headerlink" title="创建互斥锁方法—— threading模块的 Lock（）类创建互斥锁"></a>创建互斥锁方法—— threading模块的 Lock（）类创建互斥锁</h3>      <p>功能：对资源进行锁定以及非锁定，解决多任务（多线程）间资源竞争问题</p><p>创建互斥锁步骤：</p><p>1：创建互斥锁 mutex = threading . Lock( )<br>2：对资源上锁 mutex . acquire（ ）<br>3：对资源进行解锁 mutex . release（ ）</p><p>注意事项：</p><p>1：threading模块下的Lock是一个类</p><p>2：子线程访问某个资源竞争任务（全局变量）时，为了避免资源竞争问题，要先对这个资源进行上锁，访问结束进行解锁</p><p>3：给多任务加互斥锁时，多个线程全部启动，只是一个线程在处理资源时，另一个线程等待这个资源处理完毕后再次处理，这是和join方法的最大区别（join只启动一个线程）</p><p>4：利用互斥锁锁资源时，要尽可能少锁竞争资源（代码）</p><p>5：互斥锁应用于多个线程几乎同时执行一个任务时才用互斥锁！！这是使用互斥锁条件！！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163627613.png"  alt="image-20211011163627613">      </p>        <h2 id="线程——死锁【重点】"   >          <a href="#线程——死锁【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程——死锁【重点】" class="headerlink" title="线程——死锁【重点】"></a>线程——死锁【重点】</h2>              <h3 id="什么是死锁？"   >          <a href="#什么是死锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3>      <p>答：死锁发生在多线程间，比如两个子线程同时处理一个共同任务，每个子线程都会占用这个任务的一部分资源，且两个子线程间都在等待对方释放其占有的那部分资源，这样就会造成线程死锁（一个子线程将资源锁住，未释放，另一个子线程还在等待这个子线程释放其资源，造成程序无响应、这就叫死锁）</p><p>尽管在多线程间死锁很少发生，但是一旦发生就会造成程序无法响应</p><p>死锁案例代码截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163705429.png"  alt="image-20211011163705429">      </p><p>死锁原理截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163713245.png"  alt="image-20211011163713245">      </p>        <h3 id="多线程怎么避免死锁情况"   >          <a href="#多线程怎么避免死锁情况" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程怎么避免死锁情况" class="headerlink" title="多线程怎么避免死锁情况"></a>多线程怎么避免死锁情况</h3>      <p>答：在函数任务退出之前，就要将锁住的数据进行释放，这样就避免了死锁发生！</p><p>上面案例解决办法：将数据释放语句mutex.release()，放在return语句前面执行即可完成退出程序前对锁住的数据进行释放</p><p>代码演示</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011163732152.png"  alt="image-20211011163732152">      </p><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：在Python内多任务编程中的多线程实现方法…..&lt;/p&gt;</summary>
    
    
    
    <category term="多任务编程" scheme="http://pythonlamb.github.io/categories/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="多任务编程" scheme="http://pythonlamb.github.io/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>通信协议——HTTP协议【重点】</title>
    <link href="http://pythonlamb.github.io/2021/10/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94HTTP%E5%8D%8F%E8%AE%AE%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91/"/>
    <id>http://pythonlamb.github.io/2021/10/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94HTTP%E5%8D%8F%E8%AE%AE%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91/</id>
    <published>2021-10-11T07:48:34.000Z</published>
    <updated>2021-10-11T08:14:08.590Z</updated>
    
    <content type="html"><![CDATA[<p>本文主讲：在网络传输协议中常用的B/S架构以及HTTP传输协议【对爬虫来说非常重要】！</p><span id="more"></span>        <h2 id="HTTP协议概述【重点】"   >          <a href="#HTTP协议概述【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP协议概述【重点】" class="headerlink" title="HTTP协议概述【重点】"></a>HTTP协议概述【重点】</h2>              <h3 id="什么是HTTP协议"   >          <a href="#什么是HTTP协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h3>      <p>概念：</p><p>HTTP（Hypertext Transfer Protocol）叫超文本传输协议，是互联网上应用最为广泛的网络协议，所有的WWW文件必须遵守这个标准，设计HTTP的目的是提供一种发送和接收HTML页面（网页）的方法，因此HTTP协议就是在网络上传输HTML文本的协议，用于浏览器与服务器的通信</p><p>HTTP是客户端和网站服务端请求与响应的标准（TCP），客户端与服务器建立TCP连接后（客户端可以是浏览器、爬虫工具），客户端（浏览器、爬虫等）向服务端发送一个指定端口（默认端口为80）的HTTP请求协议，服务端一定会做出HTTP响应协议</p><p>超文本传输协议（HTTP）是一种应用层协议，它是基于TCP（面向有连接）的一种网络协议</p><p>HTTP模式：请求（requset）—— 响应（response）模式</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160351917.png"  alt="image-20211011160351917">      </p><p>因此，HTTP协议分成了两个部分：请求协议、响应协议</p>        <h3 id="HTTP协议的构成和作用"   >          <a href="#HTTP协议的构成和作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP协议的构成和作用" class="headerlink" title="HTTP协议的构成和作用"></a>HTTP协议的构成和作用</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160412649.png"  alt="image-20211011160412649">      </p><p>构成：不管是请求协议还是响应协议，都是由一个一个协议项所构成的，协议项形式如下：</p><p>协议名：协议内容（值）</p><p>例如：Host ： <span class="exturl"><a class="exturl__link"   href="http://www.gaoyang.com/" >www.gaoyang.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>注意事项：每一个协议项都要单独占一行！</p>        <h2 id="通过浏览器查看HTTP协议【重点】"   >          <a href="#通过浏览器查看HTTP协议【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过浏览器查看HTTP协议【重点】" class="headerlink" title="通过浏览器查看HTTP协议【重点】"></a>通过浏览器查看HTTP协议【重点】</h2>      <p>目标：学会使用 Edge 浏览器查看浏览器与百度网站的HTTP协议（请求协议、响应协议）！</p>        <h3 id="Edge浏览器查看HTTP协议（请求协议、响应协议）"   >          <a href="#Edge浏览器查看HTTP协议（请求协议、响应协议）" class="heading-link"><i class="fas fa-link"></i></a><a href="#Edge浏览器查看HTTP协议（请求协议、响应协议）" class="headerlink" title="Edge浏览器查看HTTP协议（请求协议、响应协议）"></a>Edge浏览器查看HTTP协议（请求协议、响应协议）</h3>      <p>第一步：在Edeg浏览器内按下F12进入开发者模式</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160434388.png"  alt="image-20211011160434388">      </p><p>第二步：点击网络进入</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160443401.png"  alt="image-20211011160443401">      </p><p>第三步：点击浏览器的刷新后点击<span class="exturl"><a class="exturl__link"   href="http://www.baidu.com/" >www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160452193.png"  alt="image-20211011160452193">      </p><p>第四步：点击标头，查看请求协议与响应协议</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160459972.png"  alt="image-20211011160459972">      </p><p>第五步：查看响应协议与请求协议的协议源（服务器发给客户端的原数据，没有被浏览器加工过的）</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160507379.png"  alt="image-20211011160507379">      </p><p>第六步：协议源（服务器发给客户端没有经过浏览器加工过的数据）截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160514369.png"  alt="image-20211011160514369">      </p>        <h2 id="HTTP请求协议报文格式【重点】"   >          <a href="#HTTP请求协议报文格式【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP请求协议报文格式【重点】" class="headerlink" title="HTTP请求协议报文格式【重点】"></a>HTTP请求协议报文格式【重点】</h2>              <h3 id="一：请求协议的报文格式"   >          <a href="#一：请求协议的报文格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#一：请求协议的报文格式" class="headerlink" title="一：请求协议的报文格式"></a>一：请求协议的报文格式</h3>      <p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160549702.png"  alt="image-20211011160549702">      </p><p>你问我答：在HTTP请求协议中，有两种常用的HTTP请求方式即 GET 模式与 POST 模式，那么它们两个在请求协议报文格式上有什么不同呢？</p><p>GET请求方式包含的内容：请求行、请求头、请求空行</p><p>POST请求方式包含的内容：请求行、请求头、请求空行、请求体</p>        <h3 id="请求行、请求头、请求空行和请求体的格式与代表的含义及注意事项"   >          <a href="#请求行、请求头、请求空行和请求体的格式与代表的含义及注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#请求行、请求头、请求空行和请求体的格式与代表的含义及注意事项" class="headerlink" title="请求行、请求头、请求空行和请求体的格式与代表的含义及注意事项"></a>请求行、请求头、请求空行和请求体的格式与代表的含义及注意事项</h3>      <p>请求行：</p><p>格式示例：GET / HTTP/1.1 </p><p>代表含义：其中GET代表请求方式、/ 代表浏览器（客户端）请求访问服务器上资源的路径 、HTTP/1.1是请求协议及版本</p><p>注意事项：</p><p>1：请求行需要单独占一行，来说明当前请求协议的基本信息</p><p>2：浏览器请求服务器的资源路径不包括域名</p><p>3：HTTP以前的版本是1.0，现在的版本是1.1</p><p>请求头****<strong>（很重要）</strong>：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160621760.png"  alt="image-20211011160621760">      </p><p>请求空行：用来分隔请求头和请求主体</p><p>请求主体：只有请求协议的方式是 POST 的时候，请求协议才有请求主体，请求主体是服务器发给浏览器的HTML数据</p>        <h3 id="利用网络调试助手充当TCP网站服务器，在利用浏览器（客户端）对这个服务器进行请求协议"   >          <a href="#利用网络调试助手充当TCP网站服务器，在利用浏览器（客户端）对这个服务器进行请求协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用网络调试助手充当TCP网站服务器，在利用浏览器（客户端）对这个服务器进行请求协议" class="headerlink" title="利用网络调试助手充当TCP网站服务器，在利用浏览器（客户端）对这个服务器进行请求协议"></a>利用网络调试助手充当TCP网站服务器，在利用浏览器（客户端）对这个服务器进行请求协议</h3>      <p>注意事项：客户端（浏览器）与网站服务器先要建立TCP连接，客户端才能向服务端发起请求协议</p><p>网络调试助手截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160637788.png"  alt="image-20211011160637788">      </p><p>浏览器（客户端）与调试助手建立 TCP 连接后发送请求协议截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160702158.png"  alt="image-20211011160702158">      </p><p>调试助手（服务端）接收到来自客户端的请求协议截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160708618.png"  alt="image-20211011160708618">      </p>        <h2 id="HTTP响应协议报文格式内容"   >          <a href="#HTTP响应协议报文格式内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP响应协议报文格式内容" class="headerlink" title="HTTP响应协议报文格式内容"></a>HTTP响应协议报文格式内容</h2>              <h3 id="响应协议"   >          <a href="#响应协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应协议" class="headerlink" title="响应协议"></a>响应协议</h3>      <p>概念：响应协议就是服务器收到客户端的请求协议后返回给浏览器数据的协议</p>        <h3 id="响应协议的报文内容"   >          <a href="#响应协议的报文内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应协议的报文内容" class="headerlink" title="响应协议的报文内容"></a>响应协议的报文内容</h3>      <p>响应行（状态行）：</p><p>响应行格式：响应的协议及版本 响应状态码 响应状态的描述</p><p>响应行示例：HTTP/1.1  200  ok</p><p>响应行截图（百度服务器）：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160729326.png"  alt="image-20211011160729326">      </p><p>状态码的分类及含义</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160738595.png"  alt="image-20211011160738595">      </p><p>注意事项：响应协议的响应行的状态码和状态码描述是一一对应的</p><p>响应头：由一些协议项所构成</p><p>响应头格式：协议名：协议值<br>响应头截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160755144.png"  alt="image-20211011160755144">      </p><p>响应空行：分隔响应头与响应主体（响应数据）</p><p>响应体（响应数据）：即网站服务器接收到浏览器（客户端）的请求后响应，发送给客户端的HTML数据！</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160805951.png"  alt="image-20211011160805951">      </p>        <h3 id="响应协议的响应行的状态码为-404-的含义"   >          <a href="#响应协议的响应行的状态码为-404-的含义" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应协议的响应行的状态码为-404-的含义" class="headerlink" title="响应协议的响应行的状态码为 404 的含义"></a>响应协议的响应行的状态码为 404 的含义</h3>      <p>答：响应行状态码为 404 代表浏览器请求的服务器页面（服务器资源），在服务器内找不到，即请求的资源在服务器内不存在</p>        <h3 id="网络调试助手模拟百度服务器向请求的浏览器发送数据（html）"   >          <a href="#网络调试助手模拟百度服务器向请求的浏览器发送数据（html）" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络调试助手模拟百度服务器向请求的浏览器发送数据（html）" class="headerlink" title="网络调试助手模拟百度服务器向请求的浏览器发送数据（html）"></a>网络调试助手模拟百度服务器向请求的浏览器发送数据（html）</h3>      <p>调试助手截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160824147.png"  alt="image-20211011160824147">      </p><p>浏览器（客户端）的截图</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160838554.png"  alt="image-20211011160838554">      </p>        <h2 id="长连接与短连接【重点】"   >          <a href="#长连接与短连接【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#长连接与短连接【重点】" class="headerlink" title="长连接与短连接【重点】"></a>长连接与短连接【重点】</h2>              <h3 id="长连接与短连接"   >          <a href="#长连接与短连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3>      <p>短连接：在HTTP1.0中，默认使用连接方式是短连接，浏览器与服务器每进行一次HTTP操作，就会建立、关闭一次TCP连接，即传输一个数据就要建立一次连接，两个就是建立两次连接</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160853203.png"  alt="image-20211011160853203">      </p><p>长连接：在HTTP1.1版本后，默认使用的是长连接，使用长连接的的HTTP协议，在响应头里面会有下面这段代码</p><p><code>Connection ： keep—alive</code></p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160904256.png"  alt="image-20211011160904256">      </p>        <h3 id="HTTP请求响应的短连接与长连接的优缺点"   >          <a href="#HTTP请求响应的短连接与长连接的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTTP请求响应的短连接与长连接的优缺点" class="headerlink" title="HTTP请求响应的短连接与长连接的优缺点"></a>HTTP请求响应的短连接与长连接的优缺点</h3>      <p>长连接：长连接可以省去较多的TCP建立、关闭连接的操作，节省时间，并且响应客户端的时间比短连接快很多，但是如果服务器访问人数过多的情况下会造成服务器负载过大而不可用（比如一台服务器同时支持500人访问，且长连接持续时间为10分钟，那么第501个人连接这台服务器，就要等十分钟以内的时间才可以访问即不可用，网站打不开）</p><p>短连接：短连接服务器实现起来比较简单，创建的都是有用的TCP连接，但是如果请求服务器的人数过多，就会在短时间内创建大量的连接（因为要建立连接、断开连接），会造成服务器响应客户端速度变慢（网站可以打开，但是速度贼慢，比如说民大选课官网）</p><p>总结：</p><p>1：一般小型Web网站都采用短连接，因为消耗服务器资源小</p><p>2：中大型Web网站一般采用长连接，优点是响应客户端的请求快，用户体验好</p><p>3：数据库的连接是长连接，因为短连接会频繁的建立、断开TCP连接，可能会造成socket错误</p>        <h2 id="案例）模拟浏览器（网络调试助手）请求服务器的过程【重点】"   >          <a href="#案例）模拟浏览器（网络调试助手）请求服务器的过程【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例）模拟浏览器（网络调试助手）请求服务器的过程【重点】" class="headerlink" title="案例）模拟浏览器（网络调试助手）请求服务器的过程【重点】"></a>案例）模拟浏览器（网络调试助手）请求服务器的过程【重点】</h2>              <h3 id="利用代码将网站域名解析为IP地址"   >          <a href="#利用代码将网站域名解析为IP地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用代码将网站域名解析为IP地址" class="headerlink" title="利用代码将网站域名解析为IP地址"></a>利用代码将网站域名解析为IP地址</h3>      <p>代码方法：套接字 . connect（（“网站域名”，80）） 在 connect（）方法底层，会自动将填写的域名解析为IP地址，从而与网站服务器建立 TCP 连接</p><p>注意事项：</p><p>1：浏览器请求网站服务器的步骤：与网站服务器建立TCP连接→浏览器向服务器发送请求协议→网站服务器响应浏览器发送响应协议→关闭TCP连接</p><p>2：在 python 中编写TCP客户端的 connect（）方法会自动网站域名解析为IP地址，用来与网站服务端创建TCP连接</p><p>3：网站服务器的端口默认为 80</p><p>​        </p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160936521.png"  alt="image-20211011160936521">      </p>        <h3 id="python-编写代码模拟浏览器（客户端）请求百度服务器的流程"   >          <a href="#python-编写代码模拟浏览器（客户端）请求百度服务器的流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#python-编写代码模拟浏览器（客户端）请求百度服务器的流程" class="headerlink" title="python 编写代码模拟浏览器（客户端）请求百度服务器的流程"></a>python 编写代码模拟浏览器（客户端）请求百度服务器的流程</h3>      <p>流程：导入socket模块→创建TCP套接字→利用connect（）方法与百度网站的服务器创建TCP连接→客户端利用套接字的send（）方法向服务端发起请求协议→百度服务器响应客户端的请求协议，客户端利用套接字的recv（）方法接收服务器响应协议→利用字符串的切片将响应体从响应协议内分离出来→将响应体（有用文件）保存到文件内→关闭套接字</p><p>快速代码体验：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011160947477.png"  alt="image-20211011160947477">      </p><p>注意事项：</p><p>1：截取响应体的时候为什么要查找“\r\n\r\n”呢？因为响应协议中响应体和响应头中间相隔了“\r\n\r\n”，查找出“\r\n\r\n”位置截取字符串即可</p><p>2：查找“\r\n\r\n”的时候，原始数据必须是字符串，而不是二进制数据，也就是代码中的 ws_data.decode().find(“\r\n\r\n”)，将ws_data二进制数据转为字符串</p><p>3：代码模拟浏览器客户端向服务器发送请求协议时，请求行的 HTTP 一定要大写！！！，否则会出现400错误</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161003318.png"  alt="image-20211011161003318">      </p>        <h3 id="格式化字符“-r”与“-n”和-“-r-n”-的作用"   >          <a href="#格式化字符“-r”与“-n”和-“-r-n”-的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#格式化字符“-r”与“-n”和-“-r-n”-的作用" class="headerlink" title="格式化字符“\r”与“\n”和 “\r\n” 的作用"></a>格式化字符“\r”与“\n”和 “\r\n” 的作用</h3>      <p>“\r”：不换行，将光标移动到本行行首</p><p>“\n”：换行，但是光标不移动到行首</p><p>“ \r\n”：相当于回车，换行并且光标移动至行首</p>        <h2 id="访问网站服务器的固定html文件【重要】"   >          <a href="#访问网站服务器的固定html文件【重要】" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问网站服务器的固定html文件【重要】" class="headerlink" title="访问网站服务器的固定html文件【重要】"></a>访问网站服务器的固定html文件【重要】</h2>              <h3 id="访问网站服务器上的固定文件"   >          <a href="#访问网站服务器上的固定文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#访问网站服务器上的固定文件" class="headerlink" title="访问网站服务器上的固定文件"></a>访问网站服务器上的固定文件</h3>      <p>访问方法：网站域名/文件名</p><p>访问示例：<span class="exturl"><a class="exturl__link"   href="http://www.baidu.com/a/b/ceshi.html" >www.baidu.com/a/b/ceshi.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>注意事项：</p><p>1：浏览器请求网站服务器（在浏览器上面仅输入网站域名），会自动打开服务器（服务器主机）根目录（Linux）下的 index.html 这个文件，<span class="exturl"><a class="exturl__link"   href="http://www.baidu.com/" >www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 与<span class="exturl"><a class="exturl__link"   href="http://www.baidu.com/index.html" >www.baidu.com/index.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 其实是一样的</p><p>2：浏览器想要访问服务器上面的其他文件需要在域名后面跟上服务器的文件路径，比如说<span class="exturl"><a class="exturl__link"   href="http://www.baidu.com/a/b/1.html%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%89%93%E5%BC%80%E7%99%BE%E5%BA%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84a%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8Bb%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%841.html%E6%96%87%E4%BB%B6" >www.baidu.com/a/b/1.html，就是打开百度服务器中根目录下的a文件夹下b文件夹下的1.html文件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>3：因为网站服务器也是计算机，一般操作系统都是Linux，所以访问网站服务器上的固定文件，都是访问这台计算机上面目录下的文件</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161033863.png"  alt="image-20211011161033863">      </p>        <h3 id="字符串的分割——split（）"   >          <a href="#字符串的分割——split（）" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串的分割——split（）" class="headerlink" title="字符串的分割——split（）"></a>字符串的分割——split（）</h3>      <p>功能：根据某个分隔符将字符串分割成一个列表，假入有n个分割符就有n+1个列表元素</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161045025.png"  alt="image-20211011161045025">      </p>        <h2 id="案例）编写代码模拟Web服务器"   >          <a href="#案例）编写代码模拟Web服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#案例）编写代码模拟Web服务器" class="headerlink" title="案例）编写代码模拟Web服务器"></a>案例）编写代码模拟Web服务器</h2>      <p>网站服务器向浏览器返回固定数据！  黑马程序员 P91</p><p>网站服务器向浏览器返回固定页面！ 黑马程序员 P92</p><p>网站服务器向浏览器返回指定页面！ 黑马程序员 P93</p><p>面向对象编程实现文件：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161059194.png"  alt="image-20211011161059194">      </p><p>​<br>​        </p><p>注意事项：在创建一个类的时候，在__init__ 方法下面，如果定义的变量在这个类的其他方法内要使用，就要将其变为这个类的实例化属性，即 self.xxxxx ，如果在其他方法内不使用，则不需要变为实例化属性</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161118750.png"  alt="image-20211011161118750">      </p><p>网站服务器向浏览器返回指定页面中存在的问题！ 黑马程序员 P94</p>        <h2 id="终端启动WEB服务器（python代码）【重点】"   >          <a href="#终端启动WEB服务器（python代码）【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#终端启动WEB服务器（python代码）【重点】" class="headerlink" title="终端启动WEB服务器（python代码）【重点】"></a>终端启动WEB服务器（python代码）【重点】</h2>              <h3 id="在终端中运行-py-文件的两种方法"   >          <a href="#在终端中运行-py-文件的两种方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#在终端中运行-py-文件的两种方法" class="headerlink" title="在终端中运行 py 文件的两种方法"></a>在终端中运行 py 文件的两种方法</h3>      <p>第一种方法：. /py文件名 方法</p><p>运行流程：</p><p>1：利用 pycharm 打开 py 文件后在文件代码第一行加上 # ！ Python 解释器路径，关闭文件</p><p>2：打开终端，利用 cd 指令进入需要运行 py 文件的相对文件路径，利用 chmod u+x 指令将py文件改为可运行</p><p>3：在终端输入 ./py文件名 运行文件（必须是./py文件名格式，否则报错）</p><p>第二种方法：</p><p>1：打开终端，利用 cd 指令进入需要运行 py 文件的相对文件路径，不需要将文件改为可运行文件！</p><p>2：在终端输入 python3 py文件名 即可运行（python3为python解释器，可以更改为其他版本）</p>        <h3 id="sys模块的argv方法"   >          <a href="#sys模块的argv方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#sys模块的argv方法" class="headerlink" title="sys模块的argv方法"></a>sys模块的argv方法</h3>      <p>功能：获取在终端命令行输入的参数（注意是参数，不是指令），并且返回一个列表传递给运行的py程序</p><p>代码格式：list1 = sys . argv</p><p>注意事项：</p><p>1：argv方法将命令行的参数保存至列表内后，传递给命令行中正在运行的那个程序</p><p>2：argv方法没有括号！！</p><p>3：命令行参数指的是参数，不是指令</p><p>快速代码体验</p><p>py代码</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161157451.png"  alt="image-20211011161157451">      </p><p>终端运行这个文件结果</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161209346.png"  alt="image-20211011161209346">      </p>        <h3 id="isdigit（）函数的作用"   >          <a href="#isdigit（）函数的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#isdigit（）函数的作用" class="headerlink" title="isdigit（）函数的作用"></a>isdigit（）函数的作用</h3>      <p>功能：判断某个字符串中是否只含有数字，如果只含有数字返回True，含有其他的（字母、单词等）则返回False</p><p>使用格式：字符串 . isdight( )</p><p>扩展应用：在终端运行web服务器（py文件），用于判断终端命令行输入的端口号是否为纯数字字符串，是则启动服务器，不是则写好的web服务器不启动</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161224105.png"  alt="image-20211011161224105">      </p>        <h3 id="在终端中运行特定端口号的-web-服务器（py程序）"   >          <a href="#在终端中运行特定端口号的-web-服务器（py程序）" class="heading-link"><i class="fas fa-link"></i></a><a href="#在终端中运行特定端口号的-web-服务器（py程序）" class="headerlink" title="在终端中运行特定端口号的 web 服务器（py程序）"></a>在终端中运行特定端口号的 web 服务器（py程序）</h3>      <p>示例：</p><p>功能：部署服务器的时候，服务器上面没有 pycharm，这时候我们就要用终端来运行写好的服务器文件了</p><p>运行语法格式：python3 py文件 绑定的端口号</p><p>注意事项：终端输入的端口号利用sys模块的argv方法传给py文件，服务器从而绑定端口号的时候绑定终端输入的端口号！</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161238744.png"  alt="image-20211011161238744">      </p>        <h2 id="游戏服务器的部署"   >          <a href="#游戏服务器的部署" class="heading-link"><i class="fas fa-link"></i></a><a href="#游戏服务器的部署" class="headerlink" title="游戏服务器的部署"></a>游戏服务器的部署</h2>              <h3 id="解决利用py代码书写服务器，向服务器内发布html游戏，浏览器不能成功解析html代码的问题"   >          <a href="#解决利用py代码书写服务器，向服务器内发布html游戏，浏览器不能成功解析html代码的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决利用py代码书写服务器，向服务器内发布html游戏，浏览器不能成功解析html代码的问题" class="headerlink" title="解决利用py代码书写服务器，向服务器内发布html游戏，浏览器不能成功解析html代码的问题"></a>解决利用py代码书写服务器，向服务器内发布html游戏，浏览器不能成功解析html代码的问题</h3>      <p>注意事项：</p><p>1：服务器向浏览器发布html游戏就是向浏览器（客户端）发送游戏的html代码（响应体）</p><p>2：浏览器不能成功解析html代码的问题就是，没有将游戏的html代码解析为html代码，而是解析为text文本</p><p>问题截图：</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161305287.png"  alt="image-20211011161305287">      </p><p>解决办法：</p><p>在服务器的响应头内加上这段代码即可让浏览器优先使用html解析服务器返回的数据，Content-Type：text/html </p>        <h3 id="类的注意事项"   >          <a href="#类的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#类的注意事项" class="headerlink" title="类的注意事项"></a>类的注意事项</h3>      <p>在利用类的时候，类的某个方法中有一个局部变量，但是我们想要这个局部变量在整个类中使用（其他类方法中），那我们就可以将它定义为类的实例属性，即 self . xxx = xxx</p><p>快速代码体验</p><p>没有将变量修改为实例属性前</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161319599.png"  alt="image-20211011161319599">      </p><p>修改为实例属性后</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161333104.png"  alt="image-20211011161333104">      </p>        <h2 id="字典的keys（）以及列表的enumerate（）方法"   >          <a href="#字典的keys（）以及列表的enumerate（）方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#字典的keys（）以及列表的enumerate（）方法" class="headerlink" title="字典的keys（）以及列表的enumerate（）方法"></a>字典的keys（）以及列表的enumerate（）方法</h2>              <h3 id="字典的-keys（）函数"   >          <a href="#字典的-keys（）函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#字典的-keys（）函数" class="headerlink" title="字典的 keys（）函数"></a>字典的 keys（）函数</h3>      <p>功能：将字典中所有的key值保存到一个可迭代对象中（不是列表）</p><p>语法：dict1.keys（）</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161350461.png"  alt="image-20211011161350461">      </p>        <h3 id="列表、可迭代对象的-enumerate（）函数"   >          <a href="#列表、可迭代对象的-enumerate（）函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表、可迭代对象的-enumerate（）函数" class="headerlink" title="列表、可迭代对象的 enumerate（）函数"></a>列表、可迭代对象的 enumerate（）函数</h3>      <p>功能：将列表或者可迭代对象的元素列出来，并且将每个元素的索引和数据保存至元组内后再次保存至可迭代对象中</p><p>语法：enumerate（list1，start = 0）：</p><p>注意事项：</p><p>1：start = 0 可以省略，默认下标为 0</p><p>2：数据返回的下标值是整形（int）</p><p>快速代码体验</p><p>        <img   class="lazyload lazyload-block"          src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://gitee.com/PythonLamb/blogimgs/raw/master/img/image-20211011161404102.png"  alt="image-20211011161404102">      </p><p>未完待续….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主讲：在网络传输协议中常用的B/S架构以及HTTP传输协议【对爬虫来说非常重要】！&lt;/p&gt;</summary>
    
    
    
    <category term="通信协议篇" scheme="http://pythonlamb.github.io/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AF%87/"/>
    
    
    <category term="通信协议篇" scheme="http://pythonlamb.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AF%87/"/>
    
  </entry>
  
</feed>
